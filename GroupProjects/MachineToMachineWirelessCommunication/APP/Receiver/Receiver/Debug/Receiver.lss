
Receiver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000031b2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00800060  000031b2  00003246  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  0080016e  0080016e  00003354  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003354  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003384  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005e0  00000000  00000000  000033c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006f3c  00000000  00000000  000039a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ea9  00000000  00000000  0000a8dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000473b  00000000  00000000  0000c785  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000df0  00000000  00000000  00010ec0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001fda  00000000  00000000  00011cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004a1d  00000000  00000000  00013c8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000530  00000000  00000000  000186a7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 39 00 	jmp	0x72	; 0x72 <__ctors_end>
       4:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
       8:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
       c:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      10:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      14:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      18:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      1c:	0c 94 3b 02 	jmp	0x476	; 0x476 <__vector_7>
      20:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      24:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      28:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      2c:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      30:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      34:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      38:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      3c:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      40:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      44:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      48:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      4c:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      50:	0c 94 56 00 	jmp	0xac	; 0xac <__bad_interrupt>
      54:	41 0e       	add	r4, r17
      56:	4c 0e       	add	r4, r28
      58:	57 0e       	add	r5, r23
      5a:	62 0e       	add	r6, r18
      5c:	6d 0e       	add	r6, r29
      5e:	78 0e       	add	r7, r24
      60:	83 0e       	add	r8, r19
      62:	95 12       	cpse	r9, r21
      64:	b1 12       	cpse	r11, r17
      66:	cd 12       	cpse	r12, r29
      68:	f7 12       	cpse	r15, r23
      6a:	25 13       	cpse	r18, r21
      6c:	5c 13       	cpse	r21, r28
      6e:	0c 15       	cp	r16, r12
      70:	28 15       	cp	r18, r8

00000072 <__ctors_end>:
      72:	11 24       	eor	r1, r1
      74:	1f be       	out	0x3f, r1	; 63
      76:	cf e5       	ldi	r28, 0x5F	; 95
      78:	d8 e0       	ldi	r29, 0x08	; 8
      7a:	de bf       	out	0x3e, r29	; 62
      7c:	cd bf       	out	0x3d, r28	; 61

0000007e <__do_copy_data>:
      7e:	11 e0       	ldi	r17, 0x01	; 1
      80:	a0 e6       	ldi	r26, 0x60	; 96
      82:	b0 e0       	ldi	r27, 0x00	; 0
      84:	e2 eb       	ldi	r30, 0xB2	; 178
      86:	f1 e3       	ldi	r31, 0x31	; 49
      88:	02 c0       	rjmp	.+4      	; 0x8e <__do_copy_data+0x10>
      8a:	05 90       	lpm	r0, Z+
      8c:	0d 92       	st	X+, r0
      8e:	ae 36       	cpi	r26, 0x6E	; 110
      90:	b1 07       	cpc	r27, r17
      92:	d9 f7       	brne	.-10     	; 0x8a <__do_copy_data+0xc>

00000094 <__do_clear_bss>:
      94:	27 e0       	ldi	r18, 0x07	; 7
      96:	ae e6       	ldi	r26, 0x6E	; 110
      98:	b1 e0       	ldi	r27, 0x01	; 1
      9a:	01 c0       	rjmp	.+2      	; 0x9e <.do_clear_bss_start>

0000009c <.do_clear_bss_loop>:
      9c:	1d 92       	st	X+, r1

0000009e <.do_clear_bss_start>:
      9e:	a5 3c       	cpi	r26, 0xC5	; 197
      a0:	b2 07       	cpc	r27, r18
      a2:	e1 f7       	brne	.-8      	; 0x9c <.do_clear_bss_loop>
      a4:	0e 94 31 16 	call	0x2c62	; 0x2c62 <main>
      a8:	0c 94 d7 18 	jmp	0x31ae	; 0x31ae <_exit>

000000ac <__bad_interrupt>:
      ac:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      b0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      b2:	03 96       	adiw	r24, 0x03	; 3
      b4:	92 83       	std	Z+2, r25	; 0x02
      b6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      b8:	2f ef       	ldi	r18, 0xFF	; 255
      ba:	3f ef       	ldi	r19, 0xFF	; 255
      bc:	34 83       	std	Z+4, r19	; 0x04
      be:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      c0:	96 83       	std	Z+6, r25	; 0x06
      c2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      c4:	90 87       	std	Z+8, r25	; 0x08
      c6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      c8:	10 82       	st	Z, r1
      ca:	08 95       	ret

000000cc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      cc:	fc 01       	movw	r30, r24
      ce:	11 86       	std	Z+9, r1	; 0x09
      d0:	10 86       	std	Z+8, r1	; 0x08
      d2:	08 95       	ret

000000d4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      d4:	cf 93       	push	r28
      d6:	df 93       	push	r29
      d8:	9c 01       	movw	r18, r24
      da:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      dc:	dc 01       	movw	r26, r24
      de:	11 96       	adiw	r26, 0x01	; 1
      e0:	cd 91       	ld	r28, X+
      e2:	dc 91       	ld	r29, X
      e4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      e6:	d3 83       	std	Z+3, r29	; 0x03
      e8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      ea:	8c 81       	ldd	r24, Y+4	; 0x04
      ec:	9d 81       	ldd	r25, Y+5	; 0x05
      ee:	95 83       	std	Z+5, r25	; 0x05
      f0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      f2:	8c 81       	ldd	r24, Y+4	; 0x04
      f4:	9d 81       	ldd	r25, Y+5	; 0x05
      f6:	dc 01       	movw	r26, r24
      f8:	13 96       	adiw	r26, 0x03	; 3
      fa:	7c 93       	st	X, r23
      fc:	6e 93       	st	-X, r22
      fe:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     100:	7d 83       	std	Y+5, r23	; 0x05
     102:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     104:	31 87       	std	Z+9, r19	; 0x09
     106:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     108:	f9 01       	movw	r30, r18
     10a:	80 81       	ld	r24, Z
     10c:	8f 5f       	subi	r24, 0xFF	; 255
     10e:	80 83       	st	Z, r24
}
     110:	df 91       	pop	r29
     112:	cf 91       	pop	r28
     114:	08 95       	ret

00000116 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     116:	cf 93       	push	r28
     118:	df 93       	push	r29
     11a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     11c:	48 81       	ld	r20, Y
     11e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     120:	4f 3f       	cpi	r20, 0xFF	; 255
     122:	2f ef       	ldi	r18, 0xFF	; 255
     124:	52 07       	cpc	r21, r18
     126:	21 f4       	brne	.+8      	; 0x130 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     128:	fc 01       	movw	r30, r24
     12a:	a7 81       	ldd	r26, Z+7	; 0x07
     12c:	b0 85       	ldd	r27, Z+8	; 0x08
     12e:	0d c0       	rjmp	.+26     	; 0x14a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     130:	dc 01       	movw	r26, r24
     132:	13 96       	adiw	r26, 0x03	; 3
     134:	01 c0       	rjmp	.+2      	; 0x138 <vListInsert+0x22>
     136:	df 01       	movw	r26, r30
     138:	12 96       	adiw	r26, 0x02	; 2
     13a:	ed 91       	ld	r30, X+
     13c:	fc 91       	ld	r31, X
     13e:	13 97       	sbiw	r26, 0x03	; 3
     140:	20 81       	ld	r18, Z
     142:	31 81       	ldd	r19, Z+1	; 0x01
     144:	42 17       	cp	r20, r18
     146:	53 07       	cpc	r21, r19
     148:	b0 f7       	brcc	.-20     	; 0x136 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     14a:	12 96       	adiw	r26, 0x02	; 2
     14c:	ed 91       	ld	r30, X+
     14e:	fc 91       	ld	r31, X
     150:	13 97       	sbiw	r26, 0x03	; 3
     152:	fb 83       	std	Y+3, r31	; 0x03
     154:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     156:	d5 83       	std	Z+5, r29	; 0x05
     158:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     15a:	bd 83       	std	Y+5, r27	; 0x05
     15c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     15e:	13 96       	adiw	r26, 0x03	; 3
     160:	dc 93       	st	X, r29
     162:	ce 93       	st	-X, r28
     164:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     166:	99 87       	std	Y+9, r25	; 0x09
     168:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     16a:	fc 01       	movw	r30, r24
     16c:	20 81       	ld	r18, Z
     16e:	2f 5f       	subi	r18, 0xFF	; 255
     170:	20 83       	st	Z, r18
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     17e:	a0 85       	ldd	r26, Z+8	; 0x08
     180:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     182:	c2 81       	ldd	r28, Z+2	; 0x02
     184:	d3 81       	ldd	r29, Z+3	; 0x03
     186:	84 81       	ldd	r24, Z+4	; 0x04
     188:	95 81       	ldd	r25, Z+5	; 0x05
     18a:	9d 83       	std	Y+5, r25	; 0x05
     18c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     18e:	c4 81       	ldd	r28, Z+4	; 0x04
     190:	d5 81       	ldd	r29, Z+5	; 0x05
     192:	82 81       	ldd	r24, Z+2	; 0x02
     194:	93 81       	ldd	r25, Z+3	; 0x03
     196:	9b 83       	std	Y+3, r25	; 0x03
     198:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     19a:	11 96       	adiw	r26, 0x01	; 1
     19c:	8d 91       	ld	r24, X+
     19e:	9c 91       	ld	r25, X
     1a0:	12 97       	sbiw	r26, 0x02	; 2
     1a2:	e8 17       	cp	r30, r24
     1a4:	f9 07       	cpc	r31, r25
     1a6:	31 f4       	brne	.+12     	; 0x1b4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1a8:	84 81       	ldd	r24, Z+4	; 0x04
     1aa:	95 81       	ldd	r25, Z+5	; 0x05
     1ac:	12 96       	adiw	r26, 0x02	; 2
     1ae:	9c 93       	st	X, r25
     1b0:	8e 93       	st	-X, r24
     1b2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1b4:	11 86       	std	Z+9, r1	; 0x09
     1b6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1b8:	8c 91       	ld	r24, X
     1ba:	81 50       	subi	r24, 0x01	; 1
     1bc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1be:	df 91       	pop	r29
     1c0:	cf 91       	pop	r28
     1c2:	08 95       	ret

000001c4 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     1c4:	1b bc       	out	0x2b, r1	; 43
     1c6:	89 ef       	ldi	r24, 0xF9	; 249
     1c8:	8a bd       	out	0x2a, r24	; 42
     1ca:	8b e0       	ldi	r24, 0x0B	; 11
     1cc:	8e bd       	out	0x2e, r24	; 46
     1ce:	89 b7       	in	r24, 0x39	; 57
     1d0:	80 61       	ori	r24, 0x10	; 16
     1d2:	89 bf       	out	0x39, r24	; 57
     1d4:	08 95       	ret

000001d6 <pxPortInitialiseStack>:
     1d6:	31 e1       	ldi	r19, 0x11	; 17
     1d8:	fc 01       	movw	r30, r24
     1da:	30 83       	st	Z, r19
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	22 e2       	ldi	r18, 0x22	; 34
     1e0:	20 83       	st	Z, r18
     1e2:	31 97       	sbiw	r30, 0x01	; 1
     1e4:	a3 e3       	ldi	r26, 0x33	; 51
     1e6:	a0 83       	st	Z, r26
     1e8:	31 97       	sbiw	r30, 0x01	; 1
     1ea:	60 83       	st	Z, r22
     1ec:	31 97       	sbiw	r30, 0x01	; 1
     1ee:	70 83       	st	Z, r23
     1f0:	31 97       	sbiw	r30, 0x01	; 1
     1f2:	10 82       	st	Z, r1
     1f4:	31 97       	sbiw	r30, 0x01	; 1
     1f6:	60 e8       	ldi	r22, 0x80	; 128
     1f8:	60 83       	st	Z, r22
     1fa:	31 97       	sbiw	r30, 0x01	; 1
     1fc:	10 82       	st	Z, r1
     1fe:	31 97       	sbiw	r30, 0x01	; 1
     200:	62 e0       	ldi	r22, 0x02	; 2
     202:	60 83       	st	Z, r22
     204:	31 97       	sbiw	r30, 0x01	; 1
     206:	63 e0       	ldi	r22, 0x03	; 3
     208:	60 83       	st	Z, r22
     20a:	31 97       	sbiw	r30, 0x01	; 1
     20c:	64 e0       	ldi	r22, 0x04	; 4
     20e:	60 83       	st	Z, r22
     210:	31 97       	sbiw	r30, 0x01	; 1
     212:	65 e0       	ldi	r22, 0x05	; 5
     214:	60 83       	st	Z, r22
     216:	31 97       	sbiw	r30, 0x01	; 1
     218:	66 e0       	ldi	r22, 0x06	; 6
     21a:	60 83       	st	Z, r22
     21c:	31 97       	sbiw	r30, 0x01	; 1
     21e:	67 e0       	ldi	r22, 0x07	; 7
     220:	60 83       	st	Z, r22
     222:	31 97       	sbiw	r30, 0x01	; 1
     224:	68 e0       	ldi	r22, 0x08	; 8
     226:	60 83       	st	Z, r22
     228:	31 97       	sbiw	r30, 0x01	; 1
     22a:	69 e0       	ldi	r22, 0x09	; 9
     22c:	60 83       	st	Z, r22
     22e:	31 97       	sbiw	r30, 0x01	; 1
     230:	60 e1       	ldi	r22, 0x10	; 16
     232:	60 83       	st	Z, r22
     234:	31 97       	sbiw	r30, 0x01	; 1
     236:	30 83       	st	Z, r19
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	32 e1       	ldi	r19, 0x12	; 18
     23c:	30 83       	st	Z, r19
     23e:	31 97       	sbiw	r30, 0x01	; 1
     240:	33 e1       	ldi	r19, 0x13	; 19
     242:	30 83       	st	Z, r19
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	34 e1       	ldi	r19, 0x14	; 20
     248:	30 83       	st	Z, r19
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	35 e1       	ldi	r19, 0x15	; 21
     24e:	30 83       	st	Z, r19
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	36 e1       	ldi	r19, 0x16	; 22
     254:	30 83       	st	Z, r19
     256:	31 97       	sbiw	r30, 0x01	; 1
     258:	37 e1       	ldi	r19, 0x17	; 23
     25a:	30 83       	st	Z, r19
     25c:	31 97       	sbiw	r30, 0x01	; 1
     25e:	38 e1       	ldi	r19, 0x18	; 24
     260:	30 83       	st	Z, r19
     262:	31 97       	sbiw	r30, 0x01	; 1
     264:	39 e1       	ldi	r19, 0x19	; 25
     266:	30 83       	st	Z, r19
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	30 e2       	ldi	r19, 0x20	; 32
     26c:	30 83       	st	Z, r19
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	31 e2       	ldi	r19, 0x21	; 33
     272:	30 83       	st	Z, r19
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	20 83       	st	Z, r18
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	23 e2       	ldi	r18, 0x23	; 35
     27c:	20 83       	st	Z, r18
     27e:	31 97       	sbiw	r30, 0x01	; 1
     280:	40 83       	st	Z, r20
     282:	31 97       	sbiw	r30, 0x01	; 1
     284:	50 83       	st	Z, r21
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	26 e2       	ldi	r18, 0x26	; 38
     28a:	20 83       	st	Z, r18
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	27 e2       	ldi	r18, 0x27	; 39
     290:	20 83       	st	Z, r18
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	28 e2       	ldi	r18, 0x28	; 40
     296:	20 83       	st	Z, r18
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	29 e2       	ldi	r18, 0x29	; 41
     29c:	20 83       	st	Z, r18
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	20 e3       	ldi	r18, 0x30	; 48
     2a2:	20 83       	st	Z, r18
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	21 e3       	ldi	r18, 0x31	; 49
     2a8:	20 83       	st	Z, r18
     2aa:	86 97       	sbiw	r24, 0x26	; 38
     2ac:	08 95       	ret

000002ae <xPortStartScheduler>:
     2ae:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <prvSetupTimerInterrupt>
     2b2:	a0 91 a7 07 	lds	r26, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     2b6:	b0 91 a8 07 	lds	r27, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     2ba:	cd 91       	ld	r28, X+
     2bc:	cd bf       	out	0x3d, r28	; 61
     2be:	dd 91       	ld	r29, X+
     2c0:	de bf       	out	0x3e, r29	; 62
     2c2:	ff 91       	pop	r31
     2c4:	ef 91       	pop	r30
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	bf 91       	pop	r27
     2cc:	af 91       	pop	r26
     2ce:	9f 91       	pop	r25
     2d0:	8f 91       	pop	r24
     2d2:	7f 91       	pop	r23
     2d4:	6f 91       	pop	r22
     2d6:	5f 91       	pop	r21
     2d8:	4f 91       	pop	r20
     2da:	3f 91       	pop	r19
     2dc:	2f 91       	pop	r18
     2de:	1f 91       	pop	r17
     2e0:	0f 91       	pop	r16
     2e2:	ff 90       	pop	r15
     2e4:	ef 90       	pop	r14
     2e6:	df 90       	pop	r13
     2e8:	cf 90       	pop	r12
     2ea:	bf 90       	pop	r11
     2ec:	af 90       	pop	r10
     2ee:	9f 90       	pop	r9
     2f0:	8f 90       	pop	r8
     2f2:	7f 90       	pop	r7
     2f4:	6f 90       	pop	r6
     2f6:	5f 90       	pop	r5
     2f8:	4f 90       	pop	r4
     2fa:	3f 90       	pop	r3
     2fc:	2f 90       	pop	r2
     2fe:	1f 90       	pop	r1
     300:	0f 90       	pop	r0
     302:	0f be       	out	0x3f, r0	; 63
     304:	0f 90       	pop	r0
     306:	08 95       	ret
     308:	81 e0       	ldi	r24, 0x01	; 1
     30a:	08 95       	ret

0000030c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     30c:	0f 92       	push	r0
     30e:	0f b6       	in	r0, 0x3f	; 63
     310:	f8 94       	cli
     312:	0f 92       	push	r0
     314:	1f 92       	push	r1
     316:	11 24       	eor	r1, r1
     318:	2f 92       	push	r2
     31a:	3f 92       	push	r3
     31c:	4f 92       	push	r4
     31e:	5f 92       	push	r5
     320:	6f 92       	push	r6
     322:	7f 92       	push	r7
     324:	8f 92       	push	r8
     326:	9f 92       	push	r9
     328:	af 92       	push	r10
     32a:	bf 92       	push	r11
     32c:	cf 92       	push	r12
     32e:	df 92       	push	r13
     330:	ef 92       	push	r14
     332:	ff 92       	push	r15
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	2f 93       	push	r18
     33a:	3f 93       	push	r19
     33c:	4f 93       	push	r20
     33e:	5f 93       	push	r21
     340:	6f 93       	push	r22
     342:	7f 93       	push	r23
     344:	8f 93       	push	r24
     346:	9f 93       	push	r25
     348:	af 93       	push	r26
     34a:	bf 93       	push	r27
     34c:	cf 93       	push	r28
     34e:	df 93       	push	r29
     350:	ef 93       	push	r30
     352:	ff 93       	push	r31
     354:	a0 91 a7 07 	lds	r26, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     358:	b0 91 a8 07 	lds	r27, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     35c:	0d b6       	in	r0, 0x3d	; 61
     35e:	0d 92       	st	X+, r0
     360:	0e b6       	in	r0, 0x3e	; 62
     362:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     364:	0e 94 d6 06 	call	0xdac	; 0xdac <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     368:	a0 91 a7 07 	lds	r26, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     36c:	b0 91 a8 07 	lds	r27, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     370:	cd 91       	ld	r28, X+
     372:	cd bf       	out	0x3d, r28	; 61
     374:	dd 91       	ld	r29, X+
     376:	de bf       	out	0x3e, r29	; 62
     378:	ff 91       	pop	r31
     37a:	ef 91       	pop	r30
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	bf 91       	pop	r27
     382:	af 91       	pop	r26
     384:	9f 91       	pop	r25
     386:	8f 91       	pop	r24
     388:	7f 91       	pop	r23
     38a:	6f 91       	pop	r22
     38c:	5f 91       	pop	r21
     38e:	4f 91       	pop	r20
     390:	3f 91       	pop	r19
     392:	2f 91       	pop	r18
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	ff 90       	pop	r15
     39a:	ef 90       	pop	r14
     39c:	df 90       	pop	r13
     39e:	cf 90       	pop	r12
     3a0:	bf 90       	pop	r11
     3a2:	af 90       	pop	r10
     3a4:	9f 90       	pop	r9
     3a6:	8f 90       	pop	r8
     3a8:	7f 90       	pop	r7
     3aa:	6f 90       	pop	r6
     3ac:	5f 90       	pop	r5
     3ae:	4f 90       	pop	r4
     3b0:	3f 90       	pop	r3
     3b2:	2f 90       	pop	r2
     3b4:	1f 90       	pop	r1
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
     3bc:	08 95       	ret

000003be <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3be:	0f 92       	push	r0
     3c0:	0f b6       	in	r0, 0x3f	; 63
     3c2:	f8 94       	cli
     3c4:	0f 92       	push	r0
     3c6:	1f 92       	push	r1
     3c8:	11 24       	eor	r1, r1
     3ca:	2f 92       	push	r2
     3cc:	3f 92       	push	r3
     3ce:	4f 92       	push	r4
     3d0:	5f 92       	push	r5
     3d2:	6f 92       	push	r6
     3d4:	7f 92       	push	r7
     3d6:	8f 92       	push	r8
     3d8:	9f 92       	push	r9
     3da:	af 92       	push	r10
     3dc:	bf 92       	push	r11
     3de:	cf 92       	push	r12
     3e0:	df 92       	push	r13
     3e2:	ef 92       	push	r14
     3e4:	ff 92       	push	r15
     3e6:	0f 93       	push	r16
     3e8:	1f 93       	push	r17
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	4f 93       	push	r20
     3f0:	5f 93       	push	r21
     3f2:	6f 93       	push	r22
     3f4:	7f 93       	push	r23
     3f6:	8f 93       	push	r24
     3f8:	9f 93       	push	r25
     3fa:	af 93       	push	r26
     3fc:	bf 93       	push	r27
     3fe:	cf 93       	push	r28
     400:	df 93       	push	r29
     402:	ef 93       	push	r30
     404:	ff 93       	push	r31
     406:	a0 91 a7 07 	lds	r26, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     40a:	b0 91 a8 07 	lds	r27, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     40e:	0d b6       	in	r0, 0x3d	; 61
     410:	0d 92       	st	X+, r0
     412:	0e b6       	in	r0, 0x3e	; 62
     414:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     416:	0e 94 69 05 	call	0xad2	; 0xad2 <xTaskIncrementTick>
     41a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     41c:	0e 94 d6 06 	call	0xdac	; 0xdac <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     420:	a0 91 a7 07 	lds	r26, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     424:	b0 91 a8 07 	lds	r27, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     428:	cd 91       	ld	r28, X+
     42a:	cd bf       	out	0x3d, r28	; 61
     42c:	dd 91       	ld	r29, X+
     42e:	de bf       	out	0x3e, r29	; 62
     430:	ff 91       	pop	r31
     432:	ef 91       	pop	r30
     434:	df 91       	pop	r29
     436:	cf 91       	pop	r28
     438:	bf 91       	pop	r27
     43a:	af 91       	pop	r26
     43c:	9f 91       	pop	r25
     43e:	8f 91       	pop	r24
     440:	7f 91       	pop	r23
     442:	6f 91       	pop	r22
     444:	5f 91       	pop	r21
     446:	4f 91       	pop	r20
     448:	3f 91       	pop	r19
     44a:	2f 91       	pop	r18
     44c:	1f 91       	pop	r17
     44e:	0f 91       	pop	r16
     450:	ff 90       	pop	r15
     452:	ef 90       	pop	r14
     454:	df 90       	pop	r13
     456:	cf 90       	pop	r12
     458:	bf 90       	pop	r11
     45a:	af 90       	pop	r10
     45c:	9f 90       	pop	r9
     45e:	8f 90       	pop	r8
     460:	7f 90       	pop	r7
     462:	6f 90       	pop	r6
     464:	5f 90       	pop	r5
     466:	4f 90       	pop	r4
     468:	3f 90       	pop	r3
     46a:	2f 90       	pop	r2
     46c:	1f 90       	pop	r1
     46e:	0f 90       	pop	r0
     470:	0f be       	out	0x3f, r0	; 63
     472:	0f 90       	pop	r0

	asm volatile ( "ret" );
     474:	08 95       	ret

00000476 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     476:	0e 94 df 01 	call	0x3be	; 0x3be <vPortYieldFromTick>
		asm volatile ( "reti" );
     47a:	18 95       	reti

0000047c <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     47c:	e6 e7       	ldi	r30, 0x76	; 118
     47e:	f1 e0       	ldi	r31, 0x01	; 1
     480:	aa e7       	ldi	r26, 0x7A	; 122
     482:	b1 e0       	ldi	r27, 0x01	; 1
     484:	b1 83       	std	Z+1, r27	; 0x01
     486:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     488:	13 82       	std	Z+3, r1	; 0x03
     48a:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     48c:	e2 e5       	ldi	r30, 0x52	; 82
     48e:	f7 e0       	ldi	r31, 0x07	; 7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     490:	f0 93 75 01 	sts	0x0175, r31	; 0x800175 <pxEnd+0x1>
     494:	e0 93 74 01 	sts	0x0174, r30	; 0x800174 <pxEnd>
	pxEnd->xBlockSize = 0;
     498:	13 82       	std	Z+3, r1	; 0x03
     49a:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     49c:	11 82       	std	Z+1, r1	; 0x01
     49e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     4a0:	88 ed       	ldi	r24, 0xD8	; 216
     4a2:	95 e0       	ldi	r25, 0x05	; 5
     4a4:	13 96       	adiw	r26, 0x03	; 3
     4a6:	9c 93       	st	X, r25
     4a8:	8e 93       	st	-X, r24
     4aa:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     4ac:	ed 93       	st	X+, r30
     4ae:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4b0:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <xMinimumEverFreeBytesRemaining+0x1>
     4b4:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4b8:	90 93 73 01 	sts	0x0173, r25	; 0x800173 <xFreeBytesRemaining+0x1>
     4bc:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	90 e8       	ldi	r25, 0x80	; 128
     4c4:	90 93 6f 01 	sts	0x016F, r25	; 0x80016f <__data_end+0x1>
     4c8:	80 93 6e 01 	sts	0x016E, r24	; 0x80016e <__data_end>
     4cc:	08 95       	ret

000004ce <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     4ce:	cf 93       	push	r28
     4d0:	df 93       	push	r29
     4d2:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     4d4:	a6 e7       	ldi	r26, 0x76	; 118
     4d6:	b1 e0       	ldi	r27, 0x01	; 1
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <prvInsertBlockIntoFreeList+0xe>
     4da:	df 01       	movw	r26, r30
     4dc:	ed 91       	ld	r30, X+
     4de:	fc 91       	ld	r31, X
     4e0:	11 97       	sbiw	r26, 0x01	; 1
     4e2:	ec 17       	cp	r30, r28
     4e4:	fd 07       	cpc	r31, r29
     4e6:	c8 f3       	brcs	.-14     	; 0x4da <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     4e8:	12 96       	adiw	r26, 0x02	; 2
     4ea:	8d 91       	ld	r24, X+
     4ec:	9c 91       	ld	r25, X
     4ee:	13 97       	sbiw	r26, 0x03	; 3
     4f0:	9d 01       	movw	r18, r26
     4f2:	28 0f       	add	r18, r24
     4f4:	39 1f       	adc	r19, r25
     4f6:	c2 17       	cp	r28, r18
     4f8:	d3 07       	cpc	r29, r19
     4fa:	49 f4       	brne	.+18     	; 0x50e <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     4fc:	2a 81       	ldd	r18, Y+2	; 0x02
     4fe:	3b 81       	ldd	r19, Y+3	; 0x03
     500:	82 0f       	add	r24, r18
     502:	93 1f       	adc	r25, r19
     504:	13 96       	adiw	r26, 0x03	; 3
     506:	9c 93       	st	X, r25
     508:	8e 93       	st	-X, r24
     50a:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     50c:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     50e:	8a 81       	ldd	r24, Y+2	; 0x02
     510:	9b 81       	ldd	r25, Y+3	; 0x03
     512:	9e 01       	movw	r18, r28
     514:	28 0f       	add	r18, r24
     516:	39 1f       	adc	r19, r25
     518:	e2 17       	cp	r30, r18
     51a:	f3 07       	cpc	r31, r19
     51c:	c1 f4       	brne	.+48     	; 0x54e <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     51e:	20 91 74 01 	lds	r18, 0x0174	; 0x800174 <pxEnd>
     522:	30 91 75 01 	lds	r19, 0x0175	; 0x800175 <pxEnd+0x1>
     526:	e2 17       	cp	r30, r18
     528:	f3 07       	cpc	r31, r19
     52a:	71 f0       	breq	.+28     	; 0x548 <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     52c:	22 81       	ldd	r18, Z+2	; 0x02
     52e:	33 81       	ldd	r19, Z+3	; 0x03
     530:	82 0f       	add	r24, r18
     532:	93 1f       	adc	r25, r19
     534:	9b 83       	std	Y+3, r25	; 0x03
     536:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     538:	ed 91       	ld	r30, X+
     53a:	fc 91       	ld	r31, X
     53c:	11 97       	sbiw	r26, 0x01	; 1
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	99 83       	std	Y+1, r25	; 0x01
     544:	88 83       	st	Y, r24
     546:	05 c0       	rjmp	.+10     	; 0x552 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     548:	39 83       	std	Y+1, r19	; 0x01
     54a:	28 83       	st	Y, r18
     54c:	02 c0       	rjmp	.+4      	; 0x552 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     54e:	f9 83       	std	Y+1, r31	; 0x01
     550:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     552:	ca 17       	cp	r28, r26
     554:	db 07       	cpc	r29, r27
     556:	11 f0       	breq	.+4      	; 0x55c <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     558:	cd 93       	st	X+, r28
     55a:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     55c:	df 91       	pop	r29
     55e:	cf 91       	pop	r28
     560:	08 95       	ret

00000562 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     562:	ef 92       	push	r14
     564:	ff 92       	push	r15
     566:	0f 93       	push	r16
     568:	1f 93       	push	r17
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     570:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     574:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <pxEnd>
     578:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <pxEnd+0x1>
     57c:	89 2b       	or	r24, r25
     57e:	11 f4       	brne	.+4      	; 0x584 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     580:	0e 94 3e 02 	call	0x47c	; 0x47c <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     584:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <__data_end>
     588:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <__data_end+0x1>
     58c:	80 23       	and	r24, r16
     58e:	91 23       	and	r25, r17
     590:	89 2b       	or	r24, r25
     592:	09 f0       	breq	.+2      	; 0x596 <pvPortMalloc+0x34>
     594:	67 c0       	rjmp	.+206    	; 0x664 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     596:	01 15       	cp	r16, r1
     598:	11 05       	cpc	r17, r1
     59a:	11 f0       	breq	.+4      	; 0x5a0 <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     59c:	0c 5f       	subi	r16, 0xFC	; 252
     59e:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     5a0:	01 15       	cp	r16, r1
     5a2:	11 05       	cpc	r17, r1
     5a4:	09 f4       	brne	.+2      	; 0x5a8 <pvPortMalloc+0x46>
     5a6:	61 c0       	rjmp	.+194    	; 0x66a <pvPortMalloc+0x108>
     5a8:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <xFreeBytesRemaining>
     5ac:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <xFreeBytesRemaining+0x1>
     5b0:	80 17       	cp	r24, r16
     5b2:	91 07       	cpc	r25, r17
     5b4:	08 f4       	brcc	.+2      	; 0x5b8 <pvPortMalloc+0x56>
     5b6:	5c c0       	rjmp	.+184    	; 0x670 <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     5b8:	c0 91 76 01 	lds	r28, 0x0176	; 0x800176 <xStart>
     5bc:	d0 91 77 01 	lds	r29, 0x0177	; 0x800177 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5c0:	e6 e7       	ldi	r30, 0x76	; 118
     5c2:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5c4:	02 c0       	rjmp	.+4      	; 0x5ca <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     5c6:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     5c8:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5ca:	8a 81       	ldd	r24, Y+2	; 0x02
     5cc:	9b 81       	ldd	r25, Y+3	; 0x03
     5ce:	80 17       	cp	r24, r16
     5d0:	91 07       	cpc	r25, r17
     5d2:	20 f4       	brcc	.+8      	; 0x5dc <pvPortMalloc+0x7a>
     5d4:	88 81       	ld	r24, Y
     5d6:	99 81       	ldd	r25, Y+1	; 0x01
     5d8:	00 97       	sbiw	r24, 0x00	; 0
     5da:	a9 f7       	brne	.-22     	; 0x5c6 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     5dc:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <pxEnd>
     5e0:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <pxEnd+0x1>
     5e4:	c8 17       	cp	r28, r24
     5e6:	d9 07       	cpc	r29, r25
     5e8:	09 f4       	brne	.+2      	; 0x5ec <pvPortMalloc+0x8a>
     5ea:	45 c0       	rjmp	.+138    	; 0x676 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     5ec:	e0 80       	ld	r14, Z
     5ee:	f1 80       	ldd	r15, Z+1	; 0x01
     5f0:	84 e0       	ldi	r24, 0x04	; 4
     5f2:	e8 0e       	add	r14, r24
     5f4:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5f6:	88 81       	ld	r24, Y
     5f8:	99 81       	ldd	r25, Y+1	; 0x01
     5fa:	91 83       	std	Z+1, r25	; 0x01
     5fc:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5fe:	2a 81       	ldd	r18, Y+2	; 0x02
     600:	3b 81       	ldd	r19, Y+3	; 0x03
     602:	20 1b       	sub	r18, r16
     604:	31 0b       	sbc	r19, r17
     606:	29 30       	cpi	r18, 0x09	; 9
     608:	31 05       	cpc	r19, r1
     60a:	50 f0       	brcs	.+20     	; 0x620 <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     60c:	ce 01       	movw	r24, r28
     60e:	80 0f       	add	r24, r16
     610:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     612:	fc 01       	movw	r30, r24
     614:	33 83       	std	Z+3, r19	; 0x03
     616:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     618:	1b 83       	std	Y+3, r17	; 0x03
     61a:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     61c:	0e 94 67 02 	call	0x4ce	; 0x4ce <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     620:	2a 81       	ldd	r18, Y+2	; 0x02
     622:	3b 81       	ldd	r19, Y+3	; 0x03
     624:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <xFreeBytesRemaining>
     628:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <xFreeBytesRemaining+0x1>
     62c:	82 1b       	sub	r24, r18
     62e:	93 0b       	sbc	r25, r19
     630:	90 93 73 01 	sts	0x0173, r25	; 0x800173 <xFreeBytesRemaining+0x1>
     634:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     638:	40 91 70 01 	lds	r20, 0x0170	; 0x800170 <xMinimumEverFreeBytesRemaining>
     63c:	50 91 71 01 	lds	r21, 0x0171	; 0x800171 <xMinimumEverFreeBytesRemaining+0x1>
     640:	84 17       	cp	r24, r20
     642:	95 07       	cpc	r25, r21
     644:	20 f4       	brcc	.+8      	; 0x64e <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     646:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <xMinimumEverFreeBytesRemaining+0x1>
     64a:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     64e:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <__data_end>
     652:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <__data_end+0x1>
     656:	28 2b       	or	r18, r24
     658:	39 2b       	or	r19, r25
     65a:	3b 83       	std	Y+3, r19	; 0x03
     65c:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     65e:	19 82       	std	Y+1, r1	; 0x01
     660:	18 82       	st	Y, r1
     662:	0b c0       	rjmp	.+22     	; 0x67a <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     664:	e1 2c       	mov	r14, r1
     666:	f1 2c       	mov	r15, r1
     668:	08 c0       	rjmp	.+16     	; 0x67a <pvPortMalloc+0x118>
     66a:	e1 2c       	mov	r14, r1
     66c:	f1 2c       	mov	r15, r1
     66e:	05 c0       	rjmp	.+10     	; 0x67a <pvPortMalloc+0x118>
     670:	e1 2c       	mov	r14, r1
     672:	f1 2c       	mov	r15, r1
     674:	02 c0       	rjmp	.+4      	; 0x67a <pvPortMalloc+0x118>
     676:	e1 2c       	mov	r14, r1
     678:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     67a:	0e 94 23 06 	call	0xc46	; 0xc46 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     67e:	c7 01       	movw	r24, r14
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	1f 91       	pop	r17
     686:	0f 91       	pop	r16
     688:	ff 90       	pop	r15
     68a:	ef 90       	pop	r14
     68c:	08 95       	ret

0000068e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     68e:	0f 93       	push	r16
     690:	1f 93       	push	r17
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     696:	00 97       	sbiw	r24, 0x00	; 0
     698:	51 f1       	breq	.+84     	; 0x6ee <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     69a:	ec 01       	movw	r28, r24
     69c:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     69e:	4a 81       	ldd	r20, Y+2	; 0x02
     6a0:	5b 81       	ldd	r21, Y+3	; 0x03
     6a2:	20 91 6e 01 	lds	r18, 0x016E	; 0x80016e <__data_end>
     6a6:	30 91 6f 01 	lds	r19, 0x016F	; 0x80016f <__data_end+0x1>
     6aa:	ba 01       	movw	r22, r20
     6ac:	62 23       	and	r22, r18
     6ae:	73 23       	and	r23, r19
     6b0:	67 2b       	or	r22, r23
     6b2:	e9 f0       	breq	.+58     	; 0x6ee <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     6b4:	68 81       	ld	r22, Y
     6b6:	79 81       	ldd	r23, Y+1	; 0x01
     6b8:	67 2b       	or	r22, r23
     6ba:	c9 f4       	brne	.+50     	; 0x6ee <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     6bc:	20 95       	com	r18
     6be:	30 95       	com	r19
     6c0:	24 23       	and	r18, r20
     6c2:	35 23       	and	r19, r21
     6c4:	3b 83       	std	Y+3, r19	; 0x03
     6c6:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     6c8:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     6cc:	8a 81       	ldd	r24, Y+2	; 0x02
     6ce:	9b 81       	ldd	r25, Y+3	; 0x03
     6d0:	20 91 72 01 	lds	r18, 0x0172	; 0x800172 <xFreeBytesRemaining>
     6d4:	30 91 73 01 	lds	r19, 0x0173	; 0x800173 <xFreeBytesRemaining+0x1>
     6d8:	82 0f       	add	r24, r18
     6da:	93 1f       	adc	r25, r19
     6dc:	90 93 73 01 	sts	0x0173, r25	; 0x800173 <xFreeBytesRemaining+0x1>
     6e0:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     6e4:	ce 01       	movw	r24, r28
     6e6:	0e 94 67 02 	call	0x4ce	; 0x4ce <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     6ea:	0e 94 23 06 	call	0xc46	; 0xc46 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     6ee:	df 91       	pop	r29
     6f0:	cf 91       	pop	r28
     6f2:	1f 91       	pop	r17
     6f4:	0f 91       	pop	r16
     6f6:	08 95       	ret

000006f8 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6f8:	e0 91 6f 07 	lds	r30, 0x076F	; 0x80076f <pxDelayedTaskList>
     6fc:	f0 91 70 07 	lds	r31, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     700:	80 81       	ld	r24, Z
     702:	81 11       	cpse	r24, r1
     704:	07 c0       	rjmp	.+14     	; 0x714 <prvResetNextTaskUnblockTime+0x1c>
     706:	8f ef       	ldi	r24, 0xFF	; 255
     708:	9f ef       	ldi	r25, 0xFF	; 255
     70a:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <xNextTaskUnblockTime+0x1>
     70e:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <xNextTaskUnblockTime>
     712:	08 95       	ret
     714:	e0 91 6f 07 	lds	r30, 0x076F	; 0x80076f <pxDelayedTaskList>
     718:	f0 91 70 07 	lds	r31, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     71c:	05 80       	ldd	r0, Z+5	; 0x05
     71e:	f6 81       	ldd	r31, Z+6	; 0x06
     720:	e0 2d       	mov	r30, r0
     722:	06 80       	ldd	r0, Z+6	; 0x06
     724:	f7 81       	ldd	r31, Z+7	; 0x07
     726:	e0 2d       	mov	r30, r0
     728:	82 81       	ldd	r24, Z+2	; 0x02
     72a:	93 81       	ldd	r25, Z+3	; 0x03
     72c:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <xNextTaskUnblockTime+0x1>
     730:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <xNextTaskUnblockTime>
     734:	08 95       	ret

00000736 <prvInitialiseNewTask>:
     736:	6f 92       	push	r6
     738:	7f 92       	push	r7
     73a:	8f 92       	push	r8
     73c:	9f 92       	push	r9
     73e:	af 92       	push	r10
     740:	bf 92       	push	r11
     742:	cf 92       	push	r12
     744:	df 92       	push	r13
     746:	ef 92       	push	r14
     748:	0f 93       	push	r16
     74a:	1f 93       	push	r17
     74c:	cf 93       	push	r28
     74e:	df 93       	push	r29
     750:	cd b7       	in	r28, 0x3d	; 61
     752:	de b7       	in	r29, 0x3e	; 62
     754:	4c 01       	movw	r8, r24
     756:	f5 01       	movw	r30, r10
     758:	87 89       	ldd	r24, Z+23	; 0x17
     75a:	90 8d       	ldd	r25, Z+24	; 0x18
     75c:	21 50       	subi	r18, 0x01	; 1
     75e:	31 09       	sbc	r19, r1
     760:	3c 01       	movw	r6, r24
     762:	62 0e       	add	r6, r18
     764:	73 1e       	adc	r7, r19
     766:	20 e0       	ldi	r18, 0x00	; 0
     768:	0f c0       	rjmp	.+30     	; 0x788 <prvInitialiseNewTask+0x52>
     76a:	82 2f       	mov	r24, r18
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	fb 01       	movw	r30, r22
     770:	e8 0f       	add	r30, r24
     772:	f9 1f       	adc	r31, r25
     774:	30 81       	ld	r19, Z
     776:	d5 01       	movw	r26, r10
     778:	a8 0f       	add	r26, r24
     77a:	b9 1f       	adc	r27, r25
     77c:	59 96       	adiw	r26, 0x19	; 25
     77e:	3c 93       	st	X, r19
     780:	80 81       	ld	r24, Z
     782:	88 23       	and	r24, r24
     784:	19 f0       	breq	.+6      	; 0x78c <prvInitialiseNewTask+0x56>
     786:	2f 5f       	subi	r18, 0xFF	; 255
     788:	28 30       	cpi	r18, 0x08	; 8
     78a:	78 f3       	brcs	.-34     	; 0x76a <prvInitialiseNewTask+0x34>
     78c:	f5 01       	movw	r30, r10
     78e:	10 a2       	std	Z+32, r1	; 0x20
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	fe 15       	cp	r31, r14
     794:	20 f4       	brcc	.+8      	; 0x79e <prvInitialiseNewTask+0x68>
     796:	0f 2e       	mov	r0, r31
     798:	f3 e0       	ldi	r31, 0x03	; 3
     79a:	ef 2e       	mov	r14, r31
     79c:	f0 2d       	mov	r31, r0
     79e:	f5 01       	movw	r30, r10
     7a0:	e6 8a       	std	Z+22, r14	; 0x16
     7a2:	c5 01       	movw	r24, r10
     7a4:	02 96       	adiw	r24, 0x02	; 2
     7a6:	0e 94 66 00 	call	0xcc	; 0xcc <vListInitialiseItem>
     7aa:	c5 01       	movw	r24, r10
     7ac:	0c 96       	adiw	r24, 0x0c	; 12
     7ae:	0e 94 66 00 	call	0xcc	; 0xcc <vListInitialiseItem>
     7b2:	f5 01       	movw	r30, r10
     7b4:	b1 86       	std	Z+9, r11	; 0x09
     7b6:	a0 86       	std	Z+8, r10	; 0x08
     7b8:	84 e0       	ldi	r24, 0x04	; 4
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	8e 19       	sub	r24, r14
     7be:	91 09       	sbc	r25, r1
     7c0:	95 87       	std	Z+13, r25	; 0x0d
     7c2:	84 87       	std	Z+12, r24	; 0x0c
     7c4:	b3 8a       	std	Z+19, r11	; 0x13
     7c6:	a2 8a       	std	Z+18, r10	; 0x12
     7c8:	11 a2       	std	Z+33, r1	; 0x21
     7ca:	12 a2       	std	Z+34, r1	; 0x22
     7cc:	13 a2       	std	Z+35, r1	; 0x23
     7ce:	14 a2       	std	Z+36, r1	; 0x24
     7d0:	15 a2       	std	Z+37, r1	; 0x25
     7d2:	a8 01       	movw	r20, r16
     7d4:	b4 01       	movw	r22, r8
     7d6:	c3 01       	movw	r24, r6
     7d8:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <pxPortInitialiseStack>
     7dc:	f5 01       	movw	r30, r10
     7de:	91 83       	std	Z+1, r25	; 0x01
     7e0:	80 83       	st	Z, r24
     7e2:	c1 14       	cp	r12, r1
     7e4:	d1 04       	cpc	r13, r1
     7e6:	19 f0       	breq	.+6      	; 0x7ee <prvInitialiseNewTask+0xb8>
     7e8:	f6 01       	movw	r30, r12
     7ea:	b1 82       	std	Z+1, r11	; 0x01
     7ec:	a0 82       	st	Z, r10
     7ee:	df 91       	pop	r29
     7f0:	cf 91       	pop	r28
     7f2:	1f 91       	pop	r17
     7f4:	0f 91       	pop	r16
     7f6:	ef 90       	pop	r14
     7f8:	df 90       	pop	r13
     7fa:	cf 90       	pop	r12
     7fc:	bf 90       	pop	r11
     7fe:	af 90       	pop	r10
     800:	9f 90       	pop	r9
     802:	8f 90       	pop	r8
     804:	7f 90       	pop	r7
     806:	6f 90       	pop	r6
     808:	08 95       	ret

0000080a <prvIdleTask>:
     80a:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <pxReadyTasksLists>
     80e:	82 30       	cpi	r24, 0x02	; 2
     810:	e0 f3       	brcs	.-8      	; 0x80a <prvIdleTask>
     812:	0e 94 86 01 	call	0x30c	; 0x30c <vPortYield>
     816:	f9 cf       	rjmp	.-14     	; 0x80a <prvIdleTask>

00000818 <prvInitialiseTaskLists>:
     818:	cf 93       	push	r28
     81a:	c0 e0       	ldi	r28, 0x00	; 0
     81c:	10 c0       	rjmp	.+32     	; 0x83e <prvInitialiseTaskLists+0x26>
     81e:	8c 2f       	mov	r24, r28
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	9c 01       	movw	r18, r24
     824:	22 0f       	add	r18, r18
     826:	33 1f       	adc	r19, r19
     828:	22 0f       	add	r18, r18
     82a:	33 1f       	adc	r19, r19
     82c:	22 0f       	add	r18, r18
     82e:	33 1f       	adc	r19, r19
     830:	82 0f       	add	r24, r18
     832:	93 1f       	adc	r25, r19
     834:	8d 57       	subi	r24, 0x7D	; 125
     836:	98 4f       	sbci	r25, 0xF8	; 248
     838:	0e 94 58 00 	call	0xb0	; 0xb0 <vListInitialise>
     83c:	cf 5f       	subi	r28, 0xFF	; 255
     83e:	c4 30       	cpi	r28, 0x04	; 4
     840:	70 f3       	brcs	.-36     	; 0x81e <prvInitialiseTaskLists+0x6>
     842:	8a e7       	ldi	r24, 0x7A	; 122
     844:	97 e0       	ldi	r25, 0x07	; 7
     846:	0e 94 58 00 	call	0xb0	; 0xb0 <vListInitialise>
     84a:	81 e7       	ldi	r24, 0x71	; 113
     84c:	97 e0       	ldi	r25, 0x07	; 7
     84e:	0e 94 58 00 	call	0xb0	; 0xb0 <vListInitialise>
     852:	84 e6       	ldi	r24, 0x64	; 100
     854:	97 e0       	ldi	r25, 0x07	; 7
     856:	0e 94 58 00 	call	0xb0	; 0xb0 <vListInitialise>
     85a:	8a e7       	ldi	r24, 0x7A	; 122
     85c:	97 e0       	ldi	r25, 0x07	; 7
     85e:	90 93 70 07 	sts	0x0770, r25	; 0x800770 <pxDelayedTaskList+0x1>
     862:	80 93 6f 07 	sts	0x076F, r24	; 0x80076f <pxDelayedTaskList>
     866:	81 e7       	ldi	r24, 0x71	; 113
     868:	97 e0       	ldi	r25, 0x07	; 7
     86a:	90 93 6e 07 	sts	0x076E, r25	; 0x80076e <pxOverflowDelayedTaskList+0x1>
     86e:	80 93 6d 07 	sts	0x076D, r24	; 0x80076d <pxOverflowDelayedTaskList>
     872:	cf 91       	pop	r28
     874:	08 95       	ret

00000876 <prvAddNewTaskToReadyList>:
     876:	cf 93       	push	r28
     878:	df 93       	push	r29
     87a:	ec 01       	movw	r28, r24
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	0f 92       	push	r0
     882:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <uxCurrentNumberOfTasks>
     886:	8f 5f       	subi	r24, 0xFF	; 255
     888:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <uxCurrentNumberOfTasks>
     88c:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     890:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     894:	89 2b       	or	r24, r25
     896:	59 f4       	brne	.+22     	; 0x8ae <prvAddNewTaskToReadyList+0x38>
     898:	d0 93 a8 07 	sts	0x07A8, r29	; 0x8007a8 <pxCurrentTCB+0x1>
     89c:	c0 93 a7 07 	sts	0x07A7, r28	; 0x8007a7 <pxCurrentTCB>
     8a0:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <uxCurrentNumberOfTasks>
     8a4:	81 30       	cpi	r24, 0x01	; 1
     8a6:	99 f4       	brne	.+38     	; 0x8ce <prvAddNewTaskToReadyList+0x58>
     8a8:	0e 94 0c 04 	call	0x818	; 0x818 <prvInitialiseTaskLists>
     8ac:	10 c0       	rjmp	.+32     	; 0x8ce <prvAddNewTaskToReadyList+0x58>
     8ae:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <xSchedulerRunning>
     8b2:	81 11       	cpse	r24, r1
     8b4:	0c c0       	rjmp	.+24     	; 0x8ce <prvAddNewTaskToReadyList+0x58>
     8b6:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     8ba:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     8be:	96 89       	ldd	r25, Z+22	; 0x16
     8c0:	8e 89       	ldd	r24, Y+22	; 0x16
     8c2:	89 17       	cp	r24, r25
     8c4:	20 f0       	brcs	.+8      	; 0x8ce <prvAddNewTaskToReadyList+0x58>
     8c6:	d0 93 a8 07 	sts	0x07A8, r29	; 0x8007a8 <pxCurrentTCB+0x1>
     8ca:	c0 93 a7 07 	sts	0x07A7, r28	; 0x8007a7 <pxCurrentTCB>
     8ce:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <uxTaskNumber>
     8d2:	8f 5f       	subi	r24, 0xFF	; 255
     8d4:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <uxTaskNumber>
     8d8:	8e 89       	ldd	r24, Y+22	; 0x16
     8da:	90 91 60 07 	lds	r25, 0x0760	; 0x800760 <uxTopReadyPriority>
     8de:	98 17       	cp	r25, r24
     8e0:	10 f4       	brcc	.+4      	; 0x8e6 <prvAddNewTaskToReadyList+0x70>
     8e2:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <uxTopReadyPriority>
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	9c 01       	movw	r18, r24
     8ea:	22 0f       	add	r18, r18
     8ec:	33 1f       	adc	r19, r19
     8ee:	22 0f       	add	r18, r18
     8f0:	33 1f       	adc	r19, r19
     8f2:	22 0f       	add	r18, r18
     8f4:	33 1f       	adc	r19, r19
     8f6:	82 0f       	add	r24, r18
     8f8:	93 1f       	adc	r25, r19
     8fa:	be 01       	movw	r22, r28
     8fc:	6e 5f       	subi	r22, 0xFE	; 254
     8fe:	7f 4f       	sbci	r23, 0xFF	; 255
     900:	8d 57       	subi	r24, 0x7D	; 125
     902:	98 4f       	sbci	r25, 0xF8	; 248
     904:	0e 94 6a 00 	call	0xd4	; 0xd4 <vListInsertEnd>
     908:	0f 90       	pop	r0
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <xSchedulerRunning>
     910:	88 23       	and	r24, r24
     912:	51 f0       	breq	.+20     	; 0x928 <prvAddNewTaskToReadyList+0xb2>
     914:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     918:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     91c:	96 89       	ldd	r25, Z+22	; 0x16
     91e:	8e 89       	ldd	r24, Y+22	; 0x16
     920:	98 17       	cp	r25, r24
     922:	10 f4       	brcc	.+4      	; 0x928 <prvAddNewTaskToReadyList+0xb2>
     924:	0e 94 86 01 	call	0x30c	; 0x30c <vPortYield>
     928:	df 91       	pop	r29
     92a:	cf 91       	pop	r28
     92c:	08 95       	ret

0000092e <prvAddCurrentTaskToDelayedList>:
     92e:	0f 93       	push	r16
     930:	1f 93       	push	r17
     932:	cf 93       	push	r28
     934:	df 93       	push	r29
     936:	ec 01       	movw	r28, r24
     938:	00 91 61 07 	lds	r16, 0x0761	; 0x800761 <xTickCount>
     93c:	10 91 62 07 	lds	r17, 0x0762	; 0x800762 <xTickCount+0x1>
     940:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     944:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     948:	02 96       	adiw	r24, 0x02	; 2
     94a:	0e 94 bc 00 	call	0x178	; 0x178 <uxListRemove>
     94e:	c0 0f       	add	r28, r16
     950:	d1 1f       	adc	r29, r17
     952:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     956:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     95a:	d3 83       	std	Z+3, r29	; 0x03
     95c:	c2 83       	std	Z+2, r28	; 0x02
     95e:	c0 17       	cp	r28, r16
     960:	d1 07       	cpc	r29, r17
     962:	68 f4       	brcc	.+26     	; 0x97e <prvAddCurrentTaskToDelayedList+0x50>
     964:	60 91 a7 07 	lds	r22, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     968:	70 91 a8 07 	lds	r23, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     96c:	80 91 6d 07 	lds	r24, 0x076D	; 0x80076d <pxOverflowDelayedTaskList>
     970:	90 91 6e 07 	lds	r25, 0x076E	; 0x80076e <pxOverflowDelayedTaskList+0x1>
     974:	6e 5f       	subi	r22, 0xFE	; 254
     976:	7f 4f       	sbci	r23, 0xFF	; 255
     978:	0e 94 8b 00 	call	0x116	; 0x116 <vListInsert>
     97c:	17 c0       	rjmp	.+46     	; 0x9ac <prvAddCurrentTaskToDelayedList+0x7e>
     97e:	60 91 a7 07 	lds	r22, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     982:	70 91 a8 07 	lds	r23, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     986:	80 91 6f 07 	lds	r24, 0x076F	; 0x80076f <pxDelayedTaskList>
     98a:	90 91 70 07 	lds	r25, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     98e:	6e 5f       	subi	r22, 0xFE	; 254
     990:	7f 4f       	sbci	r23, 0xFF	; 255
     992:	0e 94 8b 00 	call	0x116	; 0x116 <vListInsert>
     996:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <xNextTaskUnblockTime>
     99a:	90 91 5a 07 	lds	r25, 0x075A	; 0x80075a <xNextTaskUnblockTime+0x1>
     99e:	c8 17       	cp	r28, r24
     9a0:	d9 07       	cpc	r29, r25
     9a2:	20 f4       	brcc	.+8      	; 0x9ac <prvAddCurrentTaskToDelayedList+0x7e>
     9a4:	d0 93 5a 07 	sts	0x075A, r29	; 0x80075a <xNextTaskUnblockTime+0x1>
     9a8:	c0 93 59 07 	sts	0x0759, r28	; 0x800759 <xNextTaskUnblockTime>
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	1f 91       	pop	r17
     9b2:	0f 91       	pop	r16
     9b4:	08 95       	ret

000009b6 <xTaskCreate>:
     9b6:	2f 92       	push	r2
     9b8:	3f 92       	push	r3
     9ba:	4f 92       	push	r4
     9bc:	5f 92       	push	r5
     9be:	6f 92       	push	r6
     9c0:	7f 92       	push	r7
     9c2:	8f 92       	push	r8
     9c4:	9f 92       	push	r9
     9c6:	af 92       	push	r10
     9c8:	bf 92       	push	r11
     9ca:	cf 92       	push	r12
     9cc:	df 92       	push	r13
     9ce:	ef 92       	push	r14
     9d0:	ff 92       	push	r15
     9d2:	0f 93       	push	r16
     9d4:	1f 93       	push	r17
     9d6:	cf 93       	push	r28
     9d8:	df 93       	push	r29
     9da:	3c 01       	movw	r6, r24
     9dc:	1b 01       	movw	r2, r22
     9de:	5a 01       	movw	r10, r20
     9e0:	29 01       	movw	r4, r18
     9e2:	ca 01       	movw	r24, r20
     9e4:	0e 94 b1 02 	call	0x562	; 0x562 <pvPortMalloc>
     9e8:	6c 01       	movw	r12, r24
     9ea:	89 2b       	or	r24, r25
     9ec:	71 f0       	breq	.+28     	; 0xa0a <xTaskCreate+0x54>
     9ee:	86 e2       	ldi	r24, 0x26	; 38
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	0e 94 b1 02 	call	0x562	; 0x562 <pvPortMalloc>
     9f6:	ec 01       	movw	r28, r24
     9f8:	89 2b       	or	r24, r25
     9fa:	19 f0       	breq	.+6      	; 0xa02 <xTaskCreate+0x4c>
     9fc:	d8 8e       	std	Y+24, r13	; 0x18
     9fe:	cf 8a       	std	Y+23, r12	; 0x17
     a00:	06 c0       	rjmp	.+12     	; 0xa0e <xTaskCreate+0x58>
     a02:	c6 01       	movw	r24, r12
     a04:	0e 94 47 03 	call	0x68e	; 0x68e <vPortFree>
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <xTaskCreate+0x58>
     a0a:	c0 e0       	ldi	r28, 0x00	; 0
     a0c:	d0 e0       	ldi	r29, 0x00	; 0
     a0e:	20 97       	sbiw	r28, 0x00	; 0
     a10:	91 f0       	breq	.+36     	; 0xa36 <xTaskCreate+0x80>
     a12:	95 01       	movw	r18, r10
     a14:	40 e0       	ldi	r20, 0x00	; 0
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	81 2c       	mov	r8, r1
     a1a:	91 2c       	mov	r9, r1
     a1c:	5e 01       	movw	r10, r28
     a1e:	67 01       	movw	r12, r14
     a20:	e0 2e       	mov	r14, r16
     a22:	82 01       	movw	r16, r4
     a24:	b1 01       	movw	r22, r2
     a26:	c3 01       	movw	r24, r6
     a28:	0e 94 9b 03 	call	0x736	; 0x736 <prvInitialiseNewTask>
     a2c:	ce 01       	movw	r24, r28
     a2e:	0e 94 3b 04 	call	0x876	; 0x876 <prvAddNewTaskToReadyList>
     a32:	81 e0       	ldi	r24, 0x01	; 1
     a34:	01 c0       	rjmp	.+2      	; 0xa38 <xTaskCreate+0x82>
     a36:	8f ef       	ldi	r24, 0xFF	; 255
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	1f 91       	pop	r17
     a3e:	0f 91       	pop	r16
     a40:	ff 90       	pop	r15
     a42:	ef 90       	pop	r14
     a44:	df 90       	pop	r13
     a46:	cf 90       	pop	r12
     a48:	bf 90       	pop	r11
     a4a:	af 90       	pop	r10
     a4c:	9f 90       	pop	r9
     a4e:	8f 90       	pop	r8
     a50:	7f 90       	pop	r7
     a52:	6f 90       	pop	r6
     a54:	5f 90       	pop	r5
     a56:	4f 90       	pop	r4
     a58:	3f 90       	pop	r3
     a5a:	2f 90       	pop	r2
     a5c:	08 95       	ret

00000a5e <vTaskStartScheduler>:
     a5e:	ef 92       	push	r14
     a60:	ff 92       	push	r15
     a62:	0f 93       	push	r16
     a64:	0f 2e       	mov	r0, r31
     a66:	f7 e5       	ldi	r31, 0x57	; 87
     a68:	ef 2e       	mov	r14, r31
     a6a:	f7 e0       	ldi	r31, 0x07	; 7
     a6c:	ff 2e       	mov	r15, r31
     a6e:	f0 2d       	mov	r31, r0
     a70:	00 e0       	ldi	r16, 0x00	; 0
     a72:	20 e0       	ldi	r18, 0x00	; 0
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	45 e5       	ldi	r20, 0x55	; 85
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	67 e7       	ldi	r22, 0x77	; 119
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	85 e0       	ldi	r24, 0x05	; 5
     a80:	94 e0       	ldi	r25, 0x04	; 4
     a82:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xTaskCreate>
     a86:	81 30       	cpi	r24, 0x01	; 1
     a88:	81 f4       	brne	.+32     	; 0xaaa <vTaskStartScheduler+0x4c>
     a8a:	f8 94       	cli
     a8c:	8f ef       	ldi	r24, 0xFF	; 255
     a8e:	9f ef       	ldi	r25, 0xFF	; 255
     a90:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <xNextTaskUnblockTime+0x1>
     a94:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <xNextTaskUnblockTime>
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	80 93 5f 07 	sts	0x075F, r24	; 0x80075f <xSchedulerRunning>
     a9e:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <xTickCount+0x1>
     aa2:	10 92 61 07 	sts	0x0761, r1	; 0x800761 <xTickCount>
     aa6:	0e 94 57 01 	call	0x2ae	; 0x2ae <xPortStartScheduler>
     aaa:	0f 91       	pop	r16
     aac:	ff 90       	pop	r15
     aae:	ef 90       	pop	r14
     ab0:	08 95       	ret

00000ab2 <vTaskSuspendAll>:
     ab2:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <uxSchedulerSuspended>
     ab6:	8f 5f       	subi	r24, 0xFF	; 255
     ab8:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <uxSchedulerSuspended>
     abc:	08 95       	ret

00000abe <xTaskGetTickCount>:
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	f8 94       	cli
     ac2:	0f 92       	push	r0
     ac4:	80 91 61 07 	lds	r24, 0x0761	; 0x800761 <xTickCount>
     ac8:	90 91 62 07 	lds	r25, 0x0762	; 0x800762 <xTickCount+0x1>
     acc:	0f 90       	pop	r0
     ace:	0f be       	out	0x3f, r0	; 63
     ad0:	08 95       	ret

00000ad2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ad2:	df 92       	push	r13
     ad4:	ef 92       	push	r14
     ad6:	ff 92       	push	r15
     ad8:	0f 93       	push	r16
     ada:	1f 93       	push	r17
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ae0:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <uxSchedulerSuspended>
     ae4:	81 11       	cpse	r24, r1
     ae6:	97 c0       	rjmp	.+302    	; 0xc16 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     ae8:	e0 90 61 07 	lds	r14, 0x0761	; 0x800761 <xTickCount>
     aec:	f0 90 62 07 	lds	r15, 0x0762	; 0x800762 <xTickCount+0x1>
     af0:	8f ef       	ldi	r24, 0xFF	; 255
     af2:	e8 1a       	sub	r14, r24
     af4:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     af6:	f0 92 62 07 	sts	0x0762, r15	; 0x800762 <xTickCount+0x1>
     afa:	e0 92 61 07 	sts	0x0761, r14	; 0x800761 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     afe:	e1 14       	cp	r14, r1
     b00:	f1 04       	cpc	r15, r1
     b02:	b9 f4       	brne	.+46     	; 0xb32 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     b04:	80 91 6f 07 	lds	r24, 0x076F	; 0x80076f <pxDelayedTaskList>
     b08:	90 91 70 07 	lds	r25, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     b0c:	20 91 6d 07 	lds	r18, 0x076D	; 0x80076d <pxOverflowDelayedTaskList>
     b10:	30 91 6e 07 	lds	r19, 0x076E	; 0x80076e <pxOverflowDelayedTaskList+0x1>
     b14:	30 93 70 07 	sts	0x0770, r19	; 0x800770 <pxDelayedTaskList+0x1>
     b18:	20 93 6f 07 	sts	0x076F, r18	; 0x80076f <pxDelayedTaskList>
     b1c:	90 93 6e 07 	sts	0x076E, r25	; 0x80076e <pxOverflowDelayedTaskList+0x1>
     b20:	80 93 6d 07 	sts	0x076D, r24	; 0x80076d <pxOverflowDelayedTaskList>
     b24:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <xNumOfOverflows>
     b28:	8f 5f       	subi	r24, 0xFF	; 255
     b2a:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <xNumOfOverflows>
     b2e:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b32:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <xNextTaskUnblockTime>
     b36:	90 91 5a 07 	lds	r25, 0x075A	; 0x80075a <xNextTaskUnblockTime+0x1>
     b3a:	e8 16       	cp	r14, r24
     b3c:	f9 06       	cpc	r15, r25
     b3e:	28 f4       	brcc	.+10     	; 0xb4a <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b40:	d1 2c       	mov	r13, r1
     b42:	53 c0       	rjmp	.+166    	; 0xbea <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b44:	dd 24       	eor	r13, r13
     b46:	d3 94       	inc	r13
     b48:	01 c0       	rjmp	.+2      	; 0xb4c <xTaskIncrementTick+0x7a>
     b4a:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b4c:	e0 91 6f 07 	lds	r30, 0x076F	; 0x80076f <pxDelayedTaskList>
     b50:	f0 91 70 07 	lds	r31, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     b54:	80 81       	ld	r24, Z
     b56:	81 11       	cpse	r24, r1
     b58:	07 c0       	rjmp	.+14     	; 0xb68 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	9f ef       	ldi	r25, 0xFF	; 255
     b5e:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <xNextTaskUnblockTime+0x1>
     b62:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <xNextTaskUnblockTime>
					break;
     b66:	41 c0       	rjmp	.+130    	; 0xbea <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b68:	e0 91 6f 07 	lds	r30, 0x076F	; 0x80076f <pxDelayedTaskList>
     b6c:	f0 91 70 07 	lds	r31, 0x0770	; 0x800770 <pxDelayedTaskList+0x1>
     b70:	05 80       	ldd	r0, Z+5	; 0x05
     b72:	f6 81       	ldd	r31, Z+6	; 0x06
     b74:	e0 2d       	mov	r30, r0
     b76:	c6 81       	ldd	r28, Z+6	; 0x06
     b78:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b7a:	8a 81       	ldd	r24, Y+2	; 0x02
     b7c:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     b7e:	e8 16       	cp	r14, r24
     b80:	f9 06       	cpc	r15, r25
     b82:	28 f4       	brcc	.+10     	; 0xb8e <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b84:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <xNextTaskUnblockTime+0x1>
     b88:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <xNextTaskUnblockTime>
						break;
     b8c:	2e c0       	rjmp	.+92     	; 0xbea <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b8e:	8e 01       	movw	r16, r28
     b90:	0e 5f       	subi	r16, 0xFE	; 254
     b92:	1f 4f       	sbci	r17, 0xFF	; 255
     b94:	c8 01       	movw	r24, r16
     b96:	0e 94 bc 00 	call	0x178	; 0x178 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b9a:	8c 89       	ldd	r24, Y+20	; 0x14
     b9c:	9d 89       	ldd	r25, Y+21	; 0x15
     b9e:	89 2b       	or	r24, r25
     ba0:	21 f0       	breq	.+8      	; 0xbaa <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ba2:	ce 01       	movw	r24, r28
     ba4:	0c 96       	adiw	r24, 0x0c	; 12
     ba6:	0e 94 bc 00 	call	0x178	; 0x178 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     baa:	8e 89       	ldd	r24, Y+22	; 0x16
     bac:	90 91 60 07 	lds	r25, 0x0760	; 0x800760 <uxTopReadyPriority>
     bb0:	98 17       	cp	r25, r24
     bb2:	10 f4       	brcc	.+4      	; 0xbb8 <xTaskIncrementTick+0xe6>
     bb4:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <uxTopReadyPriority>
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	9c 01       	movw	r18, r24
     bbc:	22 0f       	add	r18, r18
     bbe:	33 1f       	adc	r19, r19
     bc0:	22 0f       	add	r18, r18
     bc2:	33 1f       	adc	r19, r19
     bc4:	22 0f       	add	r18, r18
     bc6:	33 1f       	adc	r19, r19
     bc8:	82 0f       	add	r24, r18
     bca:	93 1f       	adc	r25, r19
     bcc:	b8 01       	movw	r22, r16
     bce:	8d 57       	subi	r24, 0x7D	; 125
     bd0:	98 4f       	sbci	r25, 0xF8	; 248
     bd2:	0e 94 6a 00 	call	0xd4	; 0xd4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bd6:	9e 89       	ldd	r25, Y+22	; 0x16
     bd8:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     bdc:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     be0:	86 89       	ldd	r24, Z+22	; 0x16
     be2:	98 17       	cp	r25, r24
     be4:	08 f0       	brcs	.+2      	; 0xbe8 <xTaskIncrementTick+0x116>
     be6:	ae cf       	rjmp	.-164    	; 0xb44 <xTaskIncrementTick+0x72>
     be8:	b1 cf       	rjmp	.-158    	; 0xb4c <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bea:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     bee:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     bf2:	86 89       	ldd	r24, Z+22	; 0x16
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	fc 01       	movw	r30, r24
     bf8:	ee 0f       	add	r30, r30
     bfa:	ff 1f       	adc	r31, r31
     bfc:	ee 0f       	add	r30, r30
     bfe:	ff 1f       	adc	r31, r31
     c00:	ee 0f       	add	r30, r30
     c02:	ff 1f       	adc	r31, r31
     c04:	8e 0f       	add	r24, r30
     c06:	9f 1f       	adc	r25, r31
     c08:	fc 01       	movw	r30, r24
     c0a:	ed 57       	subi	r30, 0x7D	; 125
     c0c:	f8 4f       	sbci	r31, 0xF8	; 248
     c0e:	80 81       	ld	r24, Z
     c10:	82 30       	cpi	r24, 0x02	; 2
     c12:	40 f4       	brcc	.+16     	; 0xc24 <xTaskIncrementTick+0x152>
     c14:	09 c0       	rjmp	.+18     	; 0xc28 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     c16:	80 91 5e 07 	lds	r24, 0x075E	; 0x80075e <uxPendedTicks>
     c1a:	8f 5f       	subi	r24, 0xFF	; 255
     c1c:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c20:	d1 2c       	mov	r13, r1
     c22:	02 c0       	rjmp	.+4      	; 0xc28 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c24:	dd 24       	eor	r13, r13
     c26:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c28:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <xYieldPending>
     c2c:	88 23       	and	r24, r24
     c2e:	11 f0       	breq	.+4      	; 0xc34 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c30:	dd 24       	eor	r13, r13
     c32:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c34:	8d 2d       	mov	r24, r13
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	df 90       	pop	r13
     c44:	08 95       	ret

00000c46 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c46:	0f 93       	push	r16
     c48:	1f 93       	push	r17
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c54:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <uxSchedulerSuspended>
     c58:	81 50       	subi	r24, 0x01	; 1
     c5a:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c5e:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <uxSchedulerSuspended>
     c62:	81 11       	cpse	r24, r1
     c64:	58 c0       	rjmp	.+176    	; 0xd16 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c66:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <uxCurrentNumberOfTasks>
     c6a:	81 11       	cpse	r24, r1
     c6c:	33 c0       	rjmp	.+102    	; 0xcd4 <xTaskResumeAll+0x8e>
     c6e:	56 c0       	rjmp	.+172    	; 0xd1c <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c70:	e0 91 69 07 	lds	r30, 0x0769	; 0x800769 <xPendingReadyList+0x5>
     c74:	f0 91 6a 07 	lds	r31, 0x076A	; 0x80076a <xPendingReadyList+0x6>
     c78:	c6 81       	ldd	r28, Z+6	; 0x06
     c7a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c7c:	ce 01       	movw	r24, r28
     c7e:	0c 96       	adiw	r24, 0x0c	; 12
     c80:	0e 94 bc 00 	call	0x178	; 0x178 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c84:	8e 01       	movw	r16, r28
     c86:	0e 5f       	subi	r16, 0xFE	; 254
     c88:	1f 4f       	sbci	r17, 0xFF	; 255
     c8a:	c8 01       	movw	r24, r16
     c8c:	0e 94 bc 00 	call	0x178	; 0x178 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c90:	8e 89       	ldd	r24, Y+22	; 0x16
     c92:	90 91 60 07 	lds	r25, 0x0760	; 0x800760 <uxTopReadyPriority>
     c96:	98 17       	cp	r25, r24
     c98:	10 f4       	brcc	.+4      	; 0xc9e <xTaskResumeAll+0x58>
     c9a:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <uxTopReadyPriority>
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	9c 01       	movw	r18, r24
     ca2:	22 0f       	add	r18, r18
     ca4:	33 1f       	adc	r19, r19
     ca6:	22 0f       	add	r18, r18
     ca8:	33 1f       	adc	r19, r19
     caa:	22 0f       	add	r18, r18
     cac:	33 1f       	adc	r19, r19
     cae:	82 0f       	add	r24, r18
     cb0:	93 1f       	adc	r25, r19
     cb2:	b8 01       	movw	r22, r16
     cb4:	8d 57       	subi	r24, 0x7D	; 125
     cb6:	98 4f       	sbci	r25, 0xF8	; 248
     cb8:	0e 94 6a 00 	call	0xd4	; 0xd4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cbc:	9e 89       	ldd	r25, Y+22	; 0x16
     cbe:	e0 91 a7 07 	lds	r30, 0x07A7	; 0x8007a7 <pxCurrentTCB>
     cc2:	f0 91 a8 07 	lds	r31, 0x07A8	; 0x8007a8 <pxCurrentTCB+0x1>
     cc6:	86 89       	ldd	r24, Z+22	; 0x16
     cc8:	98 17       	cp	r25, r24
     cca:	30 f0       	brcs	.+12     	; 0xcd8 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     ccc:	81 e0       	ldi	r24, 0x01	; 1
     cce:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xYieldPending>
     cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <xTaskResumeAll+0x92>
     cd4:	c0 e0       	ldi	r28, 0x00	; 0
     cd6:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cd8:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <xPendingReadyList>
     cdc:	81 11       	cpse	r24, r1
     cde:	c8 cf       	rjmp	.-112    	; 0xc70 <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     ce0:	cd 2b       	or	r28, r29
     ce2:	11 f0       	breq	.+4      	; 0xce8 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     ce4:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     ce8:	c0 91 5e 07 	lds	r28, 0x075E	; 0x80075e <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     cec:	cc 23       	and	r28, r28
     cee:	59 f0       	breq	.+22     	; 0xd06 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     cf0:	0e 94 69 05 	call	0xad2	; 0xad2 <xTaskIncrementTick>
     cf4:	88 23       	and	r24, r24
     cf6:	19 f0       	breq	.+6      	; 0xcfe <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     cf8:	81 e0       	ldi	r24, 0x01	; 1
     cfa:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     cfe:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     d00:	b9 f7       	brne	.-18     	; 0xcf0 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     d02:	10 92 5e 07 	sts	0x075E, r1	; 0x80075e <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     d06:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <xYieldPending>
     d0a:	88 23       	and	r24, r24
     d0c:	31 f0       	breq	.+12     	; 0xd1a <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d0e:	0e 94 86 01 	call	0x30c	; 0x30c <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	03 c0       	rjmp	.+6      	; 0xd1c <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	01 c0       	rjmp	.+2      	; 0xd1c <xTaskResumeAll+0xd6>
     d1a:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d1c:	0f 90       	pop	r0
     d1e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d20:	df 91       	pop	r29
     d22:	cf 91       	pop	r28
     d24:	1f 91       	pop	r17
     d26:	0f 91       	pop	r16
     d28:	08 95       	ret

00000d2a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	cf 93       	push	r28
     d30:	df 93       	push	r29
     d32:	8c 01       	movw	r16, r24
     d34:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d36:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d3a:	40 91 61 07 	lds	r20, 0x0761	; 0x800761 <xTickCount>
     d3e:	50 91 62 07 	lds	r21, 0x0762	; 0x800762 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d42:	f8 01       	movw	r30, r16
     d44:	20 81       	ld	r18, Z
     d46:	31 81       	ldd	r19, Z+1	; 0x01
     d48:	c9 01       	movw	r24, r18
     d4a:	8c 0f       	add	r24, r28
     d4c:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d4e:	42 17       	cp	r20, r18
     d50:	53 07       	cpc	r21, r19
     d52:	40 f4       	brcc	.+16     	; 0xd64 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d54:	82 17       	cp	r24, r18
     d56:	93 07       	cpc	r25, r19
     d58:	68 f4       	brcc	.+26     	; 0xd74 <vTaskDelayUntil+0x4a>
     d5a:	48 17       	cp	r20, r24
     d5c:	59 07       	cpc	r21, r25
     d5e:	60 f0       	brcs	.+24     	; 0xd78 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d60:	20 e0       	ldi	r18, 0x00	; 0
     d62:	0f c0       	rjmp	.+30     	; 0xd82 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d64:	82 17       	cp	r24, r18
     d66:	93 07       	cpc	r25, r19
     d68:	48 f0       	brcs	.+18     	; 0xd7c <vTaskDelayUntil+0x52>
     d6a:	48 17       	cp	r20, r24
     d6c:	59 07       	cpc	r21, r25
     d6e:	40 f0       	brcs	.+16     	; 0xd80 <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d70:	20 e0       	ldi	r18, 0x00	; 0
     d72:	07 c0       	rjmp	.+14     	; 0xd82 <vTaskDelayUntil+0x58>
     d74:	20 e0       	ldi	r18, 0x00	; 0
     d76:	05 c0       	rjmp	.+10     	; 0xd82 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d78:	21 e0       	ldi	r18, 0x01	; 1
     d7a:	03 c0       	rjmp	.+6      	; 0xd82 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d7c:	21 e0       	ldi	r18, 0x01	; 1
     d7e:	01 c0       	rjmp	.+2      	; 0xd82 <vTaskDelayUntil+0x58>
     d80:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d82:	f8 01       	movw	r30, r16
     d84:	91 83       	std	Z+1, r25	; 0x01
     d86:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d88:	22 23       	and	r18, r18
     d8a:	29 f0       	breq	.+10     	; 0xd96 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d8c:	60 e0       	ldi	r22, 0x00	; 0
     d8e:	84 1b       	sub	r24, r20
     d90:	95 0b       	sbc	r25, r21
     d92:	0e 94 97 04 	call	0x92e	; 0x92e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d96:	0e 94 23 06 	call	0xc46	; 0xc46 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d9a:	81 11       	cpse	r24, r1
     d9c:	02 c0       	rjmp	.+4      	; 0xda2 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     d9e:	0e 94 86 01 	call	0x30c	; 0x30c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     da2:	df 91       	pop	r29
     da4:	cf 91       	pop	r28
     da6:	1f 91       	pop	r17
     da8:	0f 91       	pop	r16
     daa:	08 95       	ret

00000dac <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     dac:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <uxSchedulerSuspended>
     db0:	88 23       	and	r24, r24
     db2:	21 f0       	breq	.+8      	; 0xdbc <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     db4:	81 e0       	ldi	r24, 0x01	; 1
     db6:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xYieldPending>
     dba:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     dbc:	10 92 5d 07 	sts	0x075D, r1	; 0x80075d <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     dc0:	20 91 60 07 	lds	r18, 0x0760	; 0x800760 <uxTopReadyPriority>
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <vTaskSwitchContext+0x1c>
     dc6:	21 50       	subi	r18, 0x01	; 1
     dc8:	82 2f       	mov	r24, r18
     dca:	90 e0       	ldi	r25, 0x00	; 0
     dcc:	fc 01       	movw	r30, r24
     dce:	ee 0f       	add	r30, r30
     dd0:	ff 1f       	adc	r31, r31
     dd2:	ee 0f       	add	r30, r30
     dd4:	ff 1f       	adc	r31, r31
     dd6:	ee 0f       	add	r30, r30
     dd8:	ff 1f       	adc	r31, r31
     dda:	e8 0f       	add	r30, r24
     ddc:	f9 1f       	adc	r31, r25
     dde:	ed 57       	subi	r30, 0x7D	; 125
     de0:	f8 4f       	sbci	r31, 0xF8	; 248
     de2:	30 81       	ld	r19, Z
     de4:	33 23       	and	r19, r19
     de6:	79 f3       	breq	.-34     	; 0xdc6 <vTaskSwitchContext+0x1a>
     de8:	ac 01       	movw	r20, r24
     dea:	44 0f       	add	r20, r20
     dec:	55 1f       	adc	r21, r21
     dee:	44 0f       	add	r20, r20
     df0:	55 1f       	adc	r21, r21
     df2:	44 0f       	add	r20, r20
     df4:	55 1f       	adc	r21, r21
     df6:	48 0f       	add	r20, r24
     df8:	59 1f       	adc	r21, r25
     dfa:	df 01       	movw	r26, r30
     dfc:	01 80       	ldd	r0, Z+1	; 0x01
     dfe:	f2 81       	ldd	r31, Z+2	; 0x02
     e00:	e0 2d       	mov	r30, r0
     e02:	02 80       	ldd	r0, Z+2	; 0x02
     e04:	f3 81       	ldd	r31, Z+3	; 0x03
     e06:	e0 2d       	mov	r30, r0
     e08:	12 96       	adiw	r26, 0x02	; 2
     e0a:	fc 93       	st	X, r31
     e0c:	ee 93       	st	-X, r30
     e0e:	11 97       	sbiw	r26, 0x01	; 1
     e10:	4a 57       	subi	r20, 0x7A	; 122
     e12:	58 4f       	sbci	r21, 0xF8	; 248
     e14:	e4 17       	cp	r30, r20
     e16:	f5 07       	cpc	r31, r21
     e18:	29 f4       	brne	.+10     	; 0xe24 <vTaskSwitchContext+0x78>
     e1a:	42 81       	ldd	r20, Z+2	; 0x02
     e1c:	53 81       	ldd	r21, Z+3	; 0x03
     e1e:	fd 01       	movw	r30, r26
     e20:	52 83       	std	Z+2, r21	; 0x02
     e22:	41 83       	std	Z+1, r20	; 0x01
     e24:	fc 01       	movw	r30, r24
     e26:	ee 0f       	add	r30, r30
     e28:	ff 1f       	adc	r31, r31
     e2a:	ee 0f       	add	r30, r30
     e2c:	ff 1f       	adc	r31, r31
     e2e:	ee 0f       	add	r30, r30
     e30:	ff 1f       	adc	r31, r31
     e32:	8e 0f       	add	r24, r30
     e34:	9f 1f       	adc	r25, r31
     e36:	fc 01       	movw	r30, r24
     e38:	ed 57       	subi	r30, 0x7D	; 125
     e3a:	f8 4f       	sbci	r31, 0xF8	; 248
     e3c:	01 80       	ldd	r0, Z+1	; 0x01
     e3e:	f2 81       	ldd	r31, Z+2	; 0x02
     e40:	e0 2d       	mov	r30, r0
     e42:	86 81       	ldd	r24, Z+6	; 0x06
     e44:	97 81       	ldd	r25, Z+7	; 0x07
     e46:	90 93 a8 07 	sts	0x07A8, r25	; 0x8007a8 <pxCurrentTCB+0x1>
     e4a:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <pxCurrentTCB>
     e4e:	20 93 60 07 	sts	0x0760, r18	; 0x800760 <uxTopReadyPriority>
     e52:	08 95       	ret

00000e54 <LCD_SendCommand>:
				DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, PIN_OUTPUT);
				*Data = Character;
			}
	}
	return ErrRetVal;
}
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	c8 2f       	mov	r28, r24
     e5e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <State.1734>
     e62:	83 30       	cpi	r24, 0x03	; 3
     e64:	09 f4       	brne	.+2      	; 0xe68 <LCD_SendCommand+0x14>
     e66:	cc c0       	rjmp	.+408    	; 0x1000 <LCD_SendCommand+0x1ac>
     e68:	38 f4       	brcc	.+14     	; 0xe78 <LCD_SendCommand+0x24>
     e6a:	81 30       	cpi	r24, 0x01	; 1
     e6c:	09 f4       	brne	.+2      	; 0xe70 <LCD_SendCommand+0x1c>
     e6e:	5f c0       	rjmp	.+190    	; 0xf2e <LCD_SendCommand+0xda>
     e70:	82 30       	cpi	r24, 0x02	; 2
     e72:	09 f4       	brne	.+2      	; 0xe76 <LCD_SendCommand+0x22>
     e74:	80 c0       	rjmp	.+256    	; 0xf76 <LCD_SendCommand+0x122>
     e76:	ff c0       	rjmp	.+510    	; 0x1076 <LCD_SendCommand+0x222>
     e78:	84 30       	cpi	r24, 0x04	; 4
     e7a:	09 f4       	brne	.+2      	; 0xe7e <LCD_SendCommand+0x2a>
     e7c:	e4 c0       	rjmp	.+456    	; 0x1046 <LCD_SendCommand+0x1f2>
     e7e:	8f 3f       	cpi	r24, 0xFF	; 255
     e80:	09 f0       	breq	.+2      	; 0xe84 <LCD_SendCommand+0x30>
     e82:	f9 c0       	rjmp	.+498    	; 0x1076 <LCD_SendCommand+0x222>
     e84:	0f e2       	ldi	r16, 0x2F	; 47
     e86:	11 e0       	ldi	r17, 0x01	; 1
     e88:	f8 01       	movw	r30, r16
     e8a:	d0 81       	ld	r29, Z
     e8c:	40 e0       	ldi	r20, 0x00	; 0
     e8e:	61 81       	ldd	r22, Z+1	; 0x01
     e90:	8d 2f       	mov	r24, r29
     e92:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     e96:	40 e0       	ldi	r20, 0x00	; 0
     e98:	f8 01       	movw	r30, r16
     e9a:	62 81       	ldd	r22, Z+2	; 0x02
     e9c:	8d 2f       	mov	r24, r29
     e9e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     ea2:	4c 2f       	mov	r20, r28
     ea4:	40 71       	andi	r20, 0x10	; 16
     ea6:	50 e0       	ldi	r21, 0x00	; 0
     ea8:	55 95       	asr	r21
     eaa:	47 95       	ror	r20
     eac:	55 95       	asr	r21
     eae:	47 95       	ror	r20
     eb0:	55 95       	asr	r21
     eb2:	47 95       	ror	r20
     eb4:	55 95       	asr	r21
     eb6:	47 95       	ror	r20
     eb8:	f8 01       	movw	r30, r16
     eba:	67 81       	ldd	r22, Z+7	; 0x07
     ebc:	8d 2f       	mov	r24, r29
     ebe:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     ec2:	4c 2f       	mov	r20, r28
     ec4:	40 72       	andi	r20, 0x20	; 32
     ec6:	50 e0       	ldi	r21, 0x00	; 0
     ec8:	55 95       	asr	r21
     eca:	47 95       	ror	r20
     ecc:	55 95       	asr	r21
     ece:	47 95       	ror	r20
     ed0:	55 95       	asr	r21
     ed2:	47 95       	ror	r20
     ed4:	55 95       	asr	r21
     ed6:	47 95       	ror	r20
     ed8:	55 95       	asr	r21
     eda:	47 95       	ror	r20
     edc:	f8 01       	movw	r30, r16
     ede:	66 81       	ldd	r22, Z+6	; 0x06
     ee0:	8d 2f       	mov	r24, r29
     ee2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     ee6:	4c 2f       	mov	r20, r28
     ee8:	40 74       	andi	r20, 0x40	; 64
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	04 2e       	mov	r0, r20
     eee:	45 2f       	mov	r20, r21
     ef0:	00 0c       	add	r0, r0
     ef2:	44 1f       	adc	r20, r20
     ef4:	55 0b       	sbc	r21, r21
     ef6:	00 0c       	add	r0, r0
     ef8:	44 1f       	adc	r20, r20
     efa:	55 1f       	adc	r21, r21
     efc:	f8 01       	movw	r30, r16
     efe:	65 81       	ldd	r22, Z+5	; 0x05
     f00:	8d 2f       	mov	r24, r29
     f02:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f06:	4c 2f       	mov	r20, r28
     f08:	44 1f       	adc	r20, r20
     f0a:	44 27       	eor	r20, r20
     f0c:	44 1f       	adc	r20, r20
     f0e:	f8 01       	movw	r30, r16
     f10:	64 81       	ldd	r22, Z+4	; 0x04
     f12:	8d 2f       	mov	r24, r29
     f14:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f18:	41 e0       	ldi	r20, 0x01	; 1
     f1a:	f8 01       	movw	r30, r16
     f1c:	63 81       	ldd	r22, Z+3	; 0x03
     f1e:	8d 2f       	mov	r24, r29
     f20:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <State.1734>
     f2a:	8f ef       	ldi	r24, 0xFF	; 255
     f2c:	ab c0       	rjmp	.+342    	; 0x1084 <LCD_SendCommand+0x230>
     f2e:	6a e2       	ldi	r22, 0x2A	; 42
     f30:	77 e0       	ldi	r23, 0x07	; 7
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
     f38:	8b 3f       	cpi	r24, 0xFB	; 251
     f3a:	09 f0       	breq	.+2      	; 0xf3e <LCD_SendCommand+0xea>
     f3c:	9e c0       	rjmp	.+316    	; 0x107a <LCD_SendCommand+0x226>
     f3e:	2a e2       	ldi	r18, 0x2A	; 42
     f40:	37 e0       	ldi	r19, 0x07	; 7
     f42:	41 e0       	ldi	r20, 0x01	; 1
     f44:	50 e0       	ldi	r21, 0x00	; 0
     f46:	60 e0       	ldi	r22, 0x00	; 0
     f48:	70 e0       	ldi	r23, 0x00	; 0
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <TIM_DelayUs>
     f50:	6a e2       	ldi	r22, 0x2A	; 42
     f52:	77 e0       	ldi	r23, 0x07	; 7
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
     f5a:	81 11       	cpse	r24, r1
     f5c:	f9 cf       	rjmp	.-14     	; 0xf50 <LCD_SendCommand+0xfc>
     f5e:	ef e2       	ldi	r30, 0x2F	; 47
     f60:	f1 e0       	ldi	r31, 0x01	; 1
     f62:	40 e0       	ldi	r20, 0x00	; 0
     f64:	63 81       	ldd	r22, Z+3	; 0x03
     f66:	80 81       	ld	r24, Z
     f68:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f6c:	82 e0       	ldi	r24, 0x02	; 2
     f6e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <State.1734>
     f72:	8f ef       	ldi	r24, 0xFF	; 255
     f74:	87 c0       	rjmp	.+270    	; 0x1084 <LCD_SendCommand+0x230>
     f76:	0f e2       	ldi	r16, 0x2F	; 47
     f78:	11 e0       	ldi	r17, 0x01	; 1
     f7a:	f8 01       	movw	r30, r16
     f7c:	d0 81       	ld	r29, Z
     f7e:	40 e0       	ldi	r20, 0x00	; 0
     f80:	61 81       	ldd	r22, Z+1	; 0x01
     f82:	8d 2f       	mov	r24, r29
     f84:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f88:	40 e0       	ldi	r20, 0x00	; 0
     f8a:	f8 01       	movw	r30, r16
     f8c:	62 81       	ldd	r22, Z+2	; 0x02
     f8e:	8d 2f       	mov	r24, r29
     f90:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     f94:	4c 2f       	mov	r20, r28
     f96:	41 70       	andi	r20, 0x01	; 1
     f98:	f8 01       	movw	r30, r16
     f9a:	67 81       	ldd	r22, Z+7	; 0x07
     f9c:	8d 2f       	mov	r24, r29
     f9e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     fa2:	4c 2f       	mov	r20, r28
     fa4:	42 70       	andi	r20, 0x02	; 2
     fa6:	50 e0       	ldi	r21, 0x00	; 0
     fa8:	55 95       	asr	r21
     faa:	47 95       	ror	r20
     fac:	f8 01       	movw	r30, r16
     fae:	66 81       	ldd	r22, Z+6	; 0x06
     fb0:	8d 2f       	mov	r24, r29
     fb2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     fb6:	4c 2f       	mov	r20, r28
     fb8:	44 70       	andi	r20, 0x04	; 4
     fba:	50 e0       	ldi	r21, 0x00	; 0
     fbc:	55 95       	asr	r21
     fbe:	47 95       	ror	r20
     fc0:	55 95       	asr	r21
     fc2:	47 95       	ror	r20
     fc4:	f8 01       	movw	r30, r16
     fc6:	65 81       	ldd	r22, Z+5	; 0x05
     fc8:	8d 2f       	mov	r24, r29
     fca:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     fce:	c8 70       	andi	r28, 0x08	; 8
     fd0:	4c 2f       	mov	r20, r28
     fd2:	50 e0       	ldi	r21, 0x00	; 0
     fd4:	55 95       	asr	r21
     fd6:	47 95       	ror	r20
     fd8:	55 95       	asr	r21
     fda:	47 95       	ror	r20
     fdc:	55 95       	asr	r21
     fde:	47 95       	ror	r20
     fe0:	f8 01       	movw	r30, r16
     fe2:	64 81       	ldd	r22, Z+4	; 0x04
     fe4:	8d 2f       	mov	r24, r29
     fe6:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     fea:	41 e0       	ldi	r20, 0x01	; 1
     fec:	f8 01       	movw	r30, r16
     fee:	63 81       	ldd	r22, Z+3	; 0x03
     ff0:	8d 2f       	mov	r24, r29
     ff2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
     ff6:	83 e0       	ldi	r24, 0x03	; 3
     ff8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <State.1734>
     ffc:	8f ef       	ldi	r24, 0xFF	; 255
     ffe:	42 c0       	rjmp	.+132    	; 0x1084 <LCD_SendCommand+0x230>
    1000:	6a e2       	ldi	r22, 0x2A	; 42
    1002:	77 e0       	ldi	r23, 0x07	; 7
    1004:	80 e0       	ldi	r24, 0x00	; 0
    1006:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    100a:	8b 3f       	cpi	r24, 0xFB	; 251
    100c:	c1 f5       	brne	.+112    	; 0x107e <LCD_SendCommand+0x22a>
    100e:	2a e2       	ldi	r18, 0x2A	; 42
    1010:	37 e0       	ldi	r19, 0x07	; 7
    1012:	41 e0       	ldi	r20, 0x01	; 1
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	60 e0       	ldi	r22, 0x00	; 0
    1018:	70 e0       	ldi	r23, 0x00	; 0
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <TIM_DelayUs>
    1020:	6a e2       	ldi	r22, 0x2A	; 42
    1022:	77 e0       	ldi	r23, 0x07	; 7
    1024:	80 e0       	ldi	r24, 0x00	; 0
    1026:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    102a:	81 11       	cpse	r24, r1
    102c:	f9 cf       	rjmp	.-14     	; 0x1020 <LCD_SendCommand+0x1cc>
    102e:	ef e2       	ldi	r30, 0x2F	; 47
    1030:	f1 e0       	ldi	r31, 0x01	; 1
    1032:	40 e0       	ldi	r20, 0x00	; 0
    1034:	63 81       	ldd	r22, Z+3	; 0x03
    1036:	80 81       	ld	r24, Z
    1038:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
    103c:	84 e0       	ldi	r24, 0x04	; 4
    103e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <State.1734>
    1042:	8f ef       	ldi	r24, 0xFF	; 255
    1044:	1f c0       	rjmp	.+62     	; 0x1084 <LCD_SendCommand+0x230>
    1046:	6a e2       	ldi	r22, 0x2A	; 42
    1048:	77 e0       	ldi	r23, 0x07	; 7
    104a:	80 e0       	ldi	r24, 0x00	; 0
    104c:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    1050:	c8 2f       	mov	r28, r24
    1052:	8b 3f       	cpi	r24, 0xFB	; 251
    1054:	49 f4       	brne	.+18     	; 0x1068 <LCD_SendCommand+0x214>
    1056:	2a e2       	ldi	r18, 0x2A	; 42
    1058:	37 e0       	ldi	r19, 0x07	; 7
    105a:	42 e0       	ldi	r20, 0x02	; 2
    105c:	50 e0       	ldi	r21, 0x00	; 0
    105e:	60 e0       	ldi	r22, 0x00	; 0
    1060:	70 e0       	ldi	r23, 0x00	; 0
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	0e 94 19 10 	call	0x2032	; 0x2032 <TIM_DelayMs>
    1068:	c1 11       	cpse	r28, r1
    106a:	0b c0       	rjmp	.+22     	; 0x1082 <LCD_SendCommand+0x22e>
    106c:	8f ef       	ldi	r24, 0xFF	; 255
    106e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <State.1734>
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	07 c0       	rjmp	.+14     	; 0x1084 <LCD_SendCommand+0x230>
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	05 c0       	rjmp	.+10     	; 0x1084 <LCD_SendCommand+0x230>
    107a:	8f ef       	ldi	r24, 0xFF	; 255
    107c:	03 c0       	rjmp	.+6      	; 0x1084 <LCD_SendCommand+0x230>
    107e:	8f ef       	ldi	r24, 0xFF	; 255
    1080:	01 c0       	rjmp	.+2      	; 0x1084 <LCD_SendCommand+0x230>
    1082:	8f ef       	ldi	r24, 0xFF	; 255
    1084:	df 91       	pop	r29
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	08 95       	ret

0000108e <LCD_SendData>:
}



ERROR_STATE_t LCD_SendData(uint8_t Character)
{
    108e:	0f 93       	push	r16
    1090:	1f 93       	push	r17
    1092:	cf 93       	push	r28
    1094:	df 93       	push	r29
    1096:	c8 2f       	mov	r28, r24
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
	/*setting the functions state*/
	uint8_t static State = OperationStarted;
	#if LCD_4_BIT
	switch (State) {
    1098:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <State.1761>
    109c:	82 30       	cpi	r24, 0x02	; 2
    109e:	09 f4       	brne	.+2      	; 0x10a2 <LCD_SendData+0x14>
    10a0:	84 c0       	rjmp	.+264    	; 0x11aa <LCD_SendData+0x11c>
    10a2:	20 f4       	brcc	.+8      	; 0x10ac <LCD_SendData+0x1e>
    10a4:	81 30       	cpi	r24, 0x01	; 1
    10a6:	09 f4       	brne	.+2      	; 0x10aa <LCD_SendData+0x1c>
    10a8:	5c c0       	rjmp	.+184    	; 0x1162 <LCD_SendData+0xd4>
    10aa:	e7 c0       	rjmp	.+462    	; 0x127a <LCD_SendData+0x1ec>
    10ac:	83 30       	cpi	r24, 0x03	; 3
    10ae:	09 f4       	brne	.+2      	; 0x10b2 <LCD_SendData+0x24>
    10b0:	c1 c0       	rjmp	.+386    	; 0x1234 <LCD_SendData+0x1a6>
    10b2:	8f 3f       	cpi	r24, 0xFF	; 255
    10b4:	09 f0       	breq	.+2      	; 0x10b8 <LCD_SendData+0x2a>
    10b6:	e1 c0       	rjmp	.+450    	; 0x127a <LCD_SendData+0x1ec>
	case OperationStarted:
		/*sending control signals with configurations of selection of control reg. and write process*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rs, PIN_HIGH);
    10b8:	0f e2       	ldi	r16, 0x2F	; 47
    10ba:	11 e0       	ldi	r17, 0x01	; 1
    10bc:	f8 01       	movw	r30, r16
    10be:	d0 81       	ld	r29, Z
    10c0:	41 e0       	ldi	r20, 0x01	; 1
    10c2:	61 81       	ldd	r22, Z+1	; 0x01
    10c4:	8d 2f       	mov	r24, r29
    10c6:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rw, PIN_LOW);
    10ca:	40 e0       	ldi	r20, 0x00	; 0
    10cc:	f8 01       	movw	r30, r16
    10ce:	62 81       	ldd	r22, Z+2	; 0x02
    10d0:	8d 2f       	mov	r24, r29
    10d2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*copying upper nibble of the command to the pins*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D7, READ_BIT(Character, BIT_7));
    10d6:	4c 2f       	mov	r20, r28
    10d8:	44 1f       	adc	r20, r20
    10da:	44 27       	eor	r20, r20
    10dc:	44 1f       	adc	r20, r20
    10de:	f8 01       	movw	r30, r16
    10e0:	64 81       	ldd	r22, Z+4	; 0x04
    10e2:	8d 2f       	mov	r24, r29
    10e4:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D6, READ_BIT(Character, BIT_6));
    10e8:	4c 2f       	mov	r20, r28
    10ea:	40 74       	andi	r20, 0x40	; 64
    10ec:	50 e0       	ldi	r21, 0x00	; 0
    10ee:	04 2e       	mov	r0, r20
    10f0:	45 2f       	mov	r20, r21
    10f2:	00 0c       	add	r0, r0
    10f4:	44 1f       	adc	r20, r20
    10f6:	55 0b       	sbc	r21, r21
    10f8:	00 0c       	add	r0, r0
    10fa:	44 1f       	adc	r20, r20
    10fc:	55 1f       	adc	r21, r21
    10fe:	f8 01       	movw	r30, r16
    1100:	65 81       	ldd	r22, Z+5	; 0x05
    1102:	8d 2f       	mov	r24, r29
    1104:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D5, READ_BIT(Character, BIT_5));
    1108:	4c 2f       	mov	r20, r28
    110a:	40 72       	andi	r20, 0x20	; 32
    110c:	50 e0       	ldi	r21, 0x00	; 0
    110e:	55 95       	asr	r21
    1110:	47 95       	ror	r20
    1112:	55 95       	asr	r21
    1114:	47 95       	ror	r20
    1116:	55 95       	asr	r21
    1118:	47 95       	ror	r20
    111a:	55 95       	asr	r21
    111c:	47 95       	ror	r20
    111e:	55 95       	asr	r21
    1120:	47 95       	ror	r20
    1122:	f8 01       	movw	r30, r16
    1124:	66 81       	ldd	r22, Z+6	; 0x06
    1126:	8d 2f       	mov	r24, r29
    1128:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, READ_BIT(Character, BIT_4));
    112c:	c0 71       	andi	r28, 0x10	; 16
    112e:	4c 2f       	mov	r20, r28
    1130:	50 e0       	ldi	r21, 0x00	; 0
    1132:	55 95       	asr	r21
    1134:	47 95       	ror	r20
    1136:	55 95       	asr	r21
    1138:	47 95       	ror	r20
    113a:	55 95       	asr	r21
    113c:	47 95       	ror	r20
    113e:	55 95       	asr	r21
    1140:	47 95       	ror	r20
    1142:	f8 01       	movw	r30, r16
    1144:	67 81       	ldd	r22, Z+7	; 0x07
    1146:	8d 2f       	mov	r24, r29
    1148:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*writing data to the register by pulling the enable pin high for 1 Us*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_HIGH);
    114c:	41 e0       	ldi	r20, 0x01	; 1
    114e:	f8 01       	movw	r30, r16
    1150:	63 81       	ldd	r22, Z+3	; 0x03
    1152:	8d 2f       	mov	r24, r29
    1154:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*set status of the function*/
		State = Sending_First_Nibble;
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <State.1761>


ERROR_STATE_t LCD_SendData(uint8_t Character)
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    115e:	8f ef       	ldi	r24, 0xFF	; 255
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, READ_BIT(Character, BIT_4));
		/*writing data to the register by pulling the enable pin high for 1 Us*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_HIGH);
		/*set status of the function*/
		State = Sending_First_Nibble;
		break;
    1160:	91 c0       	rjmp	.+290    	; 0x1284 <LCD_SendData+0x1f6>
	case Sending_First_Nibble:
		/*start timer delay in background*/
      if(TIMER_E_DELAY_EMPTY == TIM_DelayStatus(TIMER_0, (void (*)(void))LCD_SendCommand))
    1162:	6a e2       	ldi	r22, 0x2A	; 42
    1164:	77 e0       	ldi	r23, 0x07	; 7
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    116c:	8b 3f       	cpi	r24, 0xFB	; 251
    116e:	09 f0       	breq	.+2      	; 0x1172 <LCD_SendData+0xe4>
    1170:	86 c0       	rjmp	.+268    	; 0x127e <LCD_SendData+0x1f0>
      {
         TIM_DelayUs(TIMER_0, 1,(void (*)(void)) LCD_SendCommand);
    1172:	2a e2       	ldi	r18, 0x2A	; 42
    1174:	37 e0       	ldi	r19, 0x07	; 7
    1176:	41 e0       	ldi	r20, 0x01	; 1
    1178:	50 e0       	ldi	r21, 0x00	; 0
    117a:	60 e0       	ldi	r22, 0x00	; 0
    117c:	70 e0       	ldi	r23, 0x00	; 0
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <TIM_DelayUs>
         while(ERROR_OK != TIM_DelayStatus(TIMER_0, (void (*)(void))LCD_SendCommand));
    1184:	6a e2       	ldi	r22, 0x2A	; 42
    1186:	77 e0       	ldi	r23, 0x07	; 7
    1188:	80 e0       	ldi	r24, 0x00	; 0
    118a:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    118e:	81 11       	cpse	r24, r1
    1190:	f9 cf       	rjmp	.-14     	; 0x1184 <LCD_SendData+0xf6>
         /*if timer delay function finished correctly pull enable pin low*/
         DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_LOW);
    1192:	ef e2       	ldi	r30, 0x2F	; 47
    1194:	f1 e0       	ldi	r31, 0x01	; 1
    1196:	40 e0       	ldi	r20, 0x00	; 0
    1198:	63 81       	ldd	r22, Z+3	; 0x03
    119a:	80 81       	ld	r24, Z
    119c:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
         /*update the function's state*/
         State = First_Nibble_Sent;
    11a0:	82 e0       	ldi	r24, 0x02	; 2
    11a2:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <State.1761>


ERROR_STATE_t LCD_SendData(uint8_t Character)
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    11a6:	8f ef       	ldi	r24, 0xFF	; 255
    11a8:	6d c0       	rjmp	.+218    	; 0x1284 <LCD_SendData+0x1f6>
         State = First_Nibble_Sent;
      }
		break;
	case First_Nibble_Sent:
		/*sending control signals with configurations of selection of control reg. and write process*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rs, PIN_HIGH);
    11aa:	0f e2       	ldi	r16, 0x2F	; 47
    11ac:	11 e0       	ldi	r17, 0x01	; 1
    11ae:	f8 01       	movw	r30, r16
    11b0:	d0 81       	ld	r29, Z
    11b2:	41 e0       	ldi	r20, 0x01	; 1
    11b4:	61 81       	ldd	r22, Z+1	; 0x01
    11b6:	8d 2f       	mov	r24, r29
    11b8:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rw, PIN_LOW);
    11bc:	40 e0       	ldi	r20, 0x00	; 0
    11be:	f8 01       	movw	r30, r16
    11c0:	62 81       	ldd	r22, Z+2	; 0x02
    11c2:	8d 2f       	mov	r24, r29
    11c4:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*copying lower nibble of the command to the pins*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D7, READ_BIT(Character, BIT_3));
    11c8:	4c 2f       	mov	r20, r28
    11ca:	48 70       	andi	r20, 0x08	; 8
    11cc:	50 e0       	ldi	r21, 0x00	; 0
    11ce:	55 95       	asr	r21
    11d0:	47 95       	ror	r20
    11d2:	55 95       	asr	r21
    11d4:	47 95       	ror	r20
    11d6:	55 95       	asr	r21
    11d8:	47 95       	ror	r20
    11da:	f8 01       	movw	r30, r16
    11dc:	64 81       	ldd	r22, Z+4	; 0x04
    11de:	8d 2f       	mov	r24, r29
    11e0:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D6, READ_BIT(Character, BIT_2));
    11e4:	4c 2f       	mov	r20, r28
    11e6:	44 70       	andi	r20, 0x04	; 4
    11e8:	50 e0       	ldi	r21, 0x00	; 0
    11ea:	55 95       	asr	r21
    11ec:	47 95       	ror	r20
    11ee:	55 95       	asr	r21
    11f0:	47 95       	ror	r20
    11f2:	f8 01       	movw	r30, r16
    11f4:	65 81       	ldd	r22, Z+5	; 0x05
    11f6:	8d 2f       	mov	r24, r29
    11f8:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D5, READ_BIT(Character, BIT_1));
    11fc:	4c 2f       	mov	r20, r28
    11fe:	42 70       	andi	r20, 0x02	; 2
    1200:	50 e0       	ldi	r21, 0x00	; 0
    1202:	55 95       	asr	r21
    1204:	47 95       	ror	r20
    1206:	f8 01       	movw	r30, r16
    1208:	66 81       	ldd	r22, Z+6	; 0x06
    120a:	8d 2f       	mov	r24, r29
    120c:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, READ_BIT(Character, BIT_0));
    1210:	4c 2f       	mov	r20, r28
    1212:	41 70       	andi	r20, 0x01	; 1
    1214:	f8 01       	movw	r30, r16
    1216:	67 81       	ldd	r22, Z+7	; 0x07
    1218:	8d 2f       	mov	r24, r29
    121a:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>

		/*writing data to the register by pulling the enable pin high for 1 Us*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_HIGH);
    121e:	41 e0       	ldi	r20, 0x01	; 1
    1220:	f8 01       	movw	r30, r16
    1222:	63 81       	ldd	r22, Z+3	; 0x03
    1224:	8d 2f       	mov	r24, r29
    1226:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*set status of the function*/
		State = Sending_Second_Nibble;
    122a:	83 e0       	ldi	r24, 0x03	; 3
    122c:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <State.1761>


ERROR_STATE_t LCD_SendData(uint8_t Character)
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1230:	8f ef       	ldi	r24, 0xFF	; 255

		/*writing data to the register by pulling the enable pin high for 1 Us*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_HIGH);
		/*set status of the function*/
		State = Sending_Second_Nibble;
		break;
    1232:	28 c0       	rjmp	.+80     	; 0x1284 <LCD_SendData+0x1f6>
	case Sending_Second_Nibble:
		/*start timer delay in background*/
      if(TIMER_E_DELAY_EMPTY == TIM_DelayStatus(TIMER_0, (void (*)(void))LCD_SendCommand))
    1234:	6a e2       	ldi	r22, 0x2A	; 42
    1236:	77 e0       	ldi	r23, 0x07	; 7
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    123e:	8b 3f       	cpi	r24, 0xFB	; 251
    1240:	01 f5       	brne	.+64     	; 0x1282 <LCD_SendData+0x1f4>
      {
         TIM_DelayUs(TIMER_0, 1, (void (*)(void))LCD_SendCommand);
    1242:	2a e2       	ldi	r18, 0x2A	; 42
    1244:	37 e0       	ldi	r19, 0x07	; 7
    1246:	41 e0       	ldi	r20, 0x01	; 1
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	70 e0       	ldi	r23, 0x00	; 0
    124e:	80 e0       	ldi	r24, 0x00	; 0
    1250:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <TIM_DelayUs>
         while(ERROR_OK != TIM_DelayStatus(TIMER_0, (void (*)(void))LCD_SendCommand));
    1254:	6a e2       	ldi	r22, 0x2A	; 42
    1256:	77 e0       	ldi	r23, 0x07	; 7
    1258:	80 e0       	ldi	r24, 0x00	; 0
    125a:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    125e:	81 11       	cpse	r24, r1
    1260:	f9 cf       	rjmp	.-14     	; 0x1254 <LCD_SendData+0x1c6>
         /*if timer delay function finished correctly pull enable pin low*/
         DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_LOW);
    1262:	ef e2       	ldi	r30, 0x2F	; 47
    1264:	f1 e0       	ldi	r31, 0x01	; 1
    1266:	40 e0       	ldi	r20, 0x00	; 0
    1268:	63 81       	ldd	r22, Z+3	; 0x03
    126a:	80 81       	ld	r24, Z
    126c:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
         /*reset the function's state*/
         State = OperationStarted;
    1270:	8f ef       	ldi	r24, 0xFF	; 255
    1272:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <State.1761>
         /*process finished successfully*/
         ErrRetVal = OperationSuccess;
    1276:	80 e0       	ldi	r24, 0x00	; 0
    1278:	05 c0       	rjmp	.+10     	; 0x1284 <LCD_SendData+0x1f6>
      }
		break;
	default:
		ErrRetVal = OperationFail;
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	03 c0       	rjmp	.+6      	; 0x1284 <LCD_SendData+0x1f6>


ERROR_STATE_t LCD_SendData(uint8_t Character)
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    127e:	8f ef       	ldi	r24, 0xFF	; 255
    1280:	01 c0       	rjmp	.+2      	; 0x1284 <LCD_SendData+0x1f6>
    1282:	8f ef       	ldi	r24, 0xFF	; 255
		break;
	}
	#endif
	/*return from function*/
	return ErrRetVal;
}
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	08 95       	ret

0000128e <LCD_Init>:




ERROR_STATE_t LCD_Init()
{
    128e:	bf 92       	push	r11
    1290:	cf 92       	push	r12
    1292:	df 92       	push	r13
    1294:	ef 92       	push	r14
    1296:	ff 92       	push	r15
    1298:	0f 93       	push	r16
    129a:	1f 93       	push	r17
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
	uint8_t static State = OperationStarted;
	/*declaring a variable for the timer return*/
	uint8_t TimerRetVal = 1;
	uint8_t LCD_SendCommandRetVal = OperationStarted;
	#if LCD_4_BIT
	switch (State) {
    12a0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
    12a4:	8b 30       	cpi	r24, 0x0B	; 11
    12a6:	09 f4       	brne	.+2      	; 0x12aa <LCD_Init+0x1c>
    12a8:	c3 c0       	rjmp	.+390    	; 0x1430 <LCD_Init+0x1a2>
    12aa:	90 f4       	brcc	.+36     	; 0x12d0 <LCD_Init+0x42>
    12ac:	88 30       	cpi	r24, 0x08	; 8
    12ae:	09 f4       	brne	.+2      	; 0x12b2 <LCD_Init+0x24>
    12b0:	a1 c0       	rjmp	.+322    	; 0x13f4 <LCD_Init+0x166>
    12b2:	38 f4       	brcc	.+14     	; 0x12c2 <LCD_Init+0x34>
    12b4:	85 30       	cpi	r24, 0x05	; 5
    12b6:	09 f4       	brne	.+2      	; 0x12ba <LCD_Init+0x2c>
    12b8:	7b c0       	rjmp	.+246    	; 0x13b0 <LCD_Init+0x122>
    12ba:	86 30       	cpi	r24, 0x06	; 6
    12bc:	09 f4       	brne	.+2      	; 0x12c0 <LCD_Init+0x32>
    12be:	90 c0       	rjmp	.+288    	; 0x13e0 <LCD_Init+0x152>
    12c0:	e9 c0       	rjmp	.+466    	; 0x1494 <LCD_Init+0x206>
    12c2:	89 30       	cpi	r24, 0x09	; 9
    12c4:	09 f4       	brne	.+2      	; 0x12c8 <LCD_Init+0x3a>
    12c6:	a0 c0       	rjmp	.+320    	; 0x1408 <LCD_Init+0x17a>
    12c8:	8a 30       	cpi	r24, 0x0A	; 10
    12ca:	09 f4       	brne	.+2      	; 0x12ce <LCD_Init+0x40>
    12cc:	a7 c0       	rjmp	.+334    	; 0x141c <LCD_Init+0x18e>
    12ce:	e2 c0       	rjmp	.+452    	; 0x1494 <LCD_Init+0x206>
    12d0:	8e 30       	cpi	r24, 0x0E	; 14
    12d2:	09 f4       	brne	.+2      	; 0x12d6 <LCD_Init+0x48>
    12d4:	cb c0       	rjmp	.+406    	; 0x146c <LCD_Init+0x1de>
    12d6:	38 f4       	brcc	.+14     	; 0x12e6 <LCD_Init+0x58>
    12d8:	8c 30       	cpi	r24, 0x0C	; 12
    12da:	09 f4       	brne	.+2      	; 0x12de <LCD_Init+0x50>
    12dc:	b3 c0       	rjmp	.+358    	; 0x1444 <LCD_Init+0x1b6>
    12de:	8d 30       	cpi	r24, 0x0D	; 13
    12e0:	09 f4       	brne	.+2      	; 0x12e4 <LCD_Init+0x56>
    12e2:	ba c0       	rjmp	.+372    	; 0x1458 <LCD_Init+0x1ca>
    12e4:	d7 c0       	rjmp	.+430    	; 0x1494 <LCD_Init+0x206>
    12e6:	8f 30       	cpi	r24, 0x0F	; 15
    12e8:	09 f4       	brne	.+2      	; 0x12ec <LCD_Init+0x5e>
    12ea:	ca c0       	rjmp	.+404    	; 0x1480 <LCD_Init+0x1f2>
    12ec:	8f 3f       	cpi	r24, 0xFF	; 255
    12ee:	09 f0       	breq	.+2      	; 0x12f2 <LCD_Init+0x64>
    12f0:	d1 c0       	rjmp	.+418    	; 0x1494 <LCD_Init+0x206>
	case OperationStarted:
		/*Dio and Timer Initialize for the*/
		TIM_Init(TIMER_0);
    12f2:	80 e0       	ldi	r24, 0x00	; 0
    12f4:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <TIM_Init>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D7, PIN_OUTPUT);
    12f8:	0f e2       	ldi	r16, 0x2F	; 47
    12fa:	11 e0       	ldi	r17, 0x01	; 1
    12fc:	f8 01       	movw	r30, r16
    12fe:	b4 80       	ldd	r11, Z+4	; 0x04
    1300:	c0 81       	ld	r28, Z
    1302:	41 e0       	ldi	r20, 0x01	; 1
    1304:	6b 2d       	mov	r22, r11
    1306:	8c 2f       	mov	r24, r28
    1308:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D6, PIN_OUTPUT);
    130c:	f8 01       	movw	r30, r16
    130e:	c5 80       	ldd	r12, Z+5	; 0x05
    1310:	41 e0       	ldi	r20, 0x01	; 1
    1312:	6c 2d       	mov	r22, r12
    1314:	8c 2f       	mov	r24, r28
    1316:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D5, PIN_OUTPUT);
    131a:	f8 01       	movw	r30, r16
    131c:	d6 80       	ldd	r13, Z+6	; 0x06
    131e:	41 e0       	ldi	r20, 0x01	; 1
    1320:	6d 2d       	mov	r22, r13
    1322:	8c 2f       	mov	r24, r28
    1324:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, PIN_OUTPUT);
    1328:	f8 01       	movw	r30, r16
    132a:	e7 80       	ldd	r14, Z+7	; 0x07
    132c:	41 e0       	ldi	r20, 0x01	; 1
    132e:	6e 2d       	mov	r22, r14
    1330:	8c 2f       	mov	r24, r28
    1332:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rs, PIN_OUTPUT);
    1336:	f8 01       	movw	r30, r16
    1338:	f1 80       	ldd	r15, Z+1	; 0x01
    133a:	41 e0       	ldi	r20, 0x01	; 1
    133c:	6f 2d       	mov	r22, r15
    133e:	8c 2f       	mov	r24, r28
    1340:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rw, PIN_OUTPUT);
    1344:	f8 01       	movw	r30, r16
    1346:	d2 81       	ldd	r29, Z+2	; 0x02
    1348:	41 e0       	ldi	r20, 0x01	; 1
    134a:	6d 2f       	mov	r22, r29
    134c:	8c 2f       	mov	r24, r28
    134e:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		DIO_SetPinDirection(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_OUTPUT);
    1352:	f8 01       	movw	r30, r16
    1354:	13 81       	ldd	r17, Z+3	; 0x03
    1356:	41 e0       	ldi	r20, 0x01	; 1
    1358:	61 2f       	mov	r22, r17
    135a:	8c 2f       	mov	r24, r28
    135c:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
		/*setting initial value for LCD Pins*/
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D7, PIN_LOW);
    1360:	40 e0       	ldi	r20, 0x00	; 0
    1362:	6b 2d       	mov	r22, r11
    1364:	8c 2f       	mov	r24, r28
    1366:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D6, PIN_LOW);
    136a:	40 e0       	ldi	r20, 0x00	; 0
    136c:	6c 2d       	mov	r22, r12
    136e:	8c 2f       	mov	r24, r28
    1370:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D5, PIN_LOW);
    1374:	40 e0       	ldi	r20, 0x00	; 0
    1376:	6d 2d       	mov	r22, r13
    1378:	8c 2f       	mov	r24, r28
    137a:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_D4, PIN_LOW);
    137e:	40 e0       	ldi	r20, 0x00	; 0
    1380:	6e 2d       	mov	r22, r14
    1382:	8c 2f       	mov	r24, r28
    1384:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rs, PIN_LOW);
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	6f 2d       	mov	r22, r15
    138c:	8c 2f       	mov	r24, r28
    138e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rw, PIN_LOW);
    1392:	40 e0       	ldi	r20, 0x00	; 0
    1394:	6d 2f       	mov	r22, r29
    1396:	8c 2f       	mov	r24, r28
    1398:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_LOW);
    139c:	40 e0       	ldi	r20, 0x00	; 0
    139e:	61 2f       	mov	r22, r17
    13a0:	8c 2f       	mov	r24, r28
    13a2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
		/*set status of the function*/
		State = LCD_Pin_Initializing;
    13a6:	85 e0       	ldi	r24, 0x05	; 5
    13a8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    13ac:	8f ef       	ldi	r24, 0xFF	; 255
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rs, PIN_LOW);
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_Rw, PIN_LOW);
		DIO_WritePin(gastr_LCD_Config[LCD_Channel_0].u8_LCD_Port, gastr_LCD_Config[LCD_Channel_0].u8_LCD_En, PIN_LOW);
		/*set status of the function*/
		State = LCD_Pin_Initializing;
		break;
    13ae:	87 c0       	rjmp	.+270    	; 0x14be <LCD_Init+0x230>
	case LCD_Pin_Initializing:
		/*start timer delay in background*/
		TimerRetVal = TIM_DelayStatus(TIMER_0, (void (*)(void))LCD_SendCommand);
    13b0:	6a e2       	ldi	r22, 0x2A	; 42
    13b2:	77 e0       	ldi	r23, 0x07	; 7
    13b4:	80 e0       	ldi	r24, 0x00	; 0
    13b6:	0e 94 aa 10 	call	0x2154	; 0x2154 <TIM_DelayStatus>
    13ba:	c8 2f       	mov	r28, r24
		if(TIMER_E_DELAY_EMPTY == TimerRetVal)
    13bc:	8b 3f       	cpi	r24, 0xFB	; 251
    13be:	49 f4       	brne	.+18     	; 0x13d2 <LCD_Init+0x144>
		{
   		TIM_DelayMs(TIMER_0,15, (void (*)(void))LCD_SendCommand);
    13c0:	2a e2       	ldi	r18, 0x2A	; 42
    13c2:	37 e0       	ldi	r19, 0x07	; 7
    13c4:	4f e0       	ldi	r20, 0x0F	; 15
    13c6:	50 e0       	ldi	r21, 0x00	; 0
    13c8:	60 e0       	ldi	r22, 0x00	; 0
    13ca:	70 e0       	ldi	r23, 0x00	; 0
    13cc:	80 e0       	ldi	r24, 0x00	; 0
    13ce:	0e 94 19 10 	call	0x2032	; 0x2032 <TIM_DelayMs>
		}
		if(TimerRetVal == ((uint8_t)ERROR_OK))
    13d2:	c1 11       	cpse	r28, r1
    13d4:	61 c0       	rjmp	.+194    	; 0x1498 <LCD_Init+0x20a>
		{
   		/*if timer delay function finished correctly Start the initialization sequence*/
   		State = LCD_Start_Sending_Initialization_Sequence;
    13d6:	86 e0       	ldi	r24, 0x06	; 6
    13d8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    13dc:	8f ef       	ldi	r24, 0xFF	; 255
    13de:	6f c0       	rjmp	.+222    	; 0x14be <LCD_Init+0x230>
   		/*if timer delay function finished correctly Start the initialization sequence*/
   		State = LCD_Start_Sending_Initialization_Sequence;
		}
		break;
	case LCD_Start_Sending_Initialization_Sequence:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_Init_CMD_1);
    13e0:	83 e0       	ldi	r24, 0x03	; 3
    13e2:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    13e6:	81 11       	cpse	r24, r1
    13e8:	59 c0       	rjmp	.+178    	; 0x149c <LCD_Init+0x20e>
		{
			State = First_Cmd_In_Initialization_Sequence_Is_Sent;
    13ea:	88 e0       	ldi	r24, 0x08	; 8
    13ec:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    13f0:	8f ef       	ldi	r24, 0xFF	; 255
    13f2:	65 c0       	rjmp	.+202    	; 0x14be <LCD_Init+0x230>
		{
			State = First_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case First_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_Init_CMD_1);
    13f4:	83 e0       	ldi	r24, 0x03	; 3
    13f6:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    13fa:	81 11       	cpse	r24, r1
    13fc:	51 c0       	rjmp	.+162    	; 0x14a0 <LCD_Init+0x212>
		{
			State = Second_Cmd_In_Initialization_Sequence_Is_Sent;
    13fe:	89 e0       	ldi	r24, 0x09	; 9
    1400:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1404:	8f ef       	ldi	r24, 0xFF	; 255
    1406:	5b c0       	rjmp	.+182    	; 0x14be <LCD_Init+0x230>
		{
			State = Second_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Second_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_Init_CMD_1);
    1408:	83 e0       	ldi	r24, 0x03	; 3
    140a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    140e:	81 11       	cpse	r24, r1
    1410:	49 c0       	rjmp	.+146    	; 0x14a4 <LCD_Init+0x216>
		{
			State = Third_Cmd_In_Initialization_Sequence_Is_Sent;
    1412:	8a e0       	ldi	r24, 0x0A	; 10
    1414:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1418:	8f ef       	ldi	r24, 0xFF	; 255
    141a:	51 c0       	rjmp	.+162    	; 0x14be <LCD_Init+0x230>
		{
			State = Third_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Third_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_HOME);
    141c:	82 e0       	ldi	r24, 0x02	; 2
    141e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    1422:	81 11       	cpse	r24, r1
    1424:	41 c0       	rjmp	.+130    	; 0x14a8 <LCD_Init+0x21a>
		{
			State = Fourth_Cmd_In_Initialization_Sequence_Is_Sent;
    1426:	8b e0       	ldi	r24, 0x0B	; 11
    1428:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    142c:	8f ef       	ldi	r24, 0xFF	; 255
    142e:	47 c0       	rjmp	.+142    	; 0x14be <LCD_Init+0x230>
		{
			State = Fourth_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Fourth_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_FUNCSET_6);
    1430:	88 e2       	ldi	r24, 0x28	; 40
    1432:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    1436:	81 11       	cpse	r24, r1
    1438:	39 c0       	rjmp	.+114    	; 0x14ac <LCD_Init+0x21e>
		{
			State = Fifth_Cmd_In_Initialization_Sequence_Is_Sent;
    143a:	8c e0       	ldi	r24, 0x0C	; 12
    143c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1440:	8f ef       	ldi	r24, 0xFF	; 255
    1442:	3d c0       	rjmp	.+122    	; 0x14be <LCD_Init+0x230>
		{
			State = Fifth_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Fifth_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_DISPON_CURSBLINK);
    1444:	8f e0       	ldi	r24, 0x0F	; 15
    1446:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    144a:	81 11       	cpse	r24, r1
    144c:	31 c0       	rjmp	.+98     	; 0x14b0 <LCD_Init+0x222>
		{
			State = Sixth_Cmd_In_Initialization_Sequence_Is_Sent;
    144e:	8d e0       	ldi	r24, 0x0D	; 13
    1450:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1454:	8f ef       	ldi	r24, 0xFF	; 255
    1456:	33 c0       	rjmp	.+102    	; 0x14be <LCD_Init+0x230>
		{
			State = Sixth_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Sixth_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_INCREMENTENTRYMODE);//LCD_INCREMENTENTRYMODE/LCD_SHIFTINCREMENTENTRYMODE
    1458:	86 e0       	ldi	r24, 0x06	; 6
    145a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    145e:	81 11       	cpse	r24, r1
    1460:	29 c0       	rjmp	.+82     	; 0x14b4 <LCD_Init+0x226>
		{
			State = Seventh_Cmd_In_Initialization_Sequence_Is_Sent;
    1462:	8e e0       	ldi	r24, 0x0E	; 14
    1464:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1468:	8f ef       	ldi	r24, 0xFF	; 255
    146a:	29 c0       	rjmp	.+82     	; 0x14be <LCD_Init+0x230>
		{
			State = Seventh_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Seventh_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_CLR);
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    1472:	81 11       	cpse	r24, r1
    1474:	21 c0       	rjmp	.+66     	; 0x14b8 <LCD_Init+0x22a>
		{
			State = Final_Cmd_In_Initialization_Sequence_Is_Sent;
    1476:	8f e0       	ldi	r24, 0x0F	; 15
    1478:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    147c:	8f ef       	ldi	r24, 0xFF	; 255
    147e:	1f c0       	rjmp	.+62     	; 0x14be <LCD_Init+0x230>
		{
			State = Final_Cmd_In_Initialization_Sequence_Is_Sent;
		}
		break;
	case Final_Cmd_In_Initialization_Sequence_Is_Sent:
		LCD_SendCommandRetVal = LCD_SendCommand(LCD_CURS_Position0);
    1480:	80 e8       	ldi	r24, 0x80	; 128
    1482:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
		if(LCD_SendCommandRetVal == OperationSuccess)
    1486:	81 11       	cpse	r24, r1
    1488:	19 c0       	rjmp	.+50     	; 0x14bc <LCD_Init+0x22e>
		{
			State = OperationStarted;
    148a:	8f ef       	ldi	r24, 0xFF	; 255
    148c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			ErrRetVal = OperationSuccess;
    1490:	80 e0       	ldi	r24, 0x00	; 0
    1492:	15 c0       	rjmp	.+42     	; 0x14be <LCD_Init+0x230>
		}
		break;
	default:
		ErrRetVal = OperationFail;
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	13 c0       	rjmp	.+38     	; 0x14be <LCD_Init+0x230>


ERROR_STATE_t LCD_Init()
{
	/*function starting*/
	uint8_t ErrRetVal = OperationStarted;
    1498:	8f ef       	ldi	r24, 0xFF	; 255
    149a:	11 c0       	rjmp	.+34     	; 0x14be <LCD_Init+0x230>
    149c:	8f ef       	ldi	r24, 0xFF	; 255
    149e:	0f c0       	rjmp	.+30     	; 0x14be <LCD_Init+0x230>
    14a0:	8f ef       	ldi	r24, 0xFF	; 255
    14a2:	0d c0       	rjmp	.+26     	; 0x14be <LCD_Init+0x230>
    14a4:	8f ef       	ldi	r24, 0xFF	; 255
    14a6:	0b c0       	rjmp	.+22     	; 0x14be <LCD_Init+0x230>
    14a8:	8f ef       	ldi	r24, 0xFF	; 255
    14aa:	09 c0       	rjmp	.+18     	; 0x14be <LCD_Init+0x230>
    14ac:	8f ef       	ldi	r24, 0xFF	; 255
    14ae:	07 c0       	rjmp	.+14     	; 0x14be <LCD_Init+0x230>
    14b0:	8f ef       	ldi	r24, 0xFF	; 255
    14b2:	05 c0       	rjmp	.+10     	; 0x14be <LCD_Init+0x230>
    14b4:	8f ef       	ldi	r24, 0xFF	; 255
    14b6:	03 c0       	rjmp	.+6      	; 0x14be <LCD_Init+0x230>
    14b8:	8f ef       	ldi	r24, 0xFF	; 255
    14ba:	01 c0       	rjmp	.+2      	; 0x14be <LCD_Init+0x230>
    14bc:	8f ef       	ldi	r24, 0xFF	; 255
		ErrRetVal = OperationFail;
		break;
	}
	#endif
	return ErrRetVal;
}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	1f 91       	pop	r17
    14c4:	0f 91       	pop	r16
    14c6:	ff 90       	pop	r15
    14c8:	ef 90       	pop	r14
    14ca:	df 90       	pop	r13
    14cc:	cf 90       	pop	r12
    14ce:	bf 90       	pop	r11
    14d0:	08 95       	ret

000014d2 <LCD_SendString>:
ERROR_STATE_t LCD_SendString(const uint8_t* String)
{
	uint8_t ErrRetVal = OperationStarted;
	uint8_t LCD_SendDataRetVal = OperationStarted;
	static uint8_t Number = 0;
	if (String != NULL_PTR) {
    14d2:	00 97       	sbiw	r24, 0x00	; 0
    14d4:	b9 f0       	breq	.+46     	; 0x1504 <LCD_SendString+0x32>
		if (String[Number] != NULL_TERMINATOR ) {
    14d6:	20 91 a9 07 	lds	r18, 0x07A9	; 0x8007a9 <Number.1806>
    14da:	fc 01       	movw	r30, r24
    14dc:	e2 0f       	add	r30, r18
    14de:	f1 1d       	adc	r31, r1
    14e0:	80 81       	ld	r24, Z
    14e2:	88 23       	and	r24, r24
    14e4:	59 f0       	breq	.+22     	; 0x14fc <LCD_SendString+0x2a>
			ErrRetVal = OperationRunning;
			LCD_SendDataRetVal = LCD_SendData(String[Number]);
    14e6:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
			if(LCD_SendDataRetVal == OperationSuccess)
    14ea:	81 11       	cpse	r24, r1
    14ec:	0d c0       	rjmp	.+26     	; 0x1508 <LCD_SendString+0x36>
			{
				Number++;
    14ee:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <Number.1806>
    14f2:	8f 5f       	subi	r24, 0xFF	; 255
    14f4:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <Number.1806>
	uint8_t ErrRetVal = OperationStarted;
	uint8_t LCD_SendDataRetVal = OperationStarted;
	static uint8_t Number = 0;
	if (String != NULL_PTR) {
		if (String[Number] != NULL_TERMINATOR ) {
			ErrRetVal = OperationRunning;
    14f8:	82 e0       	ldi	r24, 0x02	; 2
    14fa:	08 95       	ret
				Number++;
			}
		}
		else
		{
			Number = 0;
    14fc:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <Number.1806>
			ErrRetVal = OperationSuccess;
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	08 95       	ret
		}
	} else {
		ErrRetVal = OperationFail;
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	08 95       	ret
	uint8_t ErrRetVal = OperationStarted;
	uint8_t LCD_SendDataRetVal = OperationStarted;
	static uint8_t Number = 0;
	if (String != NULL_PTR) {
		if (String[Number] != NULL_TERMINATOR ) {
			ErrRetVal = OperationRunning;
    1508:	82 e0       	ldi	r24, 0x02	; 2
		}
	} else {
		ErrRetVal = OperationFail;
	}
	return ErrRetVal;
}
    150a:	08 95       	ret

0000150c <LCD_SendNumber>:




ERROR_STATE_t LCD_SendNumber(uint32_t Number)
{
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	cd b7       	in	r28, 0x3d	; 61
    1512:	de b7       	in	r29, 0x3e	; 62
    1514:	2a 97       	sbiw	r28, 0x0a	; 10
    1516:	0f b6       	in	r0, 0x3f	; 63
    1518:	f8 94       	cli
    151a:	de bf       	out	0x3e, r29	; 62
    151c:	0f be       	out	0x3f, r0	; 63
    151e:	cd bf       	out	0x3d, r28	; 61
	/*urgent a blocking function*/
	uint8_t ErrRetVal = OperationStarted;
	uint8_t FunRetVal = OperationStarted;
	uint8_t String[10];
	STR_Number2String((uint32_t)Number,String);
    1520:	ae 01       	movw	r20, r28
    1522:	4f 5f       	subi	r20, 0xFF	; 255
    1524:	5f 4f       	sbci	r21, 0xFF	; 255
    1526:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <STR_Number2String>

ERROR_STATE_t LCD_SendNumber(uint32_t Number)
{
	/*urgent a blocking function*/
	uint8_t ErrRetVal = OperationStarted;
	uint8_t FunRetVal = OperationStarted;
    152a:	8f ef       	ldi	r24, 0xFF	; 255


ERROR_STATE_t LCD_SendNumber(uint32_t Number)
{
	/*urgent a blocking function*/
	uint8_t ErrRetVal = OperationStarted;
    152c:	9f ef       	ldi	r25, 0xFF	; 255
	uint8_t FunRetVal = OperationStarted;
	uint8_t String[10];
	STR_Number2String((uint32_t)Number,String);
	while(FunRetVal != OperationSuccess)
    152e:	09 c0       	rjmp	.+18     	; 0x1542 <LCD_SendNumber+0x36>
   {
      FunRetVal = LCD_SendString((uint8_t*)String);
    1530:	ce 01       	movw	r24, r28
    1532:	01 96       	adiw	r24, 0x01	; 1
    1534:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
      if(FunRetVal == OperationSuccess)
    1538:	81 11       	cpse	r24, r1
    153a:	02 c0       	rjmp	.+4      	; 0x1540 <LCD_SendNumber+0x34>
      {
         ErrRetVal = OperationSuccess;
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	01 c0       	rjmp	.+2      	; 0x1542 <LCD_SendNumber+0x36>
      }
      else
      {
         ErrRetVal = OperationFail;
    1540:	91 e0       	ldi	r25, 0x01	; 1
	/*urgent a blocking function*/
	uint8_t ErrRetVal = OperationStarted;
	uint8_t FunRetVal = OperationStarted;
	uint8_t String[10];
	STR_Number2String((uint32_t)Number,String);
	while(FunRetVal != OperationSuccess)
    1542:	81 11       	cpse	r24, r1
    1544:	f5 cf       	rjmp	.-22     	; 0x1530 <LCD_SendNumber+0x24>
      {
         ErrRetVal = OperationFail;
      }
   }
	return ErrRetVal;
}
    1546:	89 2f       	mov	r24, r25
    1548:	2a 96       	adiw	r28, 0x0a	; 10
    154a:	0f b6       	in	r0, 0x3f	; 63
    154c:	f8 94       	cli
    154e:	de bf       	out	0x3e, r29	; 62
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	cd bf       	out	0x3d, r28	; 61
    1554:	df 91       	pop	r29
    1556:	cf 91       	pop	r28
    1558:	08 95       	ret

0000155a <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    155a:	ef 92       	push	r14
    155c:	ff 92       	push	r15
    155e:	0f 93       	push	r16
    1560:	1f 93       	push	r17
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1566:	81 11       	cpse	r24, r1
    1568:	4e c0       	rjmp	.+156    	; 0x1606 <LED_Init+0xac>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    156a:	c8 2f       	mov	r28, r24
    156c:	d0 e0       	ldi	r29, 0x00	; 0
    156e:	fe 01       	movw	r30, r28
    1570:	e6 55       	subi	r30, 0x56	; 86
    1572:	f8 4f       	sbci	r31, 0xF8	; 248
    1574:	80 81       	ld	r24, Z
    1576:	81 30       	cpi	r24, 0x01	; 1
    1578:	09 f4       	brne	.+2      	; 0x157c <LED_Init+0x22>
    157a:	47 c0       	rjmp	.+142    	; 0x160a <LED_Init+0xb0>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      /* Normal LED Config */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    157c:	fe 01       	movw	r30, r28
    157e:	ee 0f       	add	r30, r30
    1580:	ff 1f       	adc	r31, r31
    1582:	ee 0f       	add	r30, r30
    1584:	ff 1f       	adc	r31, r31
    1586:	e9 5c       	subi	r30, 0xC9	; 201
    1588:	fe 4f       	sbci	r31, 0xFE	; 254
    158a:	82 81       	ldd	r24, Z+2	; 0x02
    158c:	81 11       	cpse	r24, r1
    158e:	14 c0       	rjmp	.+40     	; 0x15b8 <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1590:	fe 01       	movw	r30, r28
    1592:	ee 0f       	add	r30, r30
    1594:	ff 1f       	adc	r31, r31
    1596:	ee 0f       	add	r30, r30
    1598:	ff 1f       	adc	r31, r31
    159a:	e9 5c       	subi	r30, 0xC9	; 201
    159c:	fe 4f       	sbci	r31, 0xFE	; 254
    159e:	61 81       	ldd	r22, Z+1	; 0x01
    15a0:	41 e0       	ldi	r20, 0x01	; 1
    15a2:	80 81       	ld	r24, Z
    15a4:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    15a8:	81 11       	cpse	r24, r1
    15aa:	31 c0       	rjmp	.+98     	; 0x160e <LED_Init+0xb4>
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    15ac:	c6 55       	subi	r28, 0x56	; 86
    15ae:	d8 4f       	sbci	r29, 0xF8	; 248
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    15b4:	80 e0       	ldi	r24, 0x00	; 0
    15b6:	30 c0       	rjmp	.+96     	; 0x1618 <LED_Init+0xbe>
         }
      }
      /* PWM LED Config */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    15b8:	81 30       	cpi	r24, 0x01	; 1
    15ba:	59 f5       	brne	.+86     	; 0x1612 <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         /* configure LED pin */
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    15bc:	ce 01       	movw	r24, r28
    15be:	88 0f       	add	r24, r24
    15c0:	99 1f       	adc	r25, r25
    15c2:	88 0f       	add	r24, r24
    15c4:	99 1f       	adc	r25, r25
    15c6:	9c 01       	movw	r18, r24
    15c8:	29 5c       	subi	r18, 0xC9	; 201
    15ca:	3e 4f       	sbci	r19, 0xFE	; 254
    15cc:	79 01       	movw	r14, r18
    15ce:	f9 01       	movw	r30, r18
    15d0:	03 81       	ldd	r16, Z+3	; 0x03
    15d2:	80 2f       	mov	r24, r16
    15d4:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <PWM_Init>
    15d8:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    15da:	41 e0       	ldi	r20, 0x01	; 1
    15dc:	f7 01       	movw	r30, r14
    15de:	61 81       	ldd	r22, Z+1	; 0x01
    15e0:	80 81       	ld	r24, Z
    15e2:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
    15e6:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    15e8:	80 2f       	mov	r24, r16
    15ea:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <PWM_Start>
    15ee:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    15f0:	80 2f       	mov	r24, r16
    15f2:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <PWM_Connect>
    15f6:	81 2b       	or	r24, r17
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
    15f8:	71 f4       	brne	.+28     	; 0x1616 <LED_Init+0xbc>
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    15fa:	c6 55       	subi	r28, 0x56	; 86
    15fc:	d8 4f       	sbci	r29, 0xF8	; 248
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	09 c0       	rjmp	.+18     	; 0x1618 <LED_Init+0xbe>
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1606:	81 ec       	ldi	r24, 0xC1	; 193
    1608:	07 c0       	rjmp	.+14     	; 0x1618 <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      /* Set init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    160a:	82 ec       	ldi	r24, 0xC2	; 194
    160c:	05 c0       	rjmp	.+10     	; 0x1618 <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	03 c0       	rjmp	.+6      	; 0x1618 <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	01 c0       	rjmp	.+2      	; 0x1618 <LED_Init+0xbe>
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1616:	81 e0       	ldi	r24, 0x01	; 1
      }   
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1618:	df 91       	pop	r29
    161a:	cf 91       	pop	r28
    161c:	1f 91       	pop	r17
    161e:	0f 91       	pop	r16
    1620:	ff 90       	pop	r15
    1622:	ef 90       	pop	r14
    1624:	08 95       	ret

00001626 <LED_Off>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1626:	81 11       	cpse	r24, r1
    1628:	32 c0       	rjmp	.+100    	; 0x168e <LED_Off+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	fc 01       	movw	r30, r24
    162e:	e6 55       	subi	r30, 0x56	; 86
    1630:	f8 4f       	sbci	r31, 0xF8	; 248
    1632:	20 81       	ld	r18, Z
    1634:	21 30       	cpi	r18, 0x01	; 1
    1636:	69 f5       	brne	.+90     	; 0x1692 <LED_Off+0x6c>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      /* Normal LED */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1638:	fc 01       	movw	r30, r24
    163a:	ee 0f       	add	r30, r30
    163c:	ff 1f       	adc	r31, r31
    163e:	ee 0f       	add	r30, r30
    1640:	ff 1f       	adc	r31, r31
    1642:	e9 5c       	subi	r30, 0xC9	; 201
    1644:	fe 4f       	sbci	r31, 0xFE	; 254
    1646:	22 81       	ldd	r18, Z+2	; 0x02
    1648:	21 11       	cpse	r18, r1
    164a:	10 c0       	rjmp	.+32     	; 0x166c <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    164c:	88 0f       	add	r24, r24
    164e:	99 1f       	adc	r25, r25
    1650:	88 0f       	add	r24, r24
    1652:	99 1f       	adc	r25, r25
    1654:	fc 01       	movw	r30, r24
    1656:	e9 5c       	subi	r30, 0xC9	; 201
    1658:	fe 4f       	sbci	r31, 0xFE	; 254
    165a:	61 81       	ldd	r22, Z+1	; 0x01
    165c:	40 e0       	ldi	r20, 0x00	; 0
    165e:	80 81       	ld	r24, Z
    1660:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    1664:	88 23       	and	r24, r24
    1666:	b9 f0       	breq	.+46     	; 0x1696 <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	08 95       	ret
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      /* PWM LED */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    166c:	21 30       	cpi	r18, 0x01	; 1
    166e:	a9 f4       	brne	.+42     	; 0x169a <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to Minimum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MIN_DUTY);
    1670:	88 0f       	add	r24, r24
    1672:	99 1f       	adc	r25, r25
    1674:	88 0f       	add	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	fc 01       	movw	r30, r24
    167a:	e9 5c       	subi	r30, 0xC9	; 201
    167c:	fe 4f       	sbci	r31, 0xFE	; 254
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	83 81       	ldd	r24, Z+3	; 0x03
    1682:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    1686:	88 23       	and	r24, r24
    1688:	51 f0       	breq	.+20     	; 0x169e <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    168e:	81 ec       	ldi	r24, 0xC1	; 193
    1690:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1692:	83 ec       	ldi	r24, 0xC3	; 195
    1694:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    169e:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    16a0:	08 95       	ret

000016a2 <LED_On>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    16a2:	81 11       	cpse	r24, r1
    16a4:	32 c0       	rjmp	.+100    	; 0x170a <LED_On+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	fc 01       	movw	r30, r24
    16aa:	e6 55       	subi	r30, 0x56	; 86
    16ac:	f8 4f       	sbci	r31, 0xF8	; 248
    16ae:	20 81       	ld	r18, Z
    16b0:	21 30       	cpi	r18, 0x01	; 1
    16b2:	69 f5       	brne	.+90     	; 0x170e <LED_On+0x6c>
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    16b4:	fc 01       	movw	r30, r24
    16b6:	ee 0f       	add	r30, r30
    16b8:	ff 1f       	adc	r31, r31
    16ba:	ee 0f       	add	r30, r30
    16bc:	ff 1f       	adc	r31, r31
    16be:	e9 5c       	subi	r30, 0xC9	; 201
    16c0:	fe 4f       	sbci	r31, 0xFE	; 254
    16c2:	22 81       	ldd	r18, Z+2	; 0x02
    16c4:	21 11       	cpse	r18, r1
    16c6:	10 c0       	rjmp	.+32     	; 0x16e8 <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to high */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    16c8:	88 0f       	add	r24, r24
    16ca:	99 1f       	adc	r25, r25
    16cc:	88 0f       	add	r24, r24
    16ce:	99 1f       	adc	r25, r25
    16d0:	fc 01       	movw	r30, r24
    16d2:	e9 5c       	subi	r30, 0xC9	; 201
    16d4:	fe 4f       	sbci	r31, 0xFE	; 254
    16d6:	61 81       	ldd	r22, Z+1	; 0x01
    16d8:	41 e0       	ldi	r20, 0x01	; 1
    16da:	80 81       	ld	r24, Z
    16dc:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    16e0:	88 23       	and	r24, r24
    16e2:	b9 f0       	breq	.+46     	; 0x1712 <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    16e8:	21 30       	cpi	r18, 0x01	; 1
    16ea:	a9 f4       	brne	.+42     	; 0x1716 <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to maximum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MAX_DUTY);
    16ec:	88 0f       	add	r24, r24
    16ee:	99 1f       	adc	r25, r25
    16f0:	88 0f       	add	r24, r24
    16f2:	99 1f       	adc	r25, r25
    16f4:	fc 01       	movw	r30, r24
    16f6:	e9 5c       	subi	r30, 0xC9	; 201
    16f8:	fe 4f       	sbci	r31, 0xFE	; 254
    16fa:	64 e6       	ldi	r22, 0x64	; 100
    16fc:	83 81       	ldd	r24, Z+3	; 0x03
    16fe:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    1702:	88 23       	and	r24, r24
    1704:	51 f0       	breq	.+20     	; 0x171a <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    170a:	81 ec       	ldi	r24, 0xC1	; 193
    170c:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    170e:	83 ec       	ldi	r24, 0xC3	; 195
    1710:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1712:	80 e0       	ldi	r24, 0x00	; 0
    1714:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    171a:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    171c:	08 95       	ret

0000171e <LED_Dim>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    171e:	81 11       	cpse	r24, r1
    1720:	21 c0       	rjmp	.+66     	; 0x1764 <LED_Dim+0x46>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	fc 01       	movw	r30, r24
    1726:	e6 55       	subi	r30, 0x56	; 86
    1728:	f8 4f       	sbci	r31, 0xF8	; 248
    172a:	20 81       	ld	r18, Z
    172c:	21 30       	cpi	r18, 0x01	; 1
    172e:	e1 f4       	brne	.+56     	; 0x1768 <LED_Dim+0x4a>
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1730:	fc 01       	movw	r30, r24
    1732:	ee 0f       	add	r30, r30
    1734:	ff 1f       	adc	r31, r31
    1736:	ee 0f       	add	r30, r30
    1738:	ff 1f       	adc	r31, r31
    173a:	e9 5c       	subi	r30, 0xC9	; 201
    173c:	fe 4f       	sbci	r31, 0xFE	; 254
    173e:	22 81       	ldd	r18, Z+2	; 0x02
    1740:	22 23       	and	r18, r18
    1742:	a1 f0       	breq	.+40     	; 0x176c <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
    1744:	65 36       	cpi	r22, 0x65	; 101
    1746:	a0 f4       	brcc	.+40     	; 0x1770 <LED_Dim+0x52>
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      /* set LED duty cycle */
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    1748:	88 0f       	add	r24, r24
    174a:	99 1f       	adc	r25, r25
    174c:	88 0f       	add	r24, r24
    174e:	99 1f       	adc	r25, r25
    1750:	fc 01       	movw	r30, r24
    1752:	e9 5c       	subi	r30, 0xC9	; 201
    1754:	fe 4f       	sbci	r31, 0xFE	; 254
    1756:	83 81       	ldd	r24, Z+3	; 0x03
    1758:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <PWM_SetDuty>
        
      /* make sure PWM function was successful */ 
      if(ERROR_OK != PWM_ErrorState)
    175c:	88 23       	and	r24, r24
    175e:	51 f0       	breq	.+20     	; 0x1774 <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    1760:	81 e0       	ldi	r24, 0x01	; 1
    1762:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1764:	81 ec       	ldi	r24, 0xC1	; 193
    1766:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1768:	83 ec       	ldi	r24, 0xC3	; 195
    176a:	08 95       	ret
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	08 95       	ret
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    1770:	81 e0       	ldi	r24, 0x01	; 1
    1772:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    1774:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1776:	08 95       	ret

00001778 <SevenSeg_ClearEnable>:
------------------------*/
/**
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
    1778:	cf 93       	push	r28
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    177a:	c0 e0       	ldi	r28, 0x00	; 0
    177c:	0e c0       	rjmp	.+28     	; 0x179a <SevenSeg_ClearEnable+0x22>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
    177e:	ec 2f       	mov	r30, r28
    1780:	f0 e0       	ldi	r31, 0x00	; 0
    1782:	ee 0f       	add	r30, r30
    1784:	ff 1f       	adc	r31, r31
    1786:	ee 0f       	add	r30, r30
    1788:	ff 1f       	adc	r31, r31
    178a:	e5 5c       	subi	r30, 0xC5	; 197
    178c:	fe 4f       	sbci	r31, 0xFE	; 254
    178e:	40 e0       	ldi	r20, 0x00	; 0
    1790:	61 81       	ldd	r22, Z+1	; 0x01
    1792:	80 81       	ld	r24, Z
    1794:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    1798:	cf 5f       	subi	r28, 0xFF	; 255
    179a:	c2 30       	cpi	r28, 0x02	; 2
    179c:	80 f3       	brcs	.-32     	; 0x177e <SevenSeg_ClearEnable+0x6>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
   }
}
    179e:	cf 91       	pop	r28
    17a0:	08 95       	ret

000017a2 <SevenSeg_Init>:
* @param [in]  Channel   -  Channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t SevenSeg_Init(const uint8_t Channel)
{
    17a2:	1f 93       	push	r17
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    17a8:	82 30       	cpi	r24, 0x02	; 2
    17aa:	60 f5       	brcc	.+88     	; 0x1804 <SevenSeg_Init+0x62>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT == gu8_IsInit[Channel])
    17ac:	c8 2f       	mov	r28, r24
    17ae:	d0 e0       	ldi	r29, 0x00	; 0
    17b0:	fe 01       	movw	r30, r28
    17b2:	e5 55       	subi	r30, 0x55	; 85
    17b4:	f8 4f       	sbci	r31, 0xF8	; 248
    17b6:	80 81       	ld	r24, Z
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	31 f1       	breq	.+76     	; 0x1808 <SevenSeg_Init+0x66>
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
   }
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
    17bc:	fe 01       	movw	r30, r28
    17be:	ee 0f       	add	r30, r30
    17c0:	ff 1f       	adc	r31, r31
    17c2:	ee 0f       	add	r30, r30
    17c4:	ff 1f       	adc	r31, r31
    17c6:	e5 5c       	subi	r30, 0xC5	; 197
    17c8:	fe 4f       	sbci	r31, 0xFE	; 254
    17ca:	41 e0       	ldi	r20, 0x01	; 1
    17cc:	61 81       	ldd	r22, Z+1	; 0x01
    17ce:	80 81       	ld	r24, Z
    17d0:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    17d4:	10 e0       	ldi	r17, 0x00	; 0
    17d6:	0e c0       	rjmp	.+28     	; 0x17f4 <SevenSeg_Init+0x52>
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
            aSTR_SevenSegConfig[Channel].u8_DataPort, 
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
    17d8:	fe 01       	movw	r30, r28
    17da:	ee 0f       	add	r30, r30
    17dc:	ff 1f       	adc	r31, r31
    17de:	ee 0f       	add	r30, r30
    17e0:	ff 1f       	adc	r31, r31
    17e2:	e5 5c       	subi	r30, 0xC5	; 197
    17e4:	fe 4f       	sbci	r31, 0xFE	; 254
    17e6:	63 81       	ldd	r22, Z+3	; 0x03
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
    17e8:	61 0f       	add	r22, r17
    17ea:	41 e0       	ldi	r20, 0x01	; 1
    17ec:	82 81       	ldd	r24, Z+2	; 0x02
    17ee:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    17f2:	1f 5f       	subi	r17, 0xFF	; 255
    17f4:	14 30       	cpi	r17, 0x04	; 4
    17f6:	80 f3       	brcs	.-32     	; 0x17d8 <SevenSeg_Init+0x36>
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
            PIN_OUTPUT
         );
      }    
      /* Set channel to initialized. */    
      gu8_IsInit[Channel] = INIT;
    17f8:	c5 55       	subi	r28, 0x55	; 85
    17fa:	d8 4f       	sbci	r29, 0xF8	; 248
    17fc:	81 e0       	ldi	r24, 0x01	; 1
    17fe:	88 83       	st	Y, r24
      SevenSeg_ErrorState = ERROR_OK;
    1800:	80 e0       	ldi	r24, 0x00	; 0
    1802:	03 c0       	rjmp	.+6      	; 0x180a <SevenSeg_Init+0x68>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    1804:	81 ea       	ldi	r24, 0xA1	; 161
    1806:	01 c0       	rjmp	.+2      	; 0x180a <SevenSeg_Init+0x68>
   }
   else if(INIT == gu8_IsInit[Channel])
   {
      /* Set initialized before error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
    1808:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
}
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	1f 91       	pop	r17
    1810:	08 95       	ret

00001812 <SevenSeg_Display>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t SevenSeg_Display(const uint8_t Channel, const uint8_t Number)
{
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    181a:	82 30       	cpi	r24, 0x02	; 2
    181c:	a0 f5       	brcc	.+104    	; 0x1886 <SevenSeg_Display+0x74>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT != gu8_IsInit[Channel])
    181e:	c8 2f       	mov	r28, r24
    1820:	d0 e0       	ldi	r29, 0x00	; 0
    1822:	fe 01       	movw	r30, r28
    1824:	e5 55       	subi	r30, 0x55	; 85
    1826:	f8 4f       	sbci	r31, 0xF8	; 248
    1828:	80 81       	ld	r24, Z
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	71 f5       	brne	.+92     	; 0x188a <SevenSeg_Display+0x78>
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
   }
   else if(MAX_DISPLAY_NUMBER < Number)
    182e:	6a 30       	cpi	r22, 0x0A	; 10
    1830:	70 f5       	brcc	.+92     	; 0x188e <SevenSeg_Display+0x7c>
    1832:	16 2f       	mov	r17, r22
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
   }
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
    1834:	0e 94 bc 0b 	call	0x1778	; 0x1778 <SevenSeg_ClearEnable>
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1838:	00 e0       	ldi	r16, 0x00	; 0
    183a:	16 c0       	rjmp	.+44     	; 0x1868 <SevenSeg_Display+0x56>
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
    183c:	41 2f       	mov	r20, r17
    183e:	50 e0       	ldi	r21, 0x00	; 0
    1840:	00 2e       	mov	r0, r16
    1842:	02 c0       	rjmp	.+4      	; 0x1848 <SevenSeg_Display+0x36>
    1844:	55 95       	asr	r21
    1846:	47 95       	ror	r20
    1848:	0a 94       	dec	r0
    184a:	e2 f7       	brpl	.-8      	; 0x1844 <SevenSeg_Display+0x32>
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
    184c:	fe 01       	movw	r30, r28
    184e:	ee 0f       	add	r30, r30
    1850:	ff 1f       	adc	r31, r31
    1852:	ee 0f       	add	r30, r30
    1854:	ff 1f       	adc	r31, r31
    1856:	e5 5c       	subi	r30, 0xC5	; 197
    1858:	fe 4f       	sbci	r31, 0xFE	; 254
    185a:	63 81       	ldd	r22, Z+3	; 0x03
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
    185c:	41 70       	andi	r20, 0x01	; 1
    185e:	60 0f       	add	r22, r16
    1860:	82 81       	ldd	r24, Z+2	; 0x02
    1862:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1866:	0f 5f       	subi	r16, 0xFF	; 255
    1868:	04 30       	cpi	r16, 0x04	; 4
    186a:	40 f3       	brcs	.-48     	; 0x183c <SevenSeg_Display+0x2a>
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
         );
      }
      /* Set enable pin to high. */
      DIO_WritePin(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_HIGH);
    186c:	cc 0f       	add	r28, r28
    186e:	dd 1f       	adc	r29, r29
    1870:	cc 0f       	add	r28, r28
    1872:	dd 1f       	adc	r29, r29
    1874:	c5 5c       	subi	r28, 0xC5	; 197
    1876:	de 4f       	sbci	r29, 0xFE	; 254
    1878:	41 e0       	ldi	r20, 0x01	; 1
    187a:	69 81       	ldd	r22, Y+1	; 0x01
    187c:	88 81       	ld	r24, Y
    187e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <DIO_WritePin>
      SevenSeg_ErrorState = ERROR_OK;
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	05 c0       	rjmp	.+10     	; 0x1890 <SevenSeg_Display+0x7e>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    1886:	81 ea       	ldi	r24, 0xA1	; 161
    1888:	03 c0       	rjmp	.+6      	; 0x1890 <SevenSeg_Display+0x7e>
   }
   else if(INIT != gu8_IsInit[Channel])
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
    188a:	82 ea       	ldi	r24, 0xA2	; 162
    188c:	01 c0       	rjmp	.+2      	; 0x1890 <SevenSeg_Display+0x7e>
   }
   else if(MAX_DISPLAY_NUMBER < Number)
   {
      /* Set invalid number error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
    188e:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
    1890:	df 91       	pop	r29
    1892:	cf 91       	pop	r28
    1894:	1f 91       	pop	r17
    1896:	0f 91       	pop	r16
    1898:	08 95       	ret

0000189a <STR_StringReverse>:
	}
	STR_StringReverse(SringCpy);
	return 0;
}
uint8_t STR_StringReverse(uint8_t* String)
{
    189a:	dc 01       	movw	r26, r24
	uint8_t* A = String;
	uint8_t* B = String;
    189c:	fc 01       	movw	r30, r24
	uint8_t Temp = 0;
	while(*B != '\0')
    189e:	01 c0       	rjmp	.+2      	; 0x18a2 <STR_StringReverse+0x8>
	{
		B++;
    18a0:	31 96       	adiw	r30, 0x01	; 1
uint8_t STR_StringReverse(uint8_t* String)
{
	uint8_t* A = String;
	uint8_t* B = String;
	uint8_t Temp = 0;
	while(*B != '\0')
    18a2:	80 81       	ld	r24, Z
    18a4:	81 11       	cpse	r24, r1
    18a6:	fc cf       	rjmp	.-8      	; 0x18a0 <STR_StringReverse+0x6>
	{
		B++;
	}
	B--;
    18a8:	31 97       	sbiw	r30, 0x01	; 1
	while(A<B)
    18aa:	05 c0       	rjmp	.+10     	; 0x18b6 <STR_StringReverse+0x1c>
	{
		//swap
		Temp=*A;
    18ac:	8c 91       	ld	r24, X
		*A=*B;
    18ae:	90 81       	ld	r25, Z
    18b0:	9d 93       	st	X+, r25
		*B=Temp;
    18b2:	80 83       	st	Z, r24
		A++;B--;
    18b4:	31 97       	sbiw	r30, 0x01	; 1
	while(*B != '\0')
	{
		B++;
	}
	B--;
	while(A<B)
    18b6:	ae 17       	cp	r26, r30
    18b8:	bf 07       	cpc	r27, r31
    18ba:	c0 f3       	brcs	.-16     	; 0x18ac <STR_StringReverse+0x12>
		*A=*B;
		*B=Temp;
		A++;B--;
	}
	return 0;
}
    18bc:	80 e0       	ldi	r24, 0x00	; 0
    18be:	08 95       	ret

000018c0 <STR_Number2String>:
		Multiplier*=10;
	}while(String!=StartOfString);
	return 0;
}
uint8_t STR_Number2String(uint32_t Number, uint8_t* String)
{
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	8a 01       	movw	r16, r20
	uint8_t* SringCpy = String;
	if(Number==0)
    18ca:	61 15       	cp	r22, r1
    18cc:	71 05       	cpc	r23, r1
    18ce:	81 05       	cpc	r24, r1
    18d0:	91 05       	cpc	r25, r1
    18d2:	29 f4       	brne	.+10     	; 0x18de <STR_Number2String+0x1e>
	{
		*String='0';
    18d4:	80 e3       	ldi	r24, 0x30	; 48
    18d6:	fa 01       	movw	r30, r20
    18d8:	80 83       	st	Z, r24
		*(String+1)='\0';
    18da:	11 82       	std	Z+1, r1	; 0x01
    18dc:	13 c0       	rjmp	.+38     	; 0x1904 <STR_Number2String+0x44>
    18de:	ea 01       	movw	r28, r20
	}
	else
	{
		do
		{
			*String = (Number%10)+48;
    18e0:	2a e0       	ldi	r18, 0x0A	; 10
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	40 e0       	ldi	r20, 0x00	; 0
    18e6:	50 e0       	ldi	r21, 0x00	; 0
    18e8:	0e 94 95 18 	call	0x312a	; 0x312a <__udivmodsi4>
    18ec:	60 5d       	subi	r22, 0xD0	; 208
    18ee:	69 93       	st	Y+, r22
			String++;
			Number/=10;
    18f0:	62 2f       	mov	r22, r18
    18f2:	73 2f       	mov	r23, r19
    18f4:	84 2f       	mov	r24, r20
    18f6:	95 2f       	mov	r25, r21
		}while(Number);
    18f8:	61 15       	cp	r22, r1
    18fa:	71 05       	cpc	r23, r1
    18fc:	81 05       	cpc	r24, r1
    18fe:	91 05       	cpc	r25, r1
    1900:	79 f7       	brne	.-34     	; 0x18e0 <STR_Number2String+0x20>
		*String = NULL_TERMINATOR;
    1902:	18 82       	st	Y, r1
	}
	STR_StringReverse(SringCpy);
    1904:	c8 01       	movw	r24, r16
    1906:	0e 94 4d 0c 	call	0x189a	; 0x189a <STR_StringReverse>
	return 0;
}
    190a:	80 e0       	ldi	r24, 0x00	; 0
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	0f 91       	pop	r16
    1914:	08 95       	ret

00001916 <DIO_SetPinDirection>:
#include "DIO.h"

ERROR_STATE_t DIO_SetPinDirection(uint8_t PortName , uint8_t PinNo ,uint8_t PinDirection)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_INPUT!=PinDirection)&&(PIN_OUTPUT!=PinDirection))
    1916:	42 30       	cpi	r20, 0x02	; 2
    1918:	08 f0       	brcs	.+2      	; 0x191c <DIO_SetPinDirection+0x6>
    191a:	60 c0       	rjmp	.+192    	; 0x19dc <DIO_SetPinDirection+0xc6>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(PinNo>PIN7)
    191c:	68 30       	cpi	r22, 0x08	; 8
    191e:	08 f0       	brcs	.+2      	; 0x1922 <DIO_SetPinDirection+0xc>
    1920:	5f c0       	rjmp	.+190    	; 0x19e0 <DIO_SetPinDirection+0xca>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    1922:	81 30       	cpi	r24, 0x01	; 1
    1924:	e1 f0       	breq	.+56     	; 0x195e <DIO_SetPinDirection+0x48>
    1926:	30 f0       	brcs	.+12     	; 0x1934 <DIO_SetPinDirection+0x1e>
    1928:	82 30       	cpi	r24, 0x02	; 2
    192a:	71 f1       	breq	.+92     	; 0x1988 <DIO_SetPinDirection+0x72>
    192c:	83 30       	cpi	r24, 0x03	; 3
    192e:	09 f4       	brne	.+2      	; 0x1932 <DIO_SetPinDirection+0x1c>
    1930:	40 c0       	rjmp	.+128    	; 0x19b2 <DIO_SetPinDirection+0x9c>
    1932:	58 c0       	rjmp	.+176    	; 0x19e4 <DIO_SetPinDirection+0xce>
		{
			case PORT_A:
				BIT_WRITE(DDRA,PinNo,PinDirection);
    1934:	2a b3       	in	r18, 0x1a	; 26
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	06 2e       	mov	r0, r22
    193c:	02 c0       	rjmp	.+4      	; 0x1942 <DIO_SetPinDirection+0x2c>
    193e:	88 0f       	add	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	0a 94       	dec	r0
    1944:	e2 f7       	brpl	.-8      	; 0x193e <DIO_SetPinDirection+0x28>
    1946:	50 e0       	ldi	r21, 0x00	; 0
    1948:	02 c0       	rjmp	.+4      	; 0x194e <DIO_SetPinDirection+0x38>
    194a:	44 0f       	add	r20, r20
    194c:	55 1f       	adc	r21, r21
    194e:	6a 95       	dec	r22
    1950:	e2 f7       	brpl	.-8      	; 0x194a <DIO_SetPinDirection+0x34>
    1952:	80 95       	com	r24
    1954:	82 23       	and	r24, r18
    1956:	48 2b       	or	r20, r24
    1958:	4a bb       	out	0x1a, r20	; 26
				u8_ErrorState=ERROR_OK;
    195a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    195c:	08 95       	ret
			case PORT_B:
				BIT_WRITE(DDRB,PinNo,PinDirection);
    195e:	27 b3       	in	r18, 0x17	; 23
    1960:	81 e0       	ldi	r24, 0x01	; 1
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	06 2e       	mov	r0, r22
    1966:	02 c0       	rjmp	.+4      	; 0x196c <DIO_SetPinDirection+0x56>
    1968:	88 0f       	add	r24, r24
    196a:	99 1f       	adc	r25, r25
    196c:	0a 94       	dec	r0
    196e:	e2 f7       	brpl	.-8      	; 0x1968 <DIO_SetPinDirection+0x52>
    1970:	50 e0       	ldi	r21, 0x00	; 0
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <DIO_SetPinDirection+0x62>
    1974:	44 0f       	add	r20, r20
    1976:	55 1f       	adc	r21, r21
    1978:	6a 95       	dec	r22
    197a:	e2 f7       	brpl	.-8      	; 0x1974 <DIO_SetPinDirection+0x5e>
    197c:	80 95       	com	r24
    197e:	82 23       	and	r24, r18
    1980:	48 2b       	or	r20, r24
    1982:	47 bb       	out	0x17, r20	; 23
				u8_ErrorState=ERROR_OK;
    1984:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1986:	08 95       	ret
			case PORT_C:
				BIT_WRITE(DDRC,PinNo,PinDirection);
    1988:	24 b3       	in	r18, 0x14	; 20
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	06 2e       	mov	r0, r22
    1990:	02 c0       	rjmp	.+4      	; 0x1996 <DIO_SetPinDirection+0x80>
    1992:	88 0f       	add	r24, r24
    1994:	99 1f       	adc	r25, r25
    1996:	0a 94       	dec	r0
    1998:	e2 f7       	brpl	.-8      	; 0x1992 <DIO_SetPinDirection+0x7c>
    199a:	50 e0       	ldi	r21, 0x00	; 0
    199c:	02 c0       	rjmp	.+4      	; 0x19a2 <DIO_SetPinDirection+0x8c>
    199e:	44 0f       	add	r20, r20
    19a0:	55 1f       	adc	r21, r21
    19a2:	6a 95       	dec	r22
    19a4:	e2 f7       	brpl	.-8      	; 0x199e <DIO_SetPinDirection+0x88>
    19a6:	80 95       	com	r24
    19a8:	82 23       	and	r24, r18
    19aa:	48 2b       	or	r20, r24
    19ac:	44 bb       	out	0x14, r20	; 20
				u8_ErrorState=ERROR_OK;
    19ae:	80 e0       	ldi	r24, 0x00	; 0
				break;
    19b0:	08 95       	ret
			case PORT_D:
				BIT_WRITE(DDRD,PinNo,PinDirection);
    19b2:	21 b3       	in	r18, 0x11	; 17
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	06 2e       	mov	r0, r22
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <DIO_SetPinDirection+0xaa>
    19bc:	88 0f       	add	r24, r24
    19be:	99 1f       	adc	r25, r25
    19c0:	0a 94       	dec	r0
    19c2:	e2 f7       	brpl	.-8      	; 0x19bc <DIO_SetPinDirection+0xa6>
    19c4:	50 e0       	ldi	r21, 0x00	; 0
    19c6:	02 c0       	rjmp	.+4      	; 0x19cc <DIO_SetPinDirection+0xb6>
    19c8:	44 0f       	add	r20, r20
    19ca:	55 1f       	adc	r21, r21
    19cc:	6a 95       	dec	r22
    19ce:	e2 f7       	brpl	.-8      	; 0x19c8 <DIO_SetPinDirection+0xb2>
    19d0:	80 95       	com	r24
    19d2:	82 23       	and	r24, r18
    19d4:	48 2b       	or	r20, r24
    19d6:	41 bb       	out	0x11, r20	; 17
				u8_ErrorState=ERROR_OK;
    19d8:	80 e0       	ldi	r24, 0x00	; 0
				break;
    19da:	08 95       	ret
ERROR_STATE_t DIO_SetPinDirection(uint8_t PortName , uint8_t PinNo ,uint8_t PinDirection)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_INPUT!=PinDirection)&&(PIN_OUTPUT!=PinDirection))
	{
		u8_ErrorState=ERROR_NOK;
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	08 95       	ret
	}
	else if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	08 95       	ret
			case PORT_D:
				BIT_WRITE(DDRD,PinNo,PinDirection);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    19e4:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}		
	}
	return u8_ErrorState;
}
    19e6:	08 95       	ret

000019e8 <DIO_WritePin>:

ERROR_STATE_t DIO_WritePin(uint8_t PortName , uint8_t PinNo ,uint8_t PinValue)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_LOW!=PinValue)&&(PIN_HIGH!=PinValue))
    19e8:	42 30       	cpi	r20, 0x02	; 2
    19ea:	08 f0       	brcs	.+2      	; 0x19ee <DIO_WritePin+0x6>
    19ec:	60 c0       	rjmp	.+192    	; 0x1aae <DIO_WritePin+0xc6>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(PinNo>PIN7)
    19ee:	68 30       	cpi	r22, 0x08	; 8
    19f0:	08 f0       	brcs	.+2      	; 0x19f4 <DIO_WritePin+0xc>
    19f2:	5f c0       	rjmp	.+190    	; 0x1ab2 <DIO_WritePin+0xca>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    19f4:	81 30       	cpi	r24, 0x01	; 1
    19f6:	e1 f0       	breq	.+56     	; 0x1a30 <DIO_WritePin+0x48>
    19f8:	30 f0       	brcs	.+12     	; 0x1a06 <DIO_WritePin+0x1e>
    19fa:	82 30       	cpi	r24, 0x02	; 2
    19fc:	71 f1       	breq	.+92     	; 0x1a5a <DIO_WritePin+0x72>
    19fe:	83 30       	cpi	r24, 0x03	; 3
    1a00:	09 f4       	brne	.+2      	; 0x1a04 <DIO_WritePin+0x1c>
    1a02:	40 c0       	rjmp	.+128    	; 0x1a84 <DIO_WritePin+0x9c>
    1a04:	58 c0       	rjmp	.+176    	; 0x1ab6 <DIO_WritePin+0xce>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PinValue);
    1a06:	2b b3       	in	r18, 0x1b	; 27
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	06 2e       	mov	r0, r22
    1a0e:	02 c0       	rjmp	.+4      	; 0x1a14 <DIO_WritePin+0x2c>
    1a10:	88 0f       	add	r24, r24
    1a12:	99 1f       	adc	r25, r25
    1a14:	0a 94       	dec	r0
    1a16:	e2 f7       	brpl	.-8      	; 0x1a10 <DIO_WritePin+0x28>
    1a18:	50 e0       	ldi	r21, 0x00	; 0
    1a1a:	02 c0       	rjmp	.+4      	; 0x1a20 <DIO_WritePin+0x38>
    1a1c:	44 0f       	add	r20, r20
    1a1e:	55 1f       	adc	r21, r21
    1a20:	6a 95       	dec	r22
    1a22:	e2 f7       	brpl	.-8      	; 0x1a1c <DIO_WritePin+0x34>
    1a24:	80 95       	com	r24
    1a26:	82 23       	and	r24, r18
    1a28:	48 2b       	or	r20, r24
    1a2a:	4b bb       	out	0x1b, r20	; 27
				u8_ErrorState=ERROR_OK;
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1a2e:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PinValue);
    1a30:	28 b3       	in	r18, 0x18	; 24
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	06 2e       	mov	r0, r22
    1a38:	02 c0       	rjmp	.+4      	; 0x1a3e <DIO_WritePin+0x56>
    1a3a:	88 0f       	add	r24, r24
    1a3c:	99 1f       	adc	r25, r25
    1a3e:	0a 94       	dec	r0
    1a40:	e2 f7       	brpl	.-8      	; 0x1a3a <DIO_WritePin+0x52>
    1a42:	50 e0       	ldi	r21, 0x00	; 0
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <DIO_WritePin+0x62>
    1a46:	44 0f       	add	r20, r20
    1a48:	55 1f       	adc	r21, r21
    1a4a:	6a 95       	dec	r22
    1a4c:	e2 f7       	brpl	.-8      	; 0x1a46 <DIO_WritePin+0x5e>
    1a4e:	80 95       	com	r24
    1a50:	82 23       	and	r24, r18
    1a52:	48 2b       	or	r20, r24
    1a54:	48 bb       	out	0x18, r20	; 24
				u8_ErrorState=ERROR_OK;
    1a56:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1a58:	08 95       	ret
			case PORT_C:
				BIT_WRITE(PORTC,PinNo,PinValue);
    1a5a:	25 b3       	in	r18, 0x15	; 21
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	06 2e       	mov	r0, r22
    1a62:	02 c0       	rjmp	.+4      	; 0x1a68 <DIO_WritePin+0x80>
    1a64:	88 0f       	add	r24, r24
    1a66:	99 1f       	adc	r25, r25
    1a68:	0a 94       	dec	r0
    1a6a:	e2 f7       	brpl	.-8      	; 0x1a64 <DIO_WritePin+0x7c>
    1a6c:	50 e0       	ldi	r21, 0x00	; 0
    1a6e:	02 c0       	rjmp	.+4      	; 0x1a74 <DIO_WritePin+0x8c>
    1a70:	44 0f       	add	r20, r20
    1a72:	55 1f       	adc	r21, r21
    1a74:	6a 95       	dec	r22
    1a76:	e2 f7       	brpl	.-8      	; 0x1a70 <DIO_WritePin+0x88>
    1a78:	80 95       	com	r24
    1a7a:	82 23       	and	r24, r18
    1a7c:	48 2b       	or	r20, r24
    1a7e:	45 bb       	out	0x15, r20	; 21
				u8_ErrorState=ERROR_OK;
    1a80:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1a82:	08 95       	ret
			case PORT_D:
				BIT_WRITE(PORTD,PinNo,PinValue);
    1a84:	22 b3       	in	r18, 0x12	; 18
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	06 2e       	mov	r0, r22
    1a8c:	02 c0       	rjmp	.+4      	; 0x1a92 <DIO_WritePin+0xaa>
    1a8e:	88 0f       	add	r24, r24
    1a90:	99 1f       	adc	r25, r25
    1a92:	0a 94       	dec	r0
    1a94:	e2 f7       	brpl	.-8      	; 0x1a8e <DIO_WritePin+0xa6>
    1a96:	50 e0       	ldi	r21, 0x00	; 0
    1a98:	02 c0       	rjmp	.+4      	; 0x1a9e <DIO_WritePin+0xb6>
    1a9a:	44 0f       	add	r20, r20
    1a9c:	55 1f       	adc	r21, r21
    1a9e:	6a 95       	dec	r22
    1aa0:	e2 f7       	brpl	.-8      	; 0x1a9a <DIO_WritePin+0xb2>
    1aa2:	80 95       	com	r24
    1aa4:	82 23       	and	r24, r18
    1aa6:	48 2b       	or	r20, r24
    1aa8:	42 bb       	out	0x12, r20	; 18
				u8_ErrorState=ERROR_OK;
    1aaa:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1aac:	08 95       	ret
ERROR_STATE_t DIO_WritePin(uint8_t PortName , uint8_t PinNo ,uint8_t PinValue)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_LOW!=PinValue)&&(PIN_HIGH!=PinValue))
	{
		u8_ErrorState=ERROR_NOK;
    1aae:	81 e0       	ldi	r24, 0x01	; 1
    1ab0:	08 95       	ret
	}
	else if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	08 95       	ret
			case PORT_D:
				BIT_WRITE(PORTD,PinNo,PinValue);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    1ab8:	08 95       	ret

00001aba <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    1aba:	83 30       	cpi	r24, 0x03	; 3
    1abc:	69 f5       	brne	.+90     	; 0x1b18 <PWM_Init+0x5e>
    1abe:	85 b5       	in	r24, 0x25	; 37
    1ac0:	eb e6       	ldi	r30, 0x6B	; 107
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	92 85       	ldd	r25, Z+10	; 0x0a
    1ac6:	49 2f       	mov	r20, r25
    1ac8:	41 70       	andi	r20, 0x01	; 1
    1aca:	50 e0       	ldi	r21, 0x00	; 0
    1acc:	00 24       	eor	r0, r0
    1ace:	56 95       	lsr	r21
    1ad0:	47 95       	ror	r20
    1ad2:	07 94       	ror	r0
    1ad4:	56 95       	lsr	r21
    1ad6:	47 95       	ror	r20
    1ad8:	07 94       	ror	r0
    1ada:	54 2f       	mov	r21, r20
    1adc:	40 2d       	mov	r20, r0
    1ade:	8f 7b       	andi	r24, 0xBF	; 191
    1ae0:	48 2b       	or	r20, r24
    1ae2:	91 fb       	bst	r25, 1
    1ae4:	22 27       	eor	r18, r18
    1ae6:	20 f9       	bld	r18, 0
    1ae8:	30 e0       	ldi	r19, 0x00	; 0
    1aea:	22 0f       	add	r18, r18
    1aec:	33 1f       	adc	r19, r19
    1aee:	22 0f       	add	r18, r18
    1af0:	33 1f       	adc	r19, r19
    1af2:	22 0f       	add	r18, r18
    1af4:	33 1f       	adc	r19, r19
    1af6:	47 7f       	andi	r20, 0xF7	; 247
    1af8:	24 2b       	or	r18, r20
    1afa:	83 85       	ldd	r24, Z+11	; 0x0b
    1afc:	30 e1       	ldi	r19, 0x10	; 16
    1afe:	83 9f       	mul	r24, r19
    1b00:	c0 01       	movw	r24, r0
    1b02:	11 24       	eor	r1, r1
    1b04:	2f 7c       	andi	r18, 0xCF	; 207
    1b06:	28 2b       	or	r18, r24
    1b08:	25 bd       	out	0x25, r18	; 37
    1b0a:	41 e0       	ldi	r20, 0x01	; 1
    1b0c:	67 e0       	ldi	r22, 0x07	; 7
    1b0e:	83 e0       	ldi	r24, 0x03	; 3
    1b10:	0e 94 8b 0c 	call	0x1916	; 0x1916 <DIO_SetPinDirection>
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	08 95       	ret
    1b18:	81 e0       	ldi	r24, 0x01	; 1
    1b1a:	08 95       	ret

00001b1c <PWM_Start>:
    1b1c:	83 30       	cpi	r24, 0x03	; 3
    1b1e:	41 f4       	brne	.+16     	; 0x1b30 <PWM_Start+0x14>
    1b20:	85 b5       	in	r24, 0x25	; 37
    1b22:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <gastr_PWMConfig+0x9>
    1b26:	88 7f       	andi	r24, 0xF8	; 248
    1b28:	89 2b       	or	r24, r25
    1b2a:	85 bd       	out	0x25, r24	; 37
    1b2c:	80 e0       	ldi	r24, 0x00	; 0
    1b2e:	08 95       	ret
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	08 95       	ret

00001b34 <PWM_Connect>:
    1b34:	83 30       	cpi	r24, 0x03	; 3
    1b36:	69 f4       	brne	.+26     	; 0x1b52 <PWM_Connect+0x1e>
    1b38:	25 b5       	in	r18, 0x25	; 37
    1b3a:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <gastr_PWMConfig+0xb>
    1b3e:	30 e1       	ldi	r19, 0x10	; 16
    1b40:	93 9f       	mul	r25, r19
    1b42:	c0 01       	movw	r24, r0
    1b44:	11 24       	eor	r1, r1
    1b46:	92 2f       	mov	r25, r18
    1b48:	9f 7c       	andi	r25, 0xCF	; 207
    1b4a:	89 2b       	or	r24, r25
    1b4c:	85 bd       	out	0x25, r24	; 37
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
    1b50:	08 95       	ret
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	08 95       	ret

00001b56 <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    1b56:	9f ef       	ldi	r25, 0xFF	; 255
    1b58:	96 0f       	add	r25, r22
    1b5a:	94 36       	cpi	r25, 0x64	; 100
    1b5c:	10 f5       	brcc	.+68     	; 0x1ba2 <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    1b5e:	83 30       	cpi	r24, 0x03	; 3
    1b60:	11 f5       	brne	.+68     	; 0x1ba6 <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    1b62:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <gastr_PWMConfig+0xb>
    1b66:	82 30       	cpi	r24, 0x02	; 2
    1b68:	01 f5       	brne	.+64     	; 0x1baa <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    1b6a:	70 e0       	ldi	r23, 0x00	; 0
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <__floatsisf>
    1b74:	20 e0       	ldi	r18, 0x00	; 0
    1b76:	30 e0       	ldi	r19, 0x00	; 0
    1b78:	48 ec       	ldi	r20, 0xC8	; 200
    1b7a:	52 e4       	ldi	r21, 0x42	; 66
    1b7c:	0e 94 d5 16 	call	0x2daa	; 0x2daa <__divsf3>
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	40 e8       	ldi	r20, 0x80	; 128
    1b86:	53 e4       	ldi	r21, 0x43	; 67
    1b88:	0e 94 28 18 	call	0x3050	; 0x3050 <__mulsf3>
    1b8c:	20 e0       	ldi	r18, 0x00	; 0
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	40 e8       	ldi	r20, 0x80	; 128
    1b92:	5f e3       	ldi	r21, 0x3F	; 63
    1b94:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <__subsf3>
    1b98:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <__fixunssfsi>
    1b9c:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    1b9e:	80 e0       	ldi	r24, 0x00	; 0
							break;
    1ba0:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    1baa:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    1bac:	08 95       	ret

00001bae <GetFreqPrescaleRatio>:
   /* clear the timer clock */
   *ptr_TimerControl &= ~(CLK_BITS);
   
   /* return success message. */
   return ERROR_OK;
}
    1bae:	82 30       	cpi	r24, 0x02	; 2
    1bb0:	08 f0       	brcs	.+2      	; 0x1bb4 <GetFreqPrescaleRatio+0x6>
    1bb2:	4e c0       	rjmp	.+156    	; 0x1c50 <GetFreqPrescaleRatio+0xa2>
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	ee 0f       	add	r30, r30
    1bba:	ff 1f       	adc	r31, r31
    1bbc:	8e 0f       	add	r24, r30
    1bbe:	9f 1f       	adc	r25, r31
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	eb 59       	subi	r30, 0x9B	; 155
    1bc4:	fe 4f       	sbci	r31, 0xFE	; 254
    1bc6:	82 81       	ldd	r24, Z+2	; 0x02
    1bc8:	83 30       	cpi	r24, 0x03	; 3
    1bca:	09 f1       	breq	.+66     	; 0x1c0e <GetFreqPrescaleRatio+0x60>
    1bcc:	28 f4       	brcc	.+10     	; 0x1bd8 <GetFreqPrescaleRatio+0x2a>
    1bce:	81 30       	cpi	r24, 0x01	; 1
    1bd0:	41 f0       	breq	.+16     	; 0x1be2 <GetFreqPrescaleRatio+0x34>
    1bd2:	82 30       	cpi	r24, 0x02	; 2
    1bd4:	89 f0       	breq	.+34     	; 0x1bf8 <GetFreqPrescaleRatio+0x4a>
    1bd6:	a2 c0       	rjmp	.+324    	; 0x1d1c <GetFreqPrescaleRatio+0x16e>
    1bd8:	84 30       	cpi	r24, 0x04	; 4
    1bda:	21 f1       	breq	.+72     	; 0x1c24 <GetFreqPrescaleRatio+0x76>
    1bdc:	85 30       	cpi	r24, 0x05	; 5
    1bde:	69 f1       	breq	.+90     	; 0x1c3a <GetFreqPrescaleRatio+0x8c>
    1be0:	9d c0       	rjmp	.+314    	; 0x1d1c <GetFreqPrescaleRatio+0x16e>
    1be2:	80 e0       	ldi	r24, 0x00	; 0
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	a0 e8       	ldi	r26, 0x80	; 128
    1be8:	bd e3       	ldi	r27, 0x3D	; 61
    1bea:	fb 01       	movw	r30, r22
    1bec:	80 83       	st	Z, r24
    1bee:	91 83       	std	Z+1, r25	; 0x01
    1bf0:	a2 83       	std	Z+2, r26	; 0x02
    1bf2:	b3 83       	std	Z+3, r27	; 0x03
    1bf4:	80 e0       	ldi	r24, 0x00	; 0
    1bf6:	08 95       	ret
    1bf8:	80 e0       	ldi	r24, 0x00	; 0
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	a0 e0       	ldi	r26, 0x00	; 0
    1bfe:	bf e3       	ldi	r27, 0x3F	; 63
    1c00:	fb 01       	movw	r30, r22
    1c02:	80 83       	st	Z, r24
    1c04:	91 83       	std	Z+1, r25	; 0x01
    1c06:	a2 83       	std	Z+2, r26	; 0x02
    1c08:	b3 83       	std	Z+3, r27	; 0x03
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	08 95       	ret
    1c0e:	80 e0       	ldi	r24, 0x00	; 0
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	a0 e8       	ldi	r26, 0x80	; 128
    1c14:	b0 e4       	ldi	r27, 0x40	; 64
    1c16:	fb 01       	movw	r30, r22
    1c18:	80 83       	st	Z, r24
    1c1a:	91 83       	std	Z+1, r25	; 0x01
    1c1c:	a2 83       	std	Z+2, r26	; 0x02
    1c1e:	b3 83       	std	Z+3, r27	; 0x03
    1c20:	80 e0       	ldi	r24, 0x00	; 0
    1c22:	08 95       	ret
    1c24:	80 e0       	ldi	r24, 0x00	; 0
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	a0 e8       	ldi	r26, 0x80	; 128
    1c2a:	b1 e4       	ldi	r27, 0x41	; 65
    1c2c:	fb 01       	movw	r30, r22
    1c2e:	80 83       	st	Z, r24
    1c30:	91 83       	std	Z+1, r25	; 0x01
    1c32:	a2 83       	std	Z+2, r26	; 0x02
    1c34:	b3 83       	std	Z+3, r27	; 0x03
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	08 95       	ret
    1c3a:	80 e0       	ldi	r24, 0x00	; 0
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	a0 e8       	ldi	r26, 0x80	; 128
    1c40:	b2 e4       	ldi	r27, 0x42	; 66
    1c42:	fb 01       	movw	r30, r22
    1c44:	80 83       	st	Z, r24
    1c46:	91 83       	std	Z+1, r25	; 0x01
    1c48:	a2 83       	std	Z+2, r26	; 0x02
    1c4a:	b3 83       	std	Z+3, r27	; 0x03
    1c4c:	80 e0       	ldi	r24, 0x00	; 0
    1c4e:	08 95       	ret
    1c50:	82 30       	cpi	r24, 0x02	; 2
    1c52:	09 f0       	breq	.+2      	; 0x1c56 <GetFreqPrescaleRatio+0xa8>
    1c54:	65 c0       	rjmp	.+202    	; 0x1d20 <GetFreqPrescaleRatio+0x172>
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	fc 01       	movw	r30, r24
    1c5a:	ee 0f       	add	r30, r30
    1c5c:	ff 1f       	adc	r31, r31
    1c5e:	8e 0f       	add	r24, r30
    1c60:	9f 1f       	adc	r25, r31
    1c62:	fc 01       	movw	r30, r24
    1c64:	eb 59       	subi	r30, 0x9B	; 155
    1c66:	fe 4f       	sbci	r31, 0xFE	; 254
    1c68:	e2 81       	ldd	r30, Z+2	; 0x02
    1c6a:	8e 2f       	mov	r24, r30
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	fc 01       	movw	r30, r24
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	e7 30       	cpi	r30, 0x07	; 7
    1c74:	f1 05       	cpc	r31, r1
    1c76:	08 f0       	brcs	.+2      	; 0x1c7a <GetFreqPrescaleRatio+0xcc>
    1c78:	55 c0       	rjmp	.+170    	; 0x1d24 <GetFreqPrescaleRatio+0x176>
    1c7a:	e6 5d       	subi	r30, 0xD6	; 214
    1c7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c7e:	0c 94 b7 18 	jmp	0x316e	; 0x316e <__tablejump2__>
    1c82:	80 e0       	ldi	r24, 0x00	; 0
    1c84:	90 e0       	ldi	r25, 0x00	; 0
    1c86:	a0 e8       	ldi	r26, 0x80	; 128
    1c88:	bd e3       	ldi	r27, 0x3D	; 61
    1c8a:	fb 01       	movw	r30, r22
    1c8c:	80 83       	st	Z, r24
    1c8e:	91 83       	std	Z+1, r25	; 0x01
    1c90:	a2 83       	std	Z+2, r26	; 0x02
    1c92:	b3 83       	std	Z+3, r27	; 0x03
    1c94:	80 e0       	ldi	r24, 0x00	; 0
    1c96:	08 95       	ret
    1c98:	80 e0       	ldi	r24, 0x00	; 0
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	a0 e0       	ldi	r26, 0x00	; 0
    1c9e:	bf e3       	ldi	r27, 0x3F	; 63
    1ca0:	fb 01       	movw	r30, r22
    1ca2:	80 83       	st	Z, r24
    1ca4:	91 83       	std	Z+1, r25	; 0x01
    1ca6:	a2 83       	std	Z+2, r26	; 0x02
    1ca8:	b3 83       	std	Z+3, r27	; 0x03
    1caa:	80 e0       	ldi	r24, 0x00	; 0
    1cac:	08 95       	ret
    1cae:	80 e0       	ldi	r24, 0x00	; 0
    1cb0:	90 e0       	ldi	r25, 0x00	; 0
    1cb2:	a0 e0       	ldi	r26, 0x00	; 0
    1cb4:	b0 e4       	ldi	r27, 0x40	; 64
    1cb6:	fb 01       	movw	r30, r22
    1cb8:	80 83       	st	Z, r24
    1cba:	91 83       	std	Z+1, r25	; 0x01
    1cbc:	a2 83       	std	Z+2, r26	; 0x02
    1cbe:	b3 83       	std	Z+3, r27	; 0x03
    1cc0:	80 e0       	ldi	r24, 0x00	; 0
    1cc2:	08 95       	ret
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	a0 e8       	ldi	r26, 0x80	; 128
    1cca:	b0 e4       	ldi	r27, 0x40	; 64
    1ccc:	fb 01       	movw	r30, r22
    1cce:	80 83       	st	Z, r24
    1cd0:	91 83       	std	Z+1, r25	; 0x01
    1cd2:	a2 83       	std	Z+2, r26	; 0x02
    1cd4:	b3 83       	std	Z+3, r27	; 0x03
    1cd6:	80 e0       	ldi	r24, 0x00	; 0
    1cd8:	08 95       	ret
    1cda:	80 e0       	ldi	r24, 0x00	; 0
    1cdc:	90 e0       	ldi	r25, 0x00	; 0
    1cde:	a0 e0       	ldi	r26, 0x00	; 0
    1ce0:	b1 e4       	ldi	r27, 0x41	; 65
    1ce2:	fb 01       	movw	r30, r22
    1ce4:	80 83       	st	Z, r24
    1ce6:	91 83       	std	Z+1, r25	; 0x01
    1ce8:	a2 83       	std	Z+2, r26	; 0x02
    1cea:	b3 83       	std	Z+3, r27	; 0x03
    1cec:	80 e0       	ldi	r24, 0x00	; 0
    1cee:	08 95       	ret
    1cf0:	80 e0       	ldi	r24, 0x00	; 0
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	a0 e8       	ldi	r26, 0x80	; 128
    1cf6:	b1 e4       	ldi	r27, 0x41	; 65
    1cf8:	fb 01       	movw	r30, r22
    1cfa:	80 83       	st	Z, r24
    1cfc:	91 83       	std	Z+1, r25	; 0x01
    1cfe:	a2 83       	std	Z+2, r26	; 0x02
    1d00:	b3 83       	std	Z+3, r27	; 0x03
    1d02:	80 e0       	ldi	r24, 0x00	; 0
    1d04:	08 95       	ret
    1d06:	80 e0       	ldi	r24, 0x00	; 0
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	a0 e8       	ldi	r26, 0x80	; 128
    1d0c:	b2 e4       	ldi	r27, 0x42	; 66
    1d0e:	fb 01       	movw	r30, r22
    1d10:	80 83       	st	Z, r24
    1d12:	91 83       	std	Z+1, r25	; 0x01
    1d14:	a2 83       	std	Z+2, r26	; 0x02
    1d16:	b3 83       	std	Z+3, r27	; 0x03
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	08 95       	ret
    1d1c:	8c ef       	ldi	r24, 0xFC	; 252
    1d1e:	08 95       	ret
    1d20:	80 e0       	ldi	r24, 0x00	; 0
    1d22:	08 95       	ret
    1d24:	8c ef       	ldi	r24, 0xFC	; 252
    1d26:	08 95       	ret

00001d28 <TIM_Init>:
    1d28:	81 30       	cpi	r24, 0x01	; 1
    1d2a:	b1 f0       	breq	.+44     	; 0x1d58 <TIM_Init+0x30>
    1d2c:	18 f0       	brcs	.+6      	; 0x1d34 <TIM_Init+0xc>
    1d2e:	82 30       	cpi	r24, 0x02	; 2
    1d30:	71 f1       	breq	.+92     	; 0x1d8e <TIM_Init+0x66>
    1d32:	44 c0       	rjmp	.+136    	; 0x1dbc <TIM_Init+0x94>
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	fc 01       	movw	r30, r24
    1d38:	ee 0f       	add	r30, r30
    1d3a:	ff 1f       	adc	r31, r31
    1d3c:	8e 0f       	add	r24, r30
    1d3e:	9f 1f       	adc	r25, r31
    1d40:	fc 01       	movw	r30, r24
    1d42:	eb 59       	subi	r30, 0x9B	; 155
    1d44:	fe 4f       	sbci	r31, 0xFE	; 254
    1d46:	80 81       	ld	r24, Z
    1d48:	83 bf       	out	0x33, r24	; 51
    1d4a:	89 b7       	in	r24, 0x39	; 57
    1d4c:	8c 7f       	andi	r24, 0xFC	; 252
    1d4e:	91 81       	ldd	r25, Z+1	; 0x01
    1d50:	89 2b       	or	r24, r25
    1d52:	89 bf       	out	0x39, r24	; 57
    1d54:	80 e0       	ldi	r24, 0x00	; 0
    1d56:	08 95       	ret
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	fc 01       	movw	r30, r24
    1d5c:	ee 0f       	add	r30, r30
    1d5e:	ff 1f       	adc	r31, r31
    1d60:	8e 0f       	add	r24, r30
    1d62:	9f 1f       	adc	r25, r31
    1d64:	fc 01       	movw	r30, r24
    1d66:	eb 59       	subi	r30, 0x9B	; 155
    1d68:	fe 4f       	sbci	r31, 0xFE	; 254
    1d6a:	80 81       	ld	r24, Z
    1d6c:	8e bd       	out	0x2e, r24	; 46
    1d6e:	89 b7       	in	r24, 0x39	; 57
    1d70:	28 2f       	mov	r18, r24
    1d72:	27 7e       	andi	r18, 0xE7	; 231
    1d74:	91 81       	ldd	r25, Z+1	; 0x01
    1d76:	89 2f       	mov	r24, r25
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	88 0f       	add	r24, r24
    1d7c:	99 1f       	adc	r25, r25
    1d7e:	88 0f       	add	r24, r24
    1d80:	99 1f       	adc	r25, r25
    1d82:	88 0f       	add	r24, r24
    1d84:	99 1f       	adc	r25, r25
    1d86:	82 2b       	or	r24, r18
    1d88:	89 bf       	out	0x39, r24	; 57
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	08 95       	ret
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	fc 01       	movw	r30, r24
    1d92:	ee 0f       	add	r30, r30
    1d94:	ff 1f       	adc	r31, r31
    1d96:	8e 0f       	add	r24, r30
    1d98:	9f 1f       	adc	r25, r31
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	eb 59       	subi	r30, 0x9B	; 155
    1d9e:	fe 4f       	sbci	r31, 0xFE	; 254
    1da0:	80 81       	ld	r24, Z
    1da2:	85 bd       	out	0x25, r24	; 37
    1da4:	89 b7       	in	r24, 0x39	; 57
    1da6:	28 2f       	mov	r18, r24
    1da8:	2f 73       	andi	r18, 0x3F	; 63
    1daa:	91 81       	ldd	r25, Z+1	; 0x01
    1dac:	30 e4       	ldi	r19, 0x40	; 64
    1dae:	93 9f       	mul	r25, r19
    1db0:	c0 01       	movw	r24, r0
    1db2:	11 24       	eor	r1, r1
    1db4:	82 2b       	or	r24, r18
    1db6:	89 bf       	out	0x39, r24	; 57
    1db8:	80 e0       	ldi	r24, 0x00	; 0
    1dba:	08 95       	ret
    1dbc:	8e ef       	ldi	r24, 0xFE	; 254
    1dbe:	08 95       	ret

00001dc0 <TIM_Start>:
    1dc0:	81 30       	cpi	r24, 0x01	; 1
    1dc2:	71 f0       	breq	.+28     	; 0x1de0 <TIM_Start+0x20>
    1dc4:	18 f0       	brcs	.+6      	; 0x1dcc <TIM_Start+0xc>
    1dc6:	82 30       	cpi	r24, 0x02	; 2
    1dc8:	31 f0       	breq	.+12     	; 0x1dd6 <TIM_Start+0x16>
    1dca:	1f c0       	rjmp	.+62     	; 0x1e0a <TIM_Start+0x4a>
    1dcc:	e2 e5       	ldi	r30, 0x52	; 82
    1dce:	f0 e0       	ldi	r31, 0x00	; 0
    1dd0:	a3 e5       	ldi	r26, 0x53	; 83
    1dd2:	b0 e0       	ldi	r27, 0x00	; 0
    1dd4:	09 c0       	rjmp	.+18     	; 0x1de8 <TIM_Start+0x28>
    1dd6:	e4 e4       	ldi	r30, 0x44	; 68
    1dd8:	f0 e0       	ldi	r31, 0x00	; 0
    1dda:	a5 e4       	ldi	r26, 0x45	; 69
    1ddc:	b0 e0       	ldi	r27, 0x00	; 0
    1dde:	04 c0       	rjmp	.+8      	; 0x1de8 <TIM_Start+0x28>
    1de0:	ec e4       	ldi	r30, 0x4C	; 76
    1de2:	f0 e0       	ldi	r31, 0x00	; 0
    1de4:	ae e4       	ldi	r26, 0x4E	; 78
    1de6:	b0 e0       	ldi	r27, 0x00	; 0
    1de8:	71 83       	std	Z+1, r23	; 0x01
    1dea:	60 83       	st	Z, r22
    1dec:	2c 91       	ld	r18, X
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	fc 01       	movw	r30, r24
    1df2:	ee 0f       	add	r30, r30
    1df4:	ff 1f       	adc	r31, r31
    1df6:	8e 0f       	add	r24, r30
    1df8:	9f 1f       	adc	r25, r31
    1dfa:	fc 01       	movw	r30, r24
    1dfc:	eb 59       	subi	r30, 0x9B	; 155
    1dfe:	fe 4f       	sbci	r31, 0xFE	; 254
    1e00:	82 81       	ldd	r24, Z+2	; 0x02
    1e02:	82 2b       	or	r24, r18
    1e04:	8c 93       	st	X, r24
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	08 95       	ret
    1e0a:	8e ef       	ldi	r24, 0xFE	; 254
    1e0c:	08 95       	ret

00001e0e <TIM_GetStatus>:
*
* @return function error state.
*/
ERROR_STATE_t TIM_GetStatus(TIM_CH_t TIM_channel, uint8_t* FlagStatus)
{
   if(NULL_PTR == FlagStatus)
    1e0e:	61 15       	cp	r22, r1
    1e10:	71 05       	cpc	r23, r1
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <TIM_GetStatus+0x8>
    1e14:	7a c0       	rjmp	.+244    	; 0x1f0a <TIM_GetStatus+0xfc>
   {
      return TIMER_E_NULL_PTR;
   }
   
   /* sets the registers pointers according to the required timer. */
   switch(TIM_channel)
    1e16:	81 30       	cpi	r24, 0x01	; 1
    1e18:	41 f1       	breq	.+80     	; 0x1e6a <TIM_GetStatus+0x5c>
    1e1a:	20 f0       	brcs	.+8      	; 0x1e24 <TIM_GetStatus+0x16>
    1e1c:	82 30       	cpi	r24, 0x02	; 2
    1e1e:	09 f4       	brne	.+2      	; 0x1e22 <TIM_GetStatus+0x14>
    1e20:	52 c0       	rjmp	.+164    	; 0x1ec6 <TIM_GetStatus+0xb8>
    1e22:	75 c0       	rjmp	.+234    	; 0x1f0e <TIM_GetStatus+0x100>
   {
      case TIMER_0:
         if(gastr_Timer_Config[TIM_channel].u8_mode == NORMAL_MODE)
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	fc 01       	movw	r30, r24
    1e28:	ee 0f       	add	r30, r30
    1e2a:	ff 1f       	adc	r31, r31
    1e2c:	8e 0f       	add	r24, r30
    1e2e:	9f 1f       	adc	r25, r31
    1e30:	fc 01       	movw	r30, r24
    1e32:	eb 59       	subi	r30, 0x9B	; 155
    1e34:	fe 4f       	sbci	r31, 0xFE	; 254
    1e36:	80 81       	ld	r24, Z
    1e38:	81 11       	cpse	r24, r1
    1e3a:	09 c0       	rjmp	.+18     	; 0x1e4e <TIM_GetStatus+0x40>
         {
            if( TIFR & TIMER_0_OVERFLOW_FLAG )
    1e3c:	08 b6       	in	r0, 0x38	; 56
    1e3e:	00 fe       	sbrs	r0, 0
    1e40:	68 c0       	rjmp	.+208    	; 0x1f12 <TIM_GetStatus+0x104>
            {
               *FlagStatus = TIMER_OVERFLOW_FLAG;
    1e42:	fb 01       	movw	r30, r22
    1e44:	10 82       	st	Z, r1
               TIFR |= TIMER_0_OVERFLOW_FLAG;
    1e46:	98 b7       	in	r25, 0x38	; 56
    1e48:	91 60       	ori	r25, 0x01	; 1
    1e4a:	98 bf       	out	0x38, r25	; 56
    1e4c:	08 95       	ret
            else
            {
               return TIMER_E_PENDING;
            }
         }
         else if(gastr_Timer_Config[TIM_channel].u8_mode == COMPARE_MATCH_MODE)
    1e4e:	88 30       	cpi	r24, 0x08	; 8
    1e50:	09 f0       	breq	.+2      	; 0x1e54 <TIM_GetStatus+0x46>
    1e52:	61 c0       	rjmp	.+194    	; 0x1f16 <TIM_GetStatus+0x108>
         {
            if(TIFR & TIMER_0_COMPARE_FLAG)
    1e54:	08 b6       	in	r0, 0x38	; 56
    1e56:	01 fe       	sbrs	r0, 1
    1e58:	60 c0       	rjmp	.+192    	; 0x1f1a <TIM_GetStatus+0x10c>
            {
               *FlagStatus = TIMER_COMPARE_FLAG;
    1e5a:	81 e0       	ldi	r24, 0x01	; 1
    1e5c:	fb 01       	movw	r30, r22
    1e5e:	80 83       	st	Z, r24
               TIFR |= TIMER_0_COMPARE_FLAG;
    1e60:	88 b7       	in	r24, 0x38	; 56
    1e62:	82 60       	ori	r24, 0x02	; 2
    1e64:	88 bf       	out	0x38, r24	; 56
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1e66:	80 e0       	ldi	r24, 0x00	; 0
    1e68:	08 95       	ret
               return TIMER_E_PENDING;
            }
         }
         break;
      case TIMER_1:
         if(gastr_Timer_Config[TIM_channel].u8_mode == NORMAL_MODE)
    1e6a:	90 e0       	ldi	r25, 0x00	; 0
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	ee 0f       	add	r30, r30
    1e70:	ff 1f       	adc	r31, r31
    1e72:	8e 0f       	add	r24, r30
    1e74:	9f 1f       	adc	r25, r31
    1e76:	fc 01       	movw	r30, r24
    1e78:	eb 59       	subi	r30, 0x9B	; 155
    1e7a:	fe 4f       	sbci	r31, 0xFE	; 254
    1e7c:	80 81       	ld	r24, Z
    1e7e:	81 11       	cpse	r24, r1
    1e80:	09 c0       	rjmp	.+18     	; 0x1e94 <TIM_GetStatus+0x86>
         {
            if( TIFR & TIMER_1_OVERFLOW_FLAG )
    1e82:	08 b6       	in	r0, 0x38	; 56
    1e84:	02 fe       	sbrs	r0, 2
    1e86:	4b c0       	rjmp	.+150    	; 0x1f1e <TIM_GetStatus+0x110>
            {
               *FlagStatus = TIMER_OVERFLOW_FLAG;
    1e88:	fb 01       	movw	r30, r22
    1e8a:	10 82       	st	Z, r1
               TIFR |= TIMER_1_OVERFLOW_FLAG;
    1e8c:	98 b7       	in	r25, 0x38	; 56
    1e8e:	94 60       	ori	r25, 0x04	; 4
    1e90:	98 bf       	out	0x38, r25	; 56
    1e92:	08 95       	ret
            else
            {
               return TIMER_E_PENDING;
            }
         }
         else if(gastr_Timer_Config[TIM_channel].u8_mode == COMPARE_MATCH_MODE)
    1e94:	88 30       	cpi	r24, 0x08	; 8
    1e96:	09 f0       	breq	.+2      	; 0x1e9a <TIM_GetStatus+0x8c>
    1e98:	44 c0       	rjmp	.+136    	; 0x1f22 <TIM_GetStatus+0x114>
         {
            if(TIFR & TIMER_1A_COMPARE_FLAG)
    1e9a:	98 b7       	in	r25, 0x38	; 56
    1e9c:	89 2f       	mov	r24, r25
    1e9e:	80 71       	andi	r24, 0x10	; 16
    1ea0:	94 ff       	sbrs	r25, 4
    1ea2:	08 c0       	rjmp	.+16     	; 0x1eb4 <TIM_GetStatus+0xa6>
            {
               *FlagStatus = TIMER_COMPARE_FLAG;
    1ea4:	81 e0       	ldi	r24, 0x01	; 1
    1ea6:	fb 01       	movw	r30, r22
    1ea8:	80 83       	st	Z, r24
               TIFR |= TIMER_1A_COMPARE_FLAG;
    1eaa:	88 b7       	in	r24, 0x38	; 56
    1eac:	80 61       	ori	r24, 0x10	; 16
    1eae:	88 bf       	out	0x38, r24	; 56
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1eb0:	80 e0       	ldi	r24, 0x00	; 0
    1eb2:	08 95       	ret
            if(TIFR & TIMER_1A_COMPARE_FLAG)
            {
               *FlagStatus = TIMER_COMPARE_FLAG;
               TIFR |= TIMER_1A_COMPARE_FLAG;
            }
            else if(TIFR & TIMER_1B_COMPARE_FLAG)
    1eb4:	93 ff       	sbrs	r25, 3
    1eb6:	37 c0       	rjmp	.+110    	; 0x1f26 <TIM_GetStatus+0x118>
            {
               *FlagStatus = TIMER_COMPARE_FLAG;
    1eb8:	91 e0       	ldi	r25, 0x01	; 1
    1eba:	fb 01       	movw	r30, r22
    1ebc:	90 83       	st	Z, r25
               TIFR |= TIMER_1B_COMPARE_FLAG;
    1ebe:	98 b7       	in	r25, 0x38	; 56
    1ec0:	98 60       	ori	r25, 0x08	; 8
    1ec2:	98 bf       	out	0x38, r25	; 56
    1ec4:	08 95       	ret
               return TIMER_E_PENDING;
            }
         }
         break;
      case TIMER_2:
         if(gastr_Timer_Config[TIM_channel].u8_mode == NORMAL_MODE)
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	fc 01       	movw	r30, r24
    1eca:	ee 0f       	add	r30, r30
    1ecc:	ff 1f       	adc	r31, r31
    1ece:	8e 0f       	add	r24, r30
    1ed0:	9f 1f       	adc	r25, r31
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	eb 59       	subi	r30, 0x9B	; 155
    1ed6:	fe 4f       	sbci	r31, 0xFE	; 254
    1ed8:	80 81       	ld	r24, Z
    1eda:	81 11       	cpse	r24, r1
    1edc:	09 c0       	rjmp	.+18     	; 0x1ef0 <TIM_GetStatus+0xe2>
         {
            if( TIFR & TIMER_2_OVERFLOW_FLAG )
    1ede:	08 b6       	in	r0, 0x38	; 56
    1ee0:	06 fe       	sbrs	r0, 6
    1ee2:	23 c0       	rjmp	.+70     	; 0x1f2a <TIM_GetStatus+0x11c>
            {
               *FlagStatus = TIMER_OVERFLOW_FLAG;
    1ee4:	fb 01       	movw	r30, r22
    1ee6:	10 82       	st	Z, r1
               TIFR |= TIMER_2_OVERFLOW_FLAG;
    1ee8:	98 b7       	in	r25, 0x38	; 56
    1eea:	90 64       	ori	r25, 0x40	; 64
    1eec:	98 bf       	out	0x38, r25	; 56
    1eee:	08 95       	ret
            else
            {
               return TIMER_E_PENDING;
            }
         }
         else if(gastr_Timer_Config[TIM_channel].u8_mode == COMPARE_MATCH_MODE)
    1ef0:	88 30       	cpi	r24, 0x08	; 8
    1ef2:	e9 f4       	brne	.+58     	; 0x1f2e <TIM_GetStatus+0x120>
         {
            if(TIFR & TIMER_2_COMPARE_FLAG)
    1ef4:	08 b6       	in	r0, 0x38	; 56
    1ef6:	07 fe       	sbrs	r0, 7
    1ef8:	1c c0       	rjmp	.+56     	; 0x1f32 <TIM_GetStatus+0x124>
            {
               *FlagStatus = TIMER_COMPARE_FLAG;
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	fb 01       	movw	r30, r22
    1efe:	80 83       	st	Z, r24
               TIFR |= TIMER_2_COMPARE_FLAG;
    1f00:	88 b7       	in	r24, 0x38	; 56
    1f02:	80 68       	ori	r24, 0x80	; 128
    1f04:	88 bf       	out	0x38, r24	; 56
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1f06:	80 e0       	ldi	r24, 0x00	; 0
    1f08:	08 95       	ret
*/
ERROR_STATE_t TIM_GetStatus(TIM_CH_t TIM_channel, uint8_t* FlagStatus)
{
   if(NULL_PTR == FlagStatus)
   {
      return TIMER_E_NULL_PTR;
    1f0a:	8f ef       	ldi	r24, 0xFF	; 255
    1f0c:	08 95       	ret
            }
         }
         
         break;
      default:
         return TIMER_E_INVALID_CH_NUM;
    1f0e:	8e ef       	ldi	r24, 0xFE	; 254
    1f10:	08 95       	ret
               *FlagStatus = TIMER_OVERFLOW_FLAG;
               TIFR |= TIMER_0_OVERFLOW_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f12:	8d ef       	ldi	r24, 0xFD	; 253
    1f14:	08 95       	ret
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1f16:	80 e0       	ldi	r24, 0x00	; 0
    1f18:	08 95       	ret
               *FlagStatus = TIMER_COMPARE_FLAG;
               TIFR |= TIMER_0_COMPARE_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f1a:	8d ef       	ldi	r24, 0xFD	; 253
    1f1c:	08 95       	ret
               *FlagStatus = TIMER_OVERFLOW_FLAG;
               TIFR |= TIMER_1_OVERFLOW_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f1e:	8d ef       	ldi	r24, 0xFD	; 253
    1f20:	08 95       	ret
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1f22:	80 e0       	ldi	r24, 0x00	; 0
    1f24:	08 95       	ret
               *FlagStatus = TIMER_COMPARE_FLAG;
               TIFR |= TIMER_1B_COMPARE_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f26:	8d ef       	ldi	r24, 0xFD	; 253
    1f28:	08 95       	ret
               *FlagStatus = TIMER_OVERFLOW_FLAG;
               TIFR |= TIMER_2_OVERFLOW_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f2a:	8d ef       	ldi	r24, 0xFD	; 253
    1f2c:	08 95       	ret
      default:
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
    1f30:	08 95       	ret
               *FlagStatus = TIMER_COMPARE_FLAG;
               TIFR |= TIMER_2_COMPARE_FLAG;
            }
            else
            {
               return TIMER_E_PENDING;
    1f32:	8d ef       	ldi	r24, 0xFD	; 253
         return TIMER_E_INVALID_CH_NUM;
   }
   
   /* return success message. */
   return ERROR_OK;
}
    1f34:	08 95       	ret

00001f36 <TIM_DelayUs>:
* @param [out] TIM_Delay   -  Time to delay in microseconds.
*
* @return function error state.
*/
ERROR_STATE_t TIM_DelayUs(TIM_CH_t TIM_channel, TIM_Delay_t TIM_Delay, Ptr_VoidFuncVoid_t DelayRequester)
{
    1f36:	8f 92       	push	r8
    1f38:	9f 92       	push	r9
    1f3a:	af 92       	push	r10
    1f3c:	bf 92       	push	r11
    1f3e:	cf 92       	push	r12
    1f40:	df 92       	push	r13
    1f42:	ef 92       	push	r14
    1f44:	ff 92       	push	r15
    1f46:	1f 93       	push	r17
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
    1f4c:	00 d0       	rcall	.+0      	; 0x1f4e <TIM_DelayUs+0x18>
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <TIM_DelayUs+0x1a>
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
    1f54:	18 2f       	mov	r17, r24
    1f56:	6a 01       	movw	r12, r20
    1f58:	7b 01       	movw	r14, r22
   /* Make sure not invalid timer channel */
   if(TIM_channel >= INVALID_TIMER_CH)
    1f5a:	83 30       	cpi	r24, 0x03	; 3
    1f5c:	08 f0       	brcs	.+2      	; 0x1f60 <TIM_DelayUs+0x2a>
    1f5e:	54 c0       	rjmp	.+168    	; 0x2008 <TIM_DelayUs+0xd2>
   {
      return TIMER_E_INVALID_CH_NUM;
   }
   
   if(NULL_PTR == DelayRequester)
    1f60:	21 15       	cp	r18, r1
    1f62:	31 05       	cpc	r19, r1
    1f64:	09 f4       	brne	.+2      	; 0x1f68 <TIM_DelayUs+0x32>
    1f66:	52 c0       	rjmp	.+164    	; 0x200c <TIM_DelayUs+0xd6>
   {
      return ERROR_NOK;
   }
   else
   {
      gptr_CallerFunc = DelayRequester;
    1f68:	30 93 ae 07 	sts	0x07AE, r19	; 0x8007ae <gptr_CallerFunc+0x1>
    1f6c:	20 93 ad 07 	sts	0x07AD, r18	; 0x8007ad <gptr_CallerFunc>
   
   /* Static variables used */
   ERROR_STATE_t Timer_state;
   
   /* Ready state */
   if(DelayReady == gEnu_State)
    1f70:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <gEnu_State>
    1f74:	81 11       	cpse	r24, r1
    1f76:	4c c0       	rjmp	.+152    	; 0x2010 <TIM_DelayUs+0xda>
   {
      /* Calculate needed frequency Ratio */
      float32_t f32_FreqRatio;
      Timer_state = GetFreqPrescaleRatio(TIM_channel, &f32_FreqRatio);
    1f78:	be 01       	movw	r22, r28
    1f7a:	6f 5f       	subi	r22, 0xFF	; 255
    1f7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f7e:	81 2f       	mov	r24, r17
    1f80:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <GetFreqPrescaleRatio>
      if(TIMER_E_UNSUPPORTED_PRESCALE == Timer_state)
    1f84:	8c 3f       	cpi	r24, 0xFC	; 252
    1f86:	f1 f1       	breq	.+124    	; 0x2004 <TIM_DelayUs+0xce>
      {
         return TIMER_E_UNSUPPORTED_PRESCALE;
      }
      
      if(f32_FreqRatio != 0)
    1f88:	89 80       	ldd	r8, Y+1	; 0x01
    1f8a:	9a 80       	ldd	r9, Y+2	; 0x02
    1f8c:	ab 80       	ldd	r10, Y+3	; 0x03
    1f8e:	bc 80       	ldd	r11, Y+4	; 0x04
    1f90:	20 e0       	ldi	r18, 0x00	; 0
    1f92:	30 e0       	ldi	r19, 0x00	; 0
    1f94:	a9 01       	movw	r20, r18
    1f96:	c5 01       	movw	r24, r10
    1f98:	b4 01       	movw	r22, r8
    1f9a:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <__cmpsf2>
    1f9e:	88 23       	and	r24, r24
    1fa0:	61 f0       	breq	.+24     	; 0x1fba <TIM_DelayUs+0x84>
      {
         TIM_Delay /= f32_FreqRatio;
    1fa2:	c7 01       	movw	r24, r14
    1fa4:	b6 01       	movw	r22, r12
    1fa6:	0e 94 76 17 	call	0x2eec	; 0x2eec <__floatunsisf>
    1faa:	a5 01       	movw	r20, r10
    1fac:	94 01       	movw	r18, r8
    1fae:	0e 94 d5 16 	call	0x2daa	; 0x2daa <__divsf3>
    1fb2:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <__fixunssfsi>
    1fb6:	6b 01       	movw	r12, r22
    1fb8:	7c 01       	movw	r14, r24
      }
      
      /* Calculate how many overflows needed */
      gu32_Overflows = TIM_Delay / TIMER_OVERFLOW_FACTOR;
    1fba:	bb 27       	eor	r27, r27
    1fbc:	af 2d       	mov	r26, r15
    1fbe:	9e 2d       	mov	r25, r14
    1fc0:	8d 2d       	mov	r24, r13
    1fc2:	80 93 b2 07 	sts	0x07B2, r24	; 0x8007b2 <gu32_Overflows>
    1fc6:	90 93 b3 07 	sts	0x07B3, r25	; 0x8007b3 <gu32_Overflows+0x1>
    1fca:	a0 93 b4 07 	sts	0x07B4, r26	; 0x8007b4 <gu32_Overflows+0x2>
    1fce:	b0 93 b5 07 	sts	0x07B5, r27	; 0x8007b5 <gu32_Overflows+0x3>
      gu8_Remindar = TIM_Delay % TIMER_OVERFLOW_FACTOR;
    1fd2:	c0 92 b0 07 	sts	0x07B0, r12	; 0x8007b0 <gu8_Remindar>
      
      if(gu32_Overflows == 0)
    1fd6:	89 2b       	or	r24, r25
    1fd8:	8a 2b       	or	r24, r26
    1fda:	8b 2b       	or	r24, r27
    1fdc:	49 f4       	brne	.+18     	; 0x1ff0 <TIM_DelayUs+0xba>
      {
         gu8_OverflowsComplete = HIGH;
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	80 93 b1 07 	sts	0x07B1, r24	; 0x8007b1 <gu8_OverflowsComplete>
         TIM_Start(TIM_channel, gu8_Remindar);
    1fe4:	6c 2d       	mov	r22, r12
    1fe6:	70 e0       	ldi	r23, 0x00	; 0
    1fe8:	81 2f       	mov	r24, r17
    1fea:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
    1fee:	05 c0       	rjmp	.+10     	; 0x1ffa <TIM_DelayUs+0xc4>
      }
      else
      {
         /* Start timer with full register */
         TIM_Start(TIM_channel, FULL_8_BITS);
    1ff0:	6f ef       	ldi	r22, 0xFF	; 255
    1ff2:	70 e0       	ldi	r23, 0x00	; 0
    1ff4:	81 2f       	mov	r24, r17
    1ff6:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
      }     
      /* Change to timer pending state */ 
      gEnu_State = DelayPending;
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <gEnu_State>
      return TIMER_E_PENDING;
    2000:	8d ef       	ldi	r24, 0xFD	; 253
    2002:	07 c0       	rjmp	.+14     	; 0x2012 <TIM_DelayUs+0xdc>
      /* Calculate needed frequency Ratio */
      float32_t f32_FreqRatio;
      Timer_state = GetFreqPrescaleRatio(TIM_channel, &f32_FreqRatio);
      if(TIMER_E_UNSUPPORTED_PRESCALE == Timer_state)
      {
         return TIMER_E_UNSUPPORTED_PRESCALE;
    2004:	8c ef       	ldi	r24, 0xFC	; 252
    2006:	05 c0       	rjmp	.+10     	; 0x2012 <TIM_DelayUs+0xdc>
ERROR_STATE_t TIM_DelayUs(TIM_CH_t TIM_channel, TIM_Delay_t TIM_Delay, Ptr_VoidFuncVoid_t DelayRequester)
{
   /* Make sure not invalid timer channel */
   if(TIM_channel >= INVALID_TIMER_CH)
   {
      return TIMER_E_INVALID_CH_NUM;
    2008:	8e ef       	ldi	r24, 0xFE	; 254
    200a:	03 c0       	rjmp	.+6      	; 0x2012 <TIM_DelayUs+0xdc>
   }
   
   if(NULL_PTR == DelayRequester)
   {
      return ERROR_NOK;
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	01 c0       	rjmp	.+2      	; 0x2012 <TIM_DelayUs+0xdc>
      /* Change to timer pending state */ 
      gEnu_State = DelayPending;
      return TIMER_E_PENDING;
   }
   
   return ERROR_NOK;            
    2010:	81 e0       	ldi	r24, 0x01	; 1
}
    2012:	0f 90       	pop	r0
    2014:	0f 90       	pop	r0
    2016:	0f 90       	pop	r0
    2018:	0f 90       	pop	r0
    201a:	df 91       	pop	r29
    201c:	cf 91       	pop	r28
    201e:	1f 91       	pop	r17
    2020:	ff 90       	pop	r15
    2022:	ef 90       	pop	r14
    2024:	df 90       	pop	r13
    2026:	cf 90       	pop	r12
    2028:	bf 90       	pop	r11
    202a:	af 90       	pop	r10
    202c:	9f 90       	pop	r9
    202e:	8f 90       	pop	r8
    2030:	08 95       	ret

00002032 <TIM_DelayMs>:
* @param [out] TIM_Delay   -  Time to delay in milliseconds.
*
* @return function error state.
*/
ERROR_STATE_t TIM_DelayMs(TIM_CH_t TIM_channel, TIM_Delay_t TIM_Delay, Ptr_VoidFuncVoid_t DelayRequester)
{
    2032:	8f 92       	push	r8
    2034:	9f 92       	push	r9
    2036:	af 92       	push	r10
    2038:	bf 92       	push	r11
    203a:	df 92       	push	r13
    203c:	ef 92       	push	r14
    203e:	ff 92       	push	r15
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	00 d0       	rcall	.+0      	; 0x204a <TIM_DelayMs+0x18>
    204a:	00 d0       	rcall	.+0      	; 0x204c <TIM_DelayMs+0x1a>
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
    2050:	18 2f       	mov	r17, r24
    2052:	04 2f       	mov	r16, r20
    2054:	d5 2e       	mov	r13, r21
    2056:	e6 2e       	mov	r14, r22
    2058:	f7 2e       	mov	r15, r23
   /* Make sure not invalid timer channel */
   if(TIM_channel >= INVALID_TIMER_CH)
    205a:	83 30       	cpi	r24, 0x03	; 3
    205c:	08 f0       	brcs	.+2      	; 0x2060 <TIM_DelayMs+0x2e>
    205e:	65 c0       	rjmp	.+202    	; 0x212a <TIM_DelayMs+0xf8>
   {
      return TIMER_E_INVALID_CH_NUM;
   }
   
   if(NULL_PTR == DelayRequester)
    2060:	21 15       	cp	r18, r1
    2062:	31 05       	cpc	r19, r1
    2064:	09 f4       	brne	.+2      	; 0x2068 <TIM_DelayMs+0x36>
    2066:	63 c0       	rjmp	.+198    	; 0x212e <TIM_DelayMs+0xfc>
   {
      return ERROR_NOK;
   }
   else
   {
      gptr_CallerFunc = DelayRequester;
    2068:	30 93 ae 07 	sts	0x07AE, r19	; 0x8007ae <gptr_CallerFunc+0x1>
    206c:	20 93 ad 07 	sts	0x07AD, r18	; 0x8007ad <gptr_CallerFunc>
   }
   
   ERROR_STATE_t Timer_state;
   
   /* Ready state */
   if(DelayReady == gEnu_State)
    2070:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <gEnu_State>
    2074:	81 11       	cpse	r24, r1
    2076:	5d c0       	rjmp	.+186    	; 0x2132 <TIM_DelayMs+0x100>
   {
      /* Calculate needer frequency Ratio */
      float32_t f32_FreqRatio;
      Timer_state = GetFreqPrescaleRatio(TIM_channel, &f32_FreqRatio);
    2078:	be 01       	movw	r22, r28
    207a:	6f 5f       	subi	r22, 0xFF	; 255
    207c:	7f 4f       	sbci	r23, 0xFF	; 255
    207e:	81 2f       	mov	r24, r17
    2080:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <GetFreqPrescaleRatio>
      if(TIMER_E_UNSUPPORTED_PRESCALE == Timer_state)
    2084:	8c 3f       	cpi	r24, 0xFC	; 252
    2086:	09 f4       	brne	.+2      	; 0x208a <TIM_DelayMs+0x58>
    2088:	4e c0       	rjmp	.+156    	; 0x2126 <TIM_DelayMs+0xf4>
      {
         return TIMER_E_UNSUPPORTED_PRESCALE;
      }
      
      if(f32_FreqRatio != 0)
    208a:	89 80       	ldd	r8, Y+1	; 0x01
    208c:	9a 80       	ldd	r9, Y+2	; 0x02
    208e:	ab 80       	ldd	r10, Y+3	; 0x03
    2090:	bc 80       	ldd	r11, Y+4	; 0x04
    2092:	20 e0       	ldi	r18, 0x00	; 0
    2094:	30 e0       	ldi	r19, 0x00	; 0
    2096:	a9 01       	movw	r20, r18
    2098:	c5 01       	movw	r24, r10
    209a:	b4 01       	movw	r22, r8
    209c:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <__cmpsf2>
    20a0:	88 23       	and	r24, r24
    20a2:	81 f0       	breq	.+32     	; 0x20c4 <TIM_DelayMs+0x92>
      {
         TIM_Delay /= f32_FreqRatio;
    20a4:	60 2f       	mov	r22, r16
    20a6:	7d 2d       	mov	r23, r13
    20a8:	8e 2d       	mov	r24, r14
    20aa:	9f 2d       	mov	r25, r15
    20ac:	0e 94 76 17 	call	0x2eec	; 0x2eec <__floatunsisf>
    20b0:	a5 01       	movw	r20, r10
    20b2:	94 01       	movw	r18, r8
    20b4:	0e 94 d5 16 	call	0x2daa	; 0x2daa <__divsf3>
    20b8:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <__fixunssfsi>
    20bc:	06 2f       	mov	r16, r22
    20be:	d7 2e       	mov	r13, r23
    20c0:	e8 2e       	mov	r14, r24
    20c2:	f9 2e       	mov	r15, r25
      }
      
      /* Calculate how many overflows needed */
      gu32_Overflows = TIM_Delay*MILLISECOND_TO_MICROSECOND / TIMER_OVERFLOW_FACTOR;
    20c4:	a8 ee       	ldi	r26, 0xE8	; 232
    20c6:	b3 e0       	ldi	r27, 0x03	; 3
    20c8:	20 2f       	mov	r18, r16
    20ca:	3d 2d       	mov	r19, r13
    20cc:	4e 2d       	mov	r20, r14
    20ce:	5f 2d       	mov	r21, r15
    20d0:	0e 94 cc 18 	call	0x3198	; 0x3198 <__muluhisi3>
    20d4:	bb 27       	eor	r27, r27
    20d6:	a9 2f       	mov	r26, r25
    20d8:	98 2f       	mov	r25, r24
    20da:	87 2f       	mov	r24, r23
    20dc:	80 93 b2 07 	sts	0x07B2, r24	; 0x8007b2 <gu32_Overflows>
    20e0:	90 93 b3 07 	sts	0x07B3, r25	; 0x8007b3 <gu32_Overflows+0x1>
    20e4:	a0 93 b4 07 	sts	0x07B4, r26	; 0x8007b4 <gu32_Overflows+0x2>
    20e8:	b0 93 b5 07 	sts	0x07B5, r27	; 0x8007b5 <gu32_Overflows+0x3>
      gu8_Remindar = TIM_Delay*MILLISECOND_TO_MICROSECOND % TIMER_OVERFLOW_FACTOR;
    20ec:	28 ee       	ldi	r18, 0xE8	; 232
    20ee:	02 9f       	mul	r16, r18
    20f0:	00 2d       	mov	r16, r0
    20f2:	11 24       	eor	r1, r1
    20f4:	00 93 b0 07 	sts	0x07B0, r16	; 0x8007b0 <gu8_Remindar>
      
      if(gu32_Overflows == 0)
    20f8:	89 2b       	or	r24, r25
    20fa:	8a 2b       	or	r24, r26
    20fc:	8b 2b       	or	r24, r27
    20fe:	49 f4       	brne	.+18     	; 0x2112 <TIM_DelayMs+0xe0>
      {
         gu8_OverflowsComplete = HIGH;
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	80 93 b1 07 	sts	0x07B1, r24	; 0x8007b1 <gu8_OverflowsComplete>
         TIM_Start(TIM_channel, gu8_Remindar);
    2106:	60 2f       	mov	r22, r16
    2108:	70 e0       	ldi	r23, 0x00	; 0
    210a:	81 2f       	mov	r24, r17
    210c:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
    2110:	05 c0       	rjmp	.+10     	; 0x211c <TIM_DelayMs+0xea>
      }
      else
      {
         /* Start timer with full register */
         TIM_Start(TIM_channel, FULL_8_BITS);
    2112:	6f ef       	ldi	r22, 0xFF	; 255
    2114:	70 e0       	ldi	r23, 0x00	; 0
    2116:	81 2f       	mov	r24, r17
    2118:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
      }
      /* Change to timer pending state */
      gEnu_State= DelayPending;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <gEnu_State>
      return TIMER_E_PENDING;
    2122:	8d ef       	ldi	r24, 0xFD	; 253
    2124:	07 c0       	rjmp	.+14     	; 0x2134 <TIM_DelayMs+0x102>
      /* Calculate needer frequency Ratio */
      float32_t f32_FreqRatio;
      Timer_state = GetFreqPrescaleRatio(TIM_channel, &f32_FreqRatio);
      if(TIMER_E_UNSUPPORTED_PRESCALE == Timer_state)
      {
         return TIMER_E_UNSUPPORTED_PRESCALE;
    2126:	8c ef       	ldi	r24, 0xFC	; 252
    2128:	05 c0       	rjmp	.+10     	; 0x2134 <TIM_DelayMs+0x102>
ERROR_STATE_t TIM_DelayMs(TIM_CH_t TIM_channel, TIM_Delay_t TIM_Delay, Ptr_VoidFuncVoid_t DelayRequester)
{
   /* Make sure not invalid timer channel */
   if(TIM_channel >= INVALID_TIMER_CH)
   {
      return TIMER_E_INVALID_CH_NUM;
    212a:	8e ef       	ldi	r24, 0xFE	; 254
    212c:	03 c0       	rjmp	.+6      	; 0x2134 <TIM_DelayMs+0x102>
   }
   
   if(NULL_PTR == DelayRequester)
   {
      return ERROR_NOK;
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	01 c0       	rjmp	.+2      	; 0x2134 <TIM_DelayMs+0x102>
      /* Change to timer pending state */
      gEnu_State= DelayPending;
      return TIMER_E_PENDING;
   }
   
   return ERROR_NOK;
    2132:	81 e0       	ldi	r24, 0x01	; 1
}
    2134:	0f 90       	pop	r0
    2136:	0f 90       	pop	r0
    2138:	0f 90       	pop	r0
    213a:	0f 90       	pop	r0
    213c:	df 91       	pop	r29
    213e:	cf 91       	pop	r28
    2140:	1f 91       	pop	r17
    2142:	0f 91       	pop	r16
    2144:	ff 90       	pop	r15
    2146:	ef 90       	pop	r14
    2148:	df 90       	pop	r13
    214a:	bf 90       	pop	r11
    214c:	af 90       	pop	r10
    214e:	9f 90       	pop	r9
    2150:	8f 90       	pop	r8
    2152:	08 95       	ret

00002154 <TIM_DelayStatus>:
* @param [out] DelayRequester    -  Function that requested the delay.
*
* @return function error state.
*/
ERROR_STATE_t TIM_DelayStatus(TIM_CH_t TIM_channel, Ptr_VoidFuncVoid_t DelayRequester)
{
    2154:	1f 93       	push	r17
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    215a:	1f 92       	push	r1
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
   if(DelayReady == gEnu_State)
    2160:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <gEnu_State>
    2164:	99 23       	and	r25, r25
    2166:	09 f4       	brne	.+2      	; 0x216a <TIM_DelayStatus+0x16>
    2168:	4c c0       	rjmp	.+152    	; 0x2202 <TIM_DelayStatus+0xae>
   {
      return TIMER_E_DELAY_EMPTY;
   }
   
   if(DelayRequester != gptr_CallerFunc)
    216a:	20 91 ad 07 	lds	r18, 0x07AD	; 0x8007ad <gptr_CallerFunc>
    216e:	30 91 ae 07 	lds	r19, 0x07AE	; 0x8007ae <gptr_CallerFunc+0x1>
    2172:	26 17       	cp	r18, r22
    2174:	37 07       	cpc	r19, r23
    2176:	09 f0       	breq	.+2      	; 0x217a <TIM_DelayStatus+0x26>
    2178:	46 c0       	rjmp	.+140    	; 0x2206 <TIM_DelayStatus+0xb2>
      return ERROR_NOK;
   }
   
   ERROR_STATE_t Timer_state;
   
   if(DelayPending == gEnu_State)
    217a:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <gEnu_State>
    217e:	91 30       	cpi	r25, 0x01	; 1
    2180:	09 f0       	breq	.+2      	; 0x2184 <TIM_DelayStatus+0x30>
    2182:	43 c0       	rjmp	.+134    	; 0x220a <TIM_DelayStatus+0xb6>
    2184:	18 2f       	mov	r17, r24
   {
      uint8_t u8_FlagState;
      /* Check timer state */
      Timer_state= TIM_GetStatus(TIM_channel, &u8_FlagState);
    2186:	be 01       	movw	r22, r28
    2188:	6f 5f       	subi	r22, 0xFF	; 255
    218a:	7f 4f       	sbci	r23, 0xFF	; 255
    218c:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <TIM_GetStatus>
      if(Timer_state == TIMER_OVERFLOW_FLAG)
    2190:	81 11       	cpse	r24, r1
    2192:	35 c0       	rjmp	.+106    	; 0x21fe <TIM_DelayStatus+0xaa>
      {
         /* If all overflows are finished and reminder. */
         if(gu8_OverflowsComplete == HIGH)
    2194:	80 91 b1 07 	lds	r24, 0x07B1	; 0x8007b1 <gu8_OverflowsComplete>
    2198:	81 30       	cpi	r24, 0x01	; 1
    219a:	41 f4       	brne	.+16     	; 0x21ac <TIM_DelayStatus+0x58>
         {
            /* Return to ready state */
            gEnu_State = DelayReady;
    219c:	10 92 af 07 	sts	0x07AF, r1	; 0x8007af <gEnu_State>
            gu8_OverflowsComplete = LOW;
    21a0:	10 92 b1 07 	sts	0x07B1, r1	; 0x8007b1 <gu8_OverflowsComplete>
            gu8_Remindar = 0;
    21a4:	10 92 b0 07 	sts	0x07B0, r1	; 0x8007b0 <gu8_Remindar>
            /* return success message. */
            return ERROR_OK;
    21a8:	80 e0       	ldi	r24, 0x00	; 0
    21aa:	30 c0       	rjmp	.+96     	; 0x220c <TIM_DelayStatus+0xb8>
         }
         
         /* Decrement overflows number */
         gu32_Overflows--;
    21ac:	80 91 b2 07 	lds	r24, 0x07B2	; 0x8007b2 <gu32_Overflows>
    21b0:	90 91 b3 07 	lds	r25, 0x07B3	; 0x8007b3 <gu32_Overflows+0x1>
    21b4:	a0 91 b4 07 	lds	r26, 0x07B4	; 0x8007b4 <gu32_Overflows+0x2>
    21b8:	b0 91 b5 07 	lds	r27, 0x07B5	; 0x8007b5 <gu32_Overflows+0x3>
    21bc:	01 97       	sbiw	r24, 0x01	; 1
    21be:	a1 09       	sbc	r26, r1
    21c0:	b1 09       	sbc	r27, r1
    21c2:	80 93 b2 07 	sts	0x07B2, r24	; 0x8007b2 <gu32_Overflows>
    21c6:	90 93 b3 07 	sts	0x07B3, r25	; 0x8007b3 <gu32_Overflows+0x1>
    21ca:	a0 93 b4 07 	sts	0x07B4, r26	; 0x8007b4 <gu32_Overflows+0x2>
    21ce:	b0 93 b5 07 	sts	0x07B5, r27	; 0x8007b5 <gu32_Overflows+0x3>
         /* If all overflows finished raise a flag so the next overflow will be the remainder's overflow */
         if(gu32_Overflows == 0)
    21d2:	89 2b       	or	r24, r25
    21d4:	8a 2b       	or	r24, r26
    21d6:	8b 2b       	or	r24, r27
    21d8:	59 f4       	brne	.+22     	; 0x21f0 <TIM_DelayStatus+0x9c>
         {
            gu8_OverflowsComplete = HIGH;
    21da:	81 e0       	ldi	r24, 0x01	; 1
    21dc:	80 93 b1 07 	sts	0x07B1, r24	; 0x8007b1 <gu8_OverflowsComplete>
            TIM_Start(TIM_channel, gu8_Remindar);
    21e0:	60 91 b0 07 	lds	r22, 0x07B0	; 0x8007b0 <gu8_Remindar>
    21e4:	70 e0       	ldi	r23, 0x00	; 0
    21e6:	81 2f       	mov	r24, r17
    21e8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
         {
            /* Start timer with full register */
            TIM_Start(TIM_channel, FULL_8_BITS);
         }
         
         return TIMER_E_PENDING;
    21ec:	8d ef       	ldi	r24, 0xFD	; 253
    21ee:	0e c0       	rjmp	.+28     	; 0x220c <TIM_DelayStatus+0xb8>
            TIM_Start(TIM_channel, gu8_Remindar);
         }
         else
         {
            /* Start timer with full register */
            TIM_Start(TIM_channel, FULL_8_BITS);
    21f0:	6f ef       	ldi	r22, 0xFF	; 255
    21f2:	70 e0       	ldi	r23, 0x00	; 0
    21f4:	81 2f       	mov	r24, r17
    21f6:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <TIM_Start>
         }
         
         return TIMER_E_PENDING;
    21fa:	8d ef       	ldi	r24, 0xFD	; 253
    21fc:	07 c0       	rjmp	.+14     	; 0x220c <TIM_DelayStatus+0xb8>
   }
   else
   {
      return ERROR_NOK;
   }
   return 0;
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	05 c0       	rjmp	.+10     	; 0x220c <TIM_DelayStatus+0xb8>
*/
ERROR_STATE_t TIM_DelayStatus(TIM_CH_t TIM_channel, Ptr_VoidFuncVoid_t DelayRequester)
{
   if(DelayReady == gEnu_State)
   {
      return TIMER_E_DELAY_EMPTY;
    2202:	8b ef       	ldi	r24, 0xFB	; 251
    2204:	03 c0       	rjmp	.+6      	; 0x220c <TIM_DelayStatus+0xb8>
   }
   
   if(DelayRequester != gptr_CallerFunc)
   {
      return ERROR_NOK;
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	01 c0       	rjmp	.+2      	; 0x220c <TIM_DelayStatus+0xb8>
         return TIMER_E_PENDING;
      }
   }
   else
   {
      return ERROR_NOK;
    220a:	81 e0       	ldi	r24, 0x01	; 1
   }
   return 0;
    220c:	0f 90       	pop	r0
    220e:	df 91       	pop	r29
    2210:	cf 91       	pop	r28
    2212:	1f 91       	pop	r17
    2214:	08 95       	ret

00002216 <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	00 d0       	rcall	.+0      	; 0x221c <Indicator_MainFunction+0x6>
    221c:	1f 92       	push	r1
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
   /* OS Variable used for calculating the function waiting period. */
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    2222:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskGetTickCount>
    2226:	9a 83       	std	Y+2, r25	; 0x02
    2228:	89 83       	std	Y+1, r24	; 0x01
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    222a:	80 91 b8 07 	lds	r24, 0x07B8	; 0x8007b8 <u8_Init.1974>
    222e:	81 11       	cpse	r24, r1
    2230:	07 c0       	rjmp	.+14     	; 0x2240 <Indicator_MainFunction+0x2a>
   {
      LED_Init(LED_UsedChannel);
    2232:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <LED_UsedChannel>
    2236:	0e 94 ad 0a 	call	0x155a	; 0x155a <LED_Init>
      u8_Init = 1;
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <u8_Init.1974>
   }
   
   /* Get the current pattern. */
   Indicator_GetPattern(&u8_Pattern);
    2240:	ce 01       	movw	r24, r28
    2242:	03 96       	adiw	r24, 0x03	; 3
    2244:	0e 94 c8 11 	call	0x2390	; 0x2390 <Indicator_GetPattern>
   
   /* If a new pattern is set. */
   if( u8_Pattern != u8_OldPattern)
    2248:	eb 81       	ldd	r30, Y+3	; 0x03
    224a:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <u8_OldPattern.1976>
    224e:	e8 17       	cp	r30, r24
    2250:	31 f0       	breq	.+12     	; 0x225e <Indicator_MainFunction+0x48>
   {
      u8_OldPattern = u8_Pattern;
    2252:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <u8_OldPattern.1976>
      /* Reinitialize the state and the duty cycle. */
      State = Indicator_LowTime;
    2256:	10 92 b7 07 	sts	0x07B7, r1	; 0x8007b7 <State.1977>
      u8_Duty = MIN_DUTY;
    225a:	10 92 b6 07 	sts	0x07B6, r1	; 0x8007b6 <u8_Duty.1978>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    225e:	e4 30       	cpi	r30, 0x04	; 4
    2260:	09 f4       	brne	.+2      	; 0x2264 <Indicator_MainFunction+0x4e>
    2262:	8a c0       	rjmp	.+276    	; 0x2378 <Indicator_MainFunction+0x162>
   {
      switch(State)
    2264:	80 91 b7 07 	lds	r24, 0x07B7	; 0x8007b7 <State.1977>
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	f9 f0       	breq	.+62     	; 0x22aa <Indicator_MainFunction+0x94>
    226c:	38 f0       	brcs	.+14     	; 0x227c <Indicator_MainFunction+0x66>
    226e:	82 30       	cpi	r24, 0x02	; 2
    2270:	09 f4       	brne	.+2      	; 0x2274 <Indicator_MainFunction+0x5e>
    2272:	40 c0       	rjmp	.+128    	; 0x22f4 <Indicator_MainFunction+0xde>
    2274:	83 30       	cpi	r24, 0x03	; 3
    2276:	09 f4       	brne	.+2      	; 0x227a <Indicator_MainFunction+0x64>
    2278:	54 c0       	rjmp	.+168    	; 0x2322 <Indicator_MainFunction+0x10c>
    227a:	77 c0       	rjmp	.+238    	; 0x236a <Indicator_MainFunction+0x154>
      {
         case Indicator_LowTime:
            /* Turn off led */
            LED_Off(LED_UsedChannel);
    227c:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <LED_UsedChannel>
    2280:	0e 94 13 0b 	call	0x1626	; 0x1626 <LED_Off>
            /* Change state to rise time state. */
            State = Indicator_RiseTime;
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <State.1977>
            /* Put the task in waiting state for the low time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    228a:	eb 81       	ldd	r30, Y+3	; 0x03
    228c:	86 e1       	ldi	r24, 0x16	; 22
    228e:	e8 9f       	mul	r30, r24
    2290:	f0 01       	movw	r30, r0
    2292:	11 24       	eor	r1, r1
    2294:	e4 58       	subi	r30, 0x84	; 132
    2296:	ff 4f       	sbci	r31, 0xFF	; 255
    2298:	60 89       	ldd	r22, Z+16	; 0x10
    229a:	71 89       	ldd	r23, Z+17	; 0x11
    229c:	82 89       	ldd	r24, Z+18	; 0x12
    229e:	93 89       	ldd	r25, Z+19	; 0x13
    22a0:	ce 01       	movw	r24, r28
    22a2:	01 96       	adiw	r24, 0x01	; 1
    22a4:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
            break;
    22a8:	6d c0       	rjmp	.+218    	; 0x2384 <Indicator_MainFunction+0x16e>
         case Indicator_RiseTime:
            /* Increase the duty with the rate of change. */
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    22aa:	86 e1       	ldi	r24, 0x16	; 22
    22ac:	e8 9f       	mul	r30, r24
    22ae:	f0 01       	movw	r30, r0
    22b0:	11 24       	eor	r1, r1
    22b2:	e4 58       	subi	r30, 0x84	; 132
    22b4:	ff 4f       	sbci	r31, 0xFF	; 255
    22b6:	65 89       	ldd	r22, Z+21	; 0x15
    22b8:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <u8_Duty.1978>
    22bc:	68 0f       	add	r22, r24
    22be:	60 93 b6 07 	sts	0x07B6, r22	; 0x8007b6 <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    22c2:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <LED_UsedChannel>
    22c6:	0e 94 8f 0b 	call	0x171e	; 0x171e <LED_Dim>
            /* Change state to high time state. */
            if(u8_Duty == MAX_DUTY)
    22ca:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <u8_Duty.1978>
    22ce:	84 36       	cpi	r24, 0x64	; 100
    22d0:	19 f4       	brne	.+6      	; 0x22d8 <Indicator_MainFunction+0xc2>
            {
               State = Indicator_HighTime;
    22d2:	82 e0       	ldi	r24, 0x02	; 2
    22d4:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	86 e1       	ldi	r24, 0x16	; 22
    22dc:	e8 9f       	mul	r30, r24
    22de:	f0 01       	movw	r30, r0
    22e0:	11 24       	eor	r1, r1
    22e2:	e4 58       	subi	r30, 0x84	; 132
    22e4:	ff 4f       	sbci	r31, 0xFF	; 255
    22e6:	64 89       	ldd	r22, Z+20	; 0x14
    22e8:	70 e0       	ldi	r23, 0x00	; 0
    22ea:	ce 01       	movw	r24, r28
    22ec:	01 96       	adiw	r24, 0x01	; 1
    22ee:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
            break;
    22f2:	48 c0       	rjmp	.+144    	; 0x2384 <Indicator_MainFunction+0x16e>
         case Indicator_HighTime:
            /* Turn led on. */
            LED_On(LED_UsedChannel);
    22f4:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <LED_UsedChannel>
    22f8:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <LED_On>
            /* Change state to fall time state. */
            State = Indicator_FallTime;
    22fc:	83 e0       	ldi	r24, 0x03	; 3
    22fe:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <State.1977>
            /* Put the task in waiting state for the high time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    2302:	eb 81       	ldd	r30, Y+3	; 0x03
    2304:	86 e1       	ldi	r24, 0x16	; 22
    2306:	e8 9f       	mul	r30, r24
    2308:	f0 01       	movw	r30, r0
    230a:	11 24       	eor	r1, r1
    230c:	e4 58       	subi	r30, 0x84	; 132
    230e:	ff 4f       	sbci	r31, 0xFF	; 255
    2310:	64 81       	ldd	r22, Z+4	; 0x04
    2312:	75 81       	ldd	r23, Z+5	; 0x05
    2314:	86 81       	ldd	r24, Z+6	; 0x06
    2316:	97 81       	ldd	r25, Z+7	; 0x07
    2318:	ce 01       	movw	r24, r28
    231a:	01 96       	adiw	r24, 0x01	; 1
    231c:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
            break;
    2320:	31 c0       	rjmp	.+98     	; 0x2384 <Indicator_MainFunction+0x16e>
         case Indicator_FallTime:
            /* decrease the duty with the rate of change. */
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    2322:	86 e1       	ldi	r24, 0x16	; 22
    2324:	e8 9f       	mul	r30, r24
    2326:	f0 01       	movw	r30, r0
    2328:	11 24       	eor	r1, r1
    232a:	e4 58       	subi	r30, 0x84	; 132
    232c:	ff 4f       	sbci	r31, 0xFF	; 255
    232e:	85 89       	ldd	r24, Z+21	; 0x15
    2330:	60 91 b6 07 	lds	r22, 0x07B6	; 0x8007b6 <u8_Duty.1978>
    2334:	68 1b       	sub	r22, r24
    2336:	60 93 b6 07 	sts	0x07B6, r22	; 0x8007b6 <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    233a:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <LED_UsedChannel>
    233e:	0e 94 8f 0b 	call	0x171e	; 0x171e <LED_Dim>
            /* Change state to low time state. */
            if(u8_Duty == MIN_DUTY)
    2342:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <u8_Duty.1978>
    2346:	81 11       	cpse	r24, r1
    2348:	02 c0       	rjmp	.+4      	; 0x234e <Indicator_MainFunction+0x138>
            {
               State = Indicator_LowTime;
    234a:	10 92 b7 07 	sts	0x07B7, r1	; 0x8007b7 <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    234e:	eb 81       	ldd	r30, Y+3	; 0x03
    2350:	86 e1       	ldi	r24, 0x16	; 22
    2352:	e8 9f       	mul	r30, r24
    2354:	f0 01       	movw	r30, r0
    2356:	11 24       	eor	r1, r1
    2358:	e4 58       	subi	r30, 0x84	; 132
    235a:	ff 4f       	sbci	r31, 0xFF	; 255
    235c:	64 89       	ldd	r22, Z+20	; 0x14
    235e:	70 e0       	ldi	r23, 0x00	; 0
    2360:	ce 01       	movw	r24, r28
    2362:	01 96       	adiw	r24, 0x01	; 1
    2364:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
            break;
    2368:	0d c0       	rjmp	.+26     	; 0x2384 <Indicator_MainFunction+0x16e>
         default:
            vTaskDelayUntil(&xLastWakeTime, 10);
    236a:	6a e0       	ldi	r22, 0x0A	; 10
    236c:	70 e0       	ldi	r23, 0x00	; 0
    236e:	ce 01       	movw	r24, r28
    2370:	01 96       	adiw	r24, 0x01	; 1
    2372:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
            break;
    2376:	06 c0       	rjmp	.+12     	; 0x2384 <Indicator_MainFunction+0x16e>
      }
   }
   else
   {
      vTaskDelayUntil(&xLastWakeTime, 10);
    2378:	6a e0       	ldi	r22, 0x0A	; 10
    237a:	70 e0       	ldi	r23, 0x00	; 0
    237c:	ce 01       	movw	r24, r28
    237e:	01 96       	adiw	r24, 0x01	; 1
    2380:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
   }
    2384:	0f 90       	pop	r0
    2386:	0f 90       	pop	r0
    2388:	0f 90       	pop	r0
    238a:	df 91       	pop	r29
    238c:	cf 91       	pop	r28
    238e:	08 95       	ret

00002390 <Indicator_GetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    2390:	00 97       	sbiw	r24, 0x00	; 0
    2392:	31 f0       	breq	.+12     	; 0x23a0 <Indicator_GetPattern+0x10>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      /* Return the indicator pattern. */
      *Value = gu8_IndicatorPattern;
    2394:	20 91 64 00 	lds	r18, 0x0064	; 0x800064 <gu8_IndicatorPattern>
    2398:	fc 01       	movw	r30, r24
    239a:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    239c:	80 e0       	ldi	r24, 0x00	; 0
    239e:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    23a0:	82 eb       	ldi	r24, 0xB2	; 178
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
}
    23a2:	08 95       	ret

000023a4 <DISPLAY_START_SHIFTING>:
	}
	Last_state = State;
}

void DISPLAY_START_SHIFTING(uint8_t stringLength, uint8_t passWordLength)
{
    23a4:	0f 93       	push	r16
    23a6:	1f 93       	push	r17
    23a8:	cf 93       	push	r28
    23aa:	df 93       	push	r29
    23ac:	1f 92       	push	r1
    23ae:	cd b7       	in	r28, 0x3d	; 61
    23b0:	de b7       	in	r29, 0x3e	; 62
    23b2:	16 2f       	mov	r17, r22
	uint8_t volatile StringMotionRange = DISPLAY_WIDTH - stringLength;
    23b4:	90 e1       	ldi	r25, 0x10	; 16
    23b6:	98 1b       	sub	r25, r24
    23b8:	99 83       	std	Y+1, r25	; 0x01
	if(passWordLength>6)
    23ba:	67 30       	cpi	r22, 0x07	; 7
    23bc:	08 f0       	brcs	.+2      	; 0x23c0 <DISPLAY_START_SHIFTING+0x1c>
	{
		passWordLength = 6;
    23be:	16 e0       	ldi	r17, 0x06	; 6
	}
	switch (Shifting_State)
    23c0:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <Shifting_State>
    23c4:	81 30       	cpi	r24, 0x01	; 1
    23c6:	21 f0       	breq	.+8      	; 0x23d0 <DISPLAY_START_SHIFTING+0x2c>
    23c8:	82 30       	cpi	r24, 0x02	; 2
    23ca:	09 f4       	brne	.+2      	; 0x23ce <DISPLAY_START_SHIFTING+0x2a>
    23cc:	45 c0       	rjmp	.+138    	; 0x2458 <DISPLAY_START_SHIFTING+0xb4>
    23ce:	7d c0       	rjmp	.+250    	; 0x24ca <DISPLAY_START_SHIFTING+0x126>
	{
		case ShiftingLeft:
			if(passWordLength!=0)
    23d0:	11 23       	and	r17, r17
    23d2:	69 f1       	breq	.+90     	; 0x242e <DISPLAY_START_SHIFTING+0x8a>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSRIGHT)!= OperationSuccess);
    23d4:	84 e1       	ldi	r24, 0x14	; 20
    23d6:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    23da:	81 11       	cpse	r24, r1
    23dc:	fb cf       	rjmp	.-10     	; 0x23d4 <DISPLAY_START_SHIFTING+0x30>
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
    23de:	80 e1       	ldi	r24, 0x10	; 16
    23e0:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    23e4:	81 11       	cpse	r24, r1
    23e6:	fb cf       	rjmp	.-10     	; 0x23de <DISPLAY_START_SHIFTING+0x3a>
    23e8:	00 e0       	ldi	r16, 0x00	; 0
    23ea:	14 c0       	rjmp	.+40     	; 0x2414 <DISPLAY_START_SHIFTING+0x70>
				for(uint8_t i = 0; i<7; i++)
				{
					if(i < passWordLength+1)
    23ec:	20 2f       	mov	r18, r16
    23ee:	30 e0       	ldi	r19, 0x00	; 0
    23f0:	81 2f       	mov	r24, r17
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	01 96       	adiw	r24, 0x01	; 1
    23f6:	28 17       	cp	r18, r24
    23f8:	39 07       	cpc	r19, r25
    23fa:	34 f4       	brge	.+12     	; 0x2408 <DISPLAY_START_SHIFTING+0x64>
					{
						while(LCD_SendData('*')!= OperationSuccess);
    23fc:	8a e2       	ldi	r24, 0x2A	; 42
    23fe:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2402:	81 11       	cpse	r24, r1
    2404:	fb cf       	rjmp	.-10     	; 0x23fc <DISPLAY_START_SHIFTING+0x58>
    2406:	05 c0       	rjmp	.+10     	; 0x2412 <DISPLAY_START_SHIFTING+0x6e>
					}
					else
					{
						while(LCD_SendData(' ')!= OperationSuccess);
    2408:	80 e2       	ldi	r24, 0x20	; 32
    240a:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    240e:	81 11       	cpse	r24, r1
    2410:	fb cf       	rjmp	.-10     	; 0x2408 <DISPLAY_START_SHIFTING+0x64>
		case ShiftingLeft:
			if(passWordLength!=0)
			{
				while(LCD_SendCommand(LCD_SHIFTCURSRIGHT)!= OperationSuccess);
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
				for(uint8_t i = 0; i<7; i++)
    2412:	0f 5f       	subi	r16, 0xFF	; 255
    2414:	07 30       	cpi	r16, 0x07	; 7
    2416:	50 f3       	brcs	.-44     	; 0x23ec <DISPLAY_START_SHIFTING+0x48>
    2418:	10 e0       	ldi	r17, 0x00	; 0
    241a:	06 c0       	rjmp	.+12     	; 0x2428 <DISPLAY_START_SHIFTING+0x84>
						while(LCD_SendData(' ')!= OperationSuccess);
					}
				}
				for(uint8_t i = 0; i < 6; i++)
				{
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
    241c:	80 e1       	ldi	r24, 0x10	; 16
    241e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2422:	81 11       	cpse	r24, r1
    2424:	fb cf       	rjmp	.-10     	; 0x241c <DISPLAY_START_SHIFTING+0x78>
					else
					{
						while(LCD_SendData(' ')!= OperationSuccess);
					}
				}
				for(uint8_t i = 0; i < 6; i++)
    2426:	1f 5f       	subi	r17, 0xFF	; 255
    2428:	16 30       	cpi	r17, 0x06	; 6
    242a:	c0 f3       	brcs	.-16     	; 0x241c <DISPLAY_START_SHIFTING+0x78>
    242c:	05 c0       	rjmp	.+10     	; 0x2438 <DISPLAY_START_SHIFTING+0x94>
				}
			}
			else
			{
				//while(LCD_SendCommand(LCD_SHIFTCURSRIGHT)!= OperationSuccess);
				while(LCD_SendData(' ')!= OperationSuccess);
    242e:	80 e2       	ldi	r24, 0x20	; 32
    2430:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2434:	81 11       	cpse	r24, r1
    2436:	fb cf       	rjmp	.-10     	; 0x242e <DISPLAY_START_SHIFTING+0x8a>
			}
			while(LCD_SendCommand(LCD_SHIFTDISPLEFT)!= OperationSuccess);
    2438:	88 e1       	ldi	r24, 0x18	; 24
    243a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    243e:	81 11       	cpse	r24, r1
    2440:	fb cf       	rjmp	.-10     	; 0x2438 <DISPLAY_START_SHIFTING+0x94>
			Position--;
    2442:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <Position>
    2446:	81 50       	subi	r24, 0x01	; 1
    2448:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <Position>
			if (Position == 0)
    244c:	81 11       	cpse	r24, r1
    244e:	3d c0       	rjmp	.+122    	; 0x24ca <DISPLAY_START_SHIFTING+0x126>
			{
				Shifting_State = ShiftingRight;
    2450:	82 e0       	ldi	r24, 0x02	; 2
    2452:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
    2456:	39 c0       	rjmp	.+114    	; 0x24ca <DISPLAY_START_SHIFTING+0x126>
			}
			break;
		case ShiftingRight:
			if(passWordLength!=0)
    2458:	11 23       	and	r17, r17
    245a:	11 f1       	breq	.+68     	; 0x24a0 <DISPLAY_START_SHIFTING+0xfc>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
    245c:	80 e1       	ldi	r24, 0x10	; 16
    245e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2462:	81 11       	cpse	r24, r1
    2464:	fb cf       	rjmp	.-10     	; 0x245c <DISPLAY_START_SHIFTING+0xb8>
    2466:	00 e0       	ldi	r16, 0x00	; 0
    2468:	0e c0       	rjmp	.+28     	; 0x2486 <DISPLAY_START_SHIFTING+0xe2>
				for(uint8_t i = 0; i < 7; i++)
				{
					if(i < passWordLength)
    246a:	01 17       	cp	r16, r17
    246c:	30 f4       	brcc	.+12     	; 0x247a <DISPLAY_START_SHIFTING+0xd6>
					{
						while(LCD_SendData('*')!= OperationSuccess);						
    246e:	8a e2       	ldi	r24, 0x2A	; 42
    2470:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2474:	81 11       	cpse	r24, r1
    2476:	fb cf       	rjmp	.-10     	; 0x246e <DISPLAY_START_SHIFTING+0xca>
    2478:	05 c0       	rjmp	.+10     	; 0x2484 <DISPLAY_START_SHIFTING+0xe0>
					}
					else
					{
						while(LCD_SendData(' ')!= OperationSuccess);
    247a:	80 e2       	ldi	r24, 0x20	; 32
    247c:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2480:	81 11       	cpse	r24, r1
    2482:	fb cf       	rjmp	.-10     	; 0x247a <DISPLAY_START_SHIFTING+0xd6>
			break;
		case ShiftingRight:
			if(passWordLength!=0)
			{
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
				for(uint8_t i = 0; i < 7; i++)
    2484:	0f 5f       	subi	r16, 0xFF	; 255
    2486:	07 30       	cpi	r16, 0x07	; 7
    2488:	80 f3       	brcs	.-32     	; 0x246a <DISPLAY_START_SHIFTING+0xc6>
    248a:	10 e0       	ldi	r17, 0x00	; 0
    248c:	06 c0       	rjmp	.+12     	; 0x249a <DISPLAY_START_SHIFTING+0xf6>
					}
				}
				
				for(uint8_t i = 0; i < 7; i++)
				{
						while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);
    248e:	80 e1       	ldi	r24, 0x10	; 16
    2490:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2494:	81 11       	cpse	r24, r1
    2496:	fb cf       	rjmp	.-10     	; 0x248e <DISPLAY_START_SHIFTING+0xea>
					{
						while(LCD_SendData(' ')!= OperationSuccess);
					}
				}
				
				for(uint8_t i = 0; i < 7; i++)
    2498:	1f 5f       	subi	r17, 0xFF	; 255
    249a:	17 30       	cpi	r17, 0x07	; 7
    249c:	c0 f3       	brcs	.-16     	; 0x248e <DISPLAY_START_SHIFTING+0xea>
    249e:	05 c0       	rjmp	.+10     	; 0x24aa <DISPLAY_START_SHIFTING+0x106>
				}
				
			}
			else
			{
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!= OperationSuccess);				
    24a0:	80 e1       	ldi	r24, 0x10	; 16
    24a2:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    24a6:	81 11       	cpse	r24, r1
    24a8:	fb cf       	rjmp	.-10     	; 0x24a0 <DISPLAY_START_SHIFTING+0xfc>
			}
			while(LCD_SendCommand(LCD_SHIFTDISPRIGHT)!= OperationSuccess);
    24aa:	8c e1       	ldi	r24, 0x1C	; 28
    24ac:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    24b0:	81 11       	cpse	r24, r1
    24b2:	fb cf       	rjmp	.-10     	; 0x24aa <DISPLAY_START_SHIFTING+0x106>
			Position++;
    24b4:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <Position>
    24b8:	8f 5f       	subi	r24, 0xFF	; 255
    24ba:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <Position>
			if (Position >= StringMotionRange)
    24be:	99 81       	ldd	r25, Y+1	; 0x01
    24c0:	89 17       	cp	r24, r25
    24c2:	18 f0       	brcs	.+6      	; 0x24ca <DISPLAY_START_SHIFTING+0x126>
			{
				Shifting_State = ShiftingLeft;
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			break;
	}
}
    24ca:	0f 90       	pop	r0
    24cc:	df 91       	pop	r29
    24ce:	cf 91       	pop	r28
    24d0:	1f 91       	pop	r17
    24d2:	0f 91       	pop	r16
    24d4:	08 95       	ret

000024d6 <DISPLAY_MainFunction>:
uint8_t LastShiftingState = OperationStarted;
uint8_t WrongPassEntries = 0;
uint32_t RemainingSeconds = 0;

void DISPLAY_MainFunction(void)
{
    24d6:	cf 92       	push	r12
    24d8:	df 92       	push	r13
    24da:	ef 92       	push	r14
    24dc:	ff 92       	push	r15
    24de:	1f 93       	push	r17
    24e0:	cf 93       	push	r28
    24e2:	df 93       	push	r29
    24e4:	1f 92       	push	r1
    24e6:	cd b7       	in	r28, 0x3d	; 61
    24e8:	de b7       	in	r29, 0x3e	; 62
	uint8_t static Last_state = OperationStarted;
	uint8_t static Counter = 0;
	uint8_t State =0;
    24ea:	19 82       	std	Y+1, r1	; 0x01
	DISPLAY_GetNumber_of_Asterisk(&Number_of_Asteriks);
    24ec:	8f eb       	ldi	r24, 0xBF	; 191
    24ee:	97 e0       	ldi	r25, 0x07	; 7
    24f0:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <DISPLAY_GetNumber_of_Asterisk>
	DISPLAY_GetState(&State);
    24f4:	ce 01       	movw	r24, r28
    24f6:	01 96       	adiw	r24, 0x01	; 1
    24f8:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <DISPLAY_GetState>
	if((Last_state == CorrectPassword || Last_state == WrongPassword || Last_state == Waiting)&&(Counter!=0))
    24fc:	20 91 65 00 	lds	r18, 0x0065	; 0x800065 <Last_state.1753>
    2500:	8a ef       	ldi	r24, 0xFA	; 250
    2502:	82 0f       	add	r24, r18
    2504:	83 30       	cpi	r24, 0x03	; 3
    2506:	20 f4       	brcc	.+8      	; 0x2510 <DISPLAY_MainFunction+0x3a>
    2508:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <Counter.1754>
    250c:	81 11       	cpse	r24, r1
	{
		State = Last_state;
    250e:	29 83       	std	Y+1, r18	; 0x01
	}
	switch(State)
    2510:	39 81       	ldd	r19, Y+1	; 0x01
    2512:	83 2f       	mov	r24, r19
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	fc 01       	movw	r30, r24
    2518:	33 97       	sbiw	r30, 0x03	; 3
    251a:	e8 30       	cpi	r30, 0x08	; 8
    251c:	f1 05       	cpc	r31, r1
    251e:	08 f0       	brcs	.+2      	; 0x2522 <DISPLAY_MainFunction+0x4c>
    2520:	ca c2       	rjmp	.+1428   	; 0x2ab6 <DISPLAY_MainFunction+0x5e0>
    2522:	ef 5c       	subi	r30, 0xCF	; 207
    2524:	ff 4f       	sbci	r31, 0xFF	; 255
    2526:	0c 94 b7 18 	jmp	0x316e	; 0x316e <__tablejump2__>
	{
		case SystemLoading:
			if(Last_state != State)
    252a:	23 17       	cp	r18, r19
    252c:	a9 f0       	breq	.+42     	; 0x2558 <DISPLAY_MainFunction+0x82>
			{
				Position = 0;
    252e:	10 92 c0 07 	sts	0x07C0, r1	; 0x8007c0 <Position>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2538:	81 11       	cpse	r24, r1
    253a:	fb cf       	rjmp	.-10     	; 0x2532 <DISPLAY_MainFunction+0x5c>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    253c:	82 e0       	ldi	r24, 0x02	; 2
    253e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2542:	81 11       	cpse	r24, r1
    2544:	fb cf       	rjmp	.-10     	; 0x253c <DISPLAY_MainFunction+0x66>
				while(LCD_SendString((uint8_t*)"System Loading") != OperationSuccess);
    2546:	85 ed       	ldi	r24, 0xD5	; 213
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    254e:	81 11       	cpse	r24, r1
    2550:	fa cf       	rjmp	.-12     	; 0x2546 <DISPLAY_MainFunction+0x70>
				Shifting_State = ShiftingRight;
    2552:	82 e0       	ldi	r24, 0x02	; 2
    2554:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			DISPLAY_START_SHIFTING(SystemLoading_StringWidth,0);
    2558:	60 e0       	ldi	r22, 0x00	; 0
    255a:	8e e0       	ldi	r24, 0x0E	; 14
    255c:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			break;
    2560:	af c2       	rjmp	.+1374   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
		case Welcome:
			if(Last_state != State)
    2562:	23 17       	cp	r18, r19
    2564:	a9 f0       	breq	.+42     	; 0x2590 <DISPLAY_MainFunction+0xba>
			{
				Position = 0;
    2566:	10 92 c0 07 	sts	0x07C0, r1	; 0x8007c0 <Position>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2570:	81 11       	cpse	r24, r1
    2572:	fb cf       	rjmp	.-10     	; 0x256a <DISPLAY_MainFunction+0x94>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    2574:	82 e0       	ldi	r24, 0x02	; 2
    2576:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    257a:	81 11       	cpse	r24, r1
    257c:	fb cf       	rjmp	.-10     	; 0x2574 <DISPLAY_MainFunction+0x9e>
				while(LCD_SendString((uint8_t*)"WELCOME") != OperationSuccess);
    257e:	84 ee       	ldi	r24, 0xE4	; 228
    2580:	90 e0       	ldi	r25, 0x00	; 0
    2582:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    2586:	81 11       	cpse	r24, r1
    2588:	fa cf       	rjmp	.-12     	; 0x257e <DISPLAY_MainFunction+0xa8>
				Shifting_State = ShiftingRight;
    258a:	82 e0       	ldi	r24, 0x02	; 2
    258c:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			DISPLAY_START_SHIFTING(Welcome_StringWidth,0);
    2590:	60 e0       	ldi	r22, 0x00	; 0
    2592:	87 e0       	ldi	r24, 0x07	; 7
    2594:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			break;
    2598:	93 c2       	rjmp	.+1318   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
		case PassEntering:
			if(Last_state != State)
    259a:	23 17       	cp	r18, r19
    259c:	11 f1       	breq	.+68     	; 0x25e2 <DISPLAY_MainFunction+0x10c>
			{
				//DISPLAY_SetNumber_of_Asterisk(0);
				Position = DISPLAY_WIDTH-EnterPass_StringWidth;
    259e:	86 e0       	ldi	r24, 0x06	; 6
    25a0:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <Position>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    25a4:	81 e0       	ldi	r24, 0x01	; 1
    25a6:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    25aa:	81 11       	cpse	r24, r1
    25ac:	fb cf       	rjmp	.-10     	; 0x25a4 <DISPLAY_MainFunction+0xce>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    25ae:	82 e0       	ldi	r24, 0x02	; 2
    25b0:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    25b4:	81 11       	cpse	r24, r1
    25b6:	fb cf       	rjmp	.-10     	; 0x25ae <DISPLAY_MainFunction+0xd8>
				while (LCD_SendCommand(LCD_CURS_Position0|Position)!=OperationSuccess);
    25b8:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <Position>
    25bc:	80 68       	ori	r24, 0x80	; 128
    25be:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    25c2:	81 11       	cpse	r24, r1
    25c4:	f9 cf       	rjmp	.-14     	; 0x25b8 <DISPLAY_MainFunction+0xe2>
				while (LCD_SendString((uint8_t*)"Enter Pass") != OperationSuccess);
    25c6:	8c ee       	ldi	r24, 0xEC	; 236
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    25ce:	81 11       	cpse	r24, r1
    25d0:	fa cf       	rjmp	.-12     	; 0x25c6 <DISPLAY_MainFunction+0xf0>
				Shifting_State = ShiftingLeft;
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
				while (LCD_SendCommand(LCD_CURS_LINE2)!=OperationSuccess);
    25d8:	80 ec       	ldi	r24, 0xC0	; 192
    25da:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    25de:	81 11       	cpse	r24, r1
    25e0:	fb cf       	rjmp	.-10     	; 0x25d8 <DISPLAY_MainFunction+0x102>
					{
						break;
					}
				}*/
			}
			DISPLAY_START_SHIFTING(EnterPass_StringWidth,Number_of_Asteriks);
    25e2:	60 91 bf 07 	lds	r22, 0x07BF	; 0x8007bf <Number_of_Asteriks>
    25e6:	8a e0       	ldi	r24, 0x0A	; 10
    25e8:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			break;
    25ec:	69 c2       	rjmp	.+1234   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
		case CorrectPassword:
			if(Last_state != State)
    25ee:	23 17       	cp	r18, r19
    25f0:	c1 f0       	breq	.+48     	; 0x2622 <DISPLAY_MainFunction+0x14c>
			{
				Position = 0;
    25f2:	10 92 c0 07 	sts	0x07C0, r1	; 0x8007c0 <Position>
				DISPLAY_SetNumber_of_Asterisk(0);
    25f6:	80 e0       	ldi	r24, 0x00	; 0
    25f8:	0e 94 79 15 	call	0x2af2	; 0x2af2 <DISPLAY_SetNumber_of_Asterisk>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    25fc:	81 e0       	ldi	r24, 0x01	; 1
    25fe:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2602:	81 11       	cpse	r24, r1
    2604:	fb cf       	rjmp	.-10     	; 0x25fc <DISPLAY_MainFunction+0x126>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    2606:	82 e0       	ldi	r24, 0x02	; 2
    2608:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    260c:	81 11       	cpse	r24, r1
    260e:	fb cf       	rjmp	.-10     	; 0x2606 <DISPLAY_MainFunction+0x130>
				while (LCD_SendString((uint8_t*)"Pass OK") != OperationSuccess);
    2610:	87 ef       	ldi	r24, 0xF7	; 247
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    2618:	81 11       	cpse	r24, r1
    261a:	fa cf       	rjmp	.-12     	; 0x2610 <DISPLAY_MainFunction+0x13a>
				Shifting_State = ShiftingRight;
    261c:	82 e0       	ldi	r24, 0x02	; 2
    261e:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			DISPLAY_START_SHIFTING(CorrectPass_StringWidth,0);
    2622:	60 e0       	ldi	r22, 0x00	; 0
    2624:	87 e0       	ldi	r24, 0x07	; 7
    2626:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			Counter ++;
    262a:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <Counter.1754>
    262e:	8f 5f       	subi	r24, 0xFF	; 255
    2630:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <Counter.1754>
			if(Counter == (uint8_t)(TwoSeconds/MainFunction_Periodicity))
    2634:	88 32       	cpi	r24, 0x28	; 40
    2636:	09 f0       	breq	.+2      	; 0x263a <DISPLAY_MainFunction+0x164>
    2638:	43 c2       	rjmp	.+1158   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			{
				WrongPassEntries = 0;
    263a:	10 92 be 07 	sts	0x07BE, r1	; 0x8007be <WrongPassEntries>
				Counter = 0;
    263e:	10 92 b9 07 	sts	0x07B9, r1	; 0x8007b9 <Counter.1754>
				DISPLAY_SetState(SevenSegments);
    2642:	89 e0       	ldi	r24, 0x09	; 9
    2644:	0e 94 76 15 	call	0x2aec	; 0x2aec <DISPLAY_SetState>
    2648:	3b c2       	rjmp	.+1142   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			}
			break;
		/*Counter*/
		case WrongPassword:
			if(Last_state != State)
    264a:	23 17       	cp	r18, r19
    264c:	c1 f0       	breq	.+48     	; 0x267e <DISPLAY_MainFunction+0x1a8>
			{
				Position = 0;
    264e:	10 92 c0 07 	sts	0x07C0, r1	; 0x8007c0 <Position>
				DISPLAY_SetNumber_of_Asterisk(0);
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	0e 94 79 15 	call	0x2af2	; 0x2af2 <DISPLAY_SetNumber_of_Asterisk>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    265e:	81 11       	cpse	r24, r1
    2660:	fb cf       	rjmp	.-10     	; 0x2658 <DISPLAY_MainFunction+0x182>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    2662:	82 e0       	ldi	r24, 0x02	; 2
    2664:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2668:	81 11       	cpse	r24, r1
    266a:	fb cf       	rjmp	.-10     	; 0x2662 <DISPLAY_MainFunction+0x18c>
				while (LCD_SendString((uint8_t*)"Wrong Pass") != OperationSuccess);
    266c:	8f ef       	ldi	r24, 0xFF	; 255
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    2674:	81 11       	cpse	r24, r1
    2676:	fa cf       	rjmp	.-12     	; 0x266c <DISPLAY_MainFunction+0x196>
				Shifting_State = ShiftingRight;
    2678:	82 e0       	ldi	r24, 0x02	; 2
    267a:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			DISPLAY_START_SHIFTING(WrongPass_StringWidth,0);
    267e:	60 e0       	ldi	r22, 0x00	; 0
    2680:	8a e0       	ldi	r24, 0x0A	; 10
    2682:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			Counter ++;
    2686:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <Counter.1754>
    268a:	8f 5f       	subi	r24, 0xFF	; 255
    268c:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <Counter.1754>
			if(Counter == (uint8_t)(TwoSeconds/MainFunction_Periodicity))
    2690:	88 32       	cpi	r24, 0x28	; 40
    2692:	09 f0       	breq	.+2      	; 0x2696 <DISPLAY_MainFunction+0x1c0>
    2694:	15 c2       	rjmp	.+1066   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			{
				Counter = 0;
    2696:	10 92 b9 07 	sts	0x07B9, r1	; 0x8007b9 <Counter.1754>
				WrongPassEntries++;
    269a:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <WrongPassEntries>
    269e:	8f 5f       	subi	r24, 0xFF	; 255
    26a0:	80 93 be 07 	sts	0x07BE, r24	; 0x8007be <WrongPassEntries>
				if(WrongPassEntries==3)
    26a4:	83 30       	cpi	r24, 0x03	; 3
    26a6:	21 f4       	brne	.+8      	; 0x26b0 <DISPLAY_MainFunction+0x1da>
					DISPLAY_SetState(Waiting);
    26a8:	88 e0       	ldi	r24, 0x08	; 8
    26aa:	0e 94 76 15 	call	0x2aec	; 0x2aec <DISPLAY_SetState>
    26ae:	08 c2       	rjmp	.+1040   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
				else
					DISPLAY_SetState(PassEntering);
    26b0:	85 e0       	ldi	r24, 0x05	; 5
    26b2:	0e 94 76 15 	call	0x2aec	; 0x2aec <DISPLAY_SetState>
    26b6:	04 c2       	rjmp	.+1032   	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			}
			break;
		case Waiting:
			if(Last_state != State)
    26b8:	23 17       	cp	r18, r19
    26ba:	39 f1       	breq	.+78     	; 0x270a <DISPLAY_MainFunction+0x234>
			{
				Position = DISPLAY_WIDTH - Waiting_StringWidth;
    26bc:	89 e0       	ldi	r24, 0x09	; 9
    26be:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <Position>
				DISPLAY_SetNumber_of_Asterisk(0);
    26c2:	80 e0       	ldi	r24, 0x00	; 0
    26c4:	0e 94 79 15 	call	0x2af2	; 0x2af2 <DISPLAY_SetNumber_of_Asterisk>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    26ce:	81 11       	cpse	r24, r1
    26d0:	fb cf       	rjmp	.-10     	; 0x26c8 <DISPLAY_MainFunction+0x1f2>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    26d2:	82 e0       	ldi	r24, 0x02	; 2
    26d4:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    26d8:	81 11       	cpse	r24, r1
    26da:	fb cf       	rjmp	.-10     	; 0x26d2 <DISPLAY_MainFunction+0x1fc>
				while (LCD_SendCommand(LCD_CURS_Position0|Position)!=OperationSuccess);
    26dc:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <Position>
    26e0:	80 68       	ori	r24, 0x80	; 128
    26e2:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    26e6:	81 11       	cpse	r24, r1
    26e8:	f9 cf       	rjmp	.-14     	; 0x26dc <DISPLAY_MainFunction+0x206>
				while (LCD_SendString((uint8_t*)"Waiting") != OperationSuccess);
    26ea:	8a e0       	ldi	r24, 0x0A	; 10
    26ec:	91 e0       	ldi	r25, 0x01	; 1
    26ee:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    26f2:	81 11       	cpse	r24, r1
    26f4:	fa cf       	rjmp	.-12     	; 0x26ea <DISPLAY_MainFunction+0x214>
				Shifting_State = ShiftingLeft;
    26f6:	81 e0       	ldi	r24, 0x01	; 1
    26f8:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
				LastShiftingState = Shifting_State;
    26fc:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <LastShiftingState>
				while (LCD_SendCommand(LCD_CURS_LINE2)!=OperationSuccess);
    2700:	80 ec       	ldi	r24, 0xC0	; 192
    2702:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2706:	81 11       	cpse	r24, r1
    2708:	fb cf       	rjmp	.-10     	; 0x2700 <DISPLAY_MainFunction+0x22a>
			}
			RemainingSeconds = ((TenSeconds-(Counter*MainFunction_Periodicity))/1000);
    270a:	10 91 b9 07 	lds	r17, 0x07B9	; 0x8007b9 <Counter.1754>
    270e:	21 2f       	mov	r18, r17
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	a2 e3       	ldi	r26, 0x32	; 50
    2714:	b0 e0       	ldi	r27, 0x00	; 0
    2716:	0e 94 bd 18 	call	0x317a	; 0x317a <__umulhisi3>
    271a:	0f 2e       	mov	r0, r31
    271c:	f0 e1       	ldi	r31, 0x10	; 16
    271e:	cf 2e       	mov	r12, r31
    2720:	f7 e2       	ldi	r31, 0x27	; 39
    2722:	df 2e       	mov	r13, r31
    2724:	e1 2c       	mov	r14, r1
    2726:	f1 2c       	mov	r15, r1
    2728:	f0 2d       	mov	r31, r0
    272a:	a7 01       	movw	r20, r14
    272c:	96 01       	movw	r18, r12
    272e:	26 1b       	sub	r18, r22
    2730:	37 0b       	sbc	r19, r23
    2732:	48 0b       	sbc	r20, r24
    2734:	59 0b       	sbc	r21, r25
    2736:	ca 01       	movw	r24, r20
    2738:	b9 01       	movw	r22, r18
    273a:	28 ee       	ldi	r18, 0xE8	; 232
    273c:	33 e0       	ldi	r19, 0x03	; 3
    273e:	40 e0       	ldi	r20, 0x00	; 0
    2740:	50 e0       	ldi	r21, 0x00	; 0
    2742:	0e 94 95 18 	call	0x312a	; 0x312a <__udivmodsi4>
    2746:	20 93 ba 07 	sts	0x07BA, r18	; 0x8007ba <RemainingSeconds>
    274a:	30 93 bb 07 	sts	0x07BB, r19	; 0x8007bb <RemainingSeconds+0x1>
    274e:	40 93 bc 07 	sts	0x07BC, r20	; 0x8007bc <RemainingSeconds+0x2>
    2752:	50 93 bd 07 	sts	0x07BD, r21	; 0x8007bd <RemainingSeconds+0x3>
			Counter ++;
    2756:	1f 5f       	subi	r17, 0xFF	; 255
    2758:	10 93 b9 07 	sts	0x07B9, r17	; 0x8007b9 <Counter.1754>
			DISPLAY_START_SHIFTING(Waiting_StringWidth,0);
    275c:	60 e0       	ldi	r22, 0x00	; 0
    275e:	87 e0       	ldi	r24, 0x07	; 7
    2760:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			if((Shifting_State == ShiftingLeft) && (LastShiftingState == ShiftingLeft))
    2764:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <Shifting_State>
    2768:	81 30       	cpi	r24, 0x01	; 1
    276a:	09 f0       	breq	.+2      	; 0x276e <DISPLAY_MainFunction+0x298>
    276c:	4f c0       	rjmp	.+158    	; 0x280c <DISPLAY_MainFunction+0x336>
    276e:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <LastShiftingState>
    2772:	91 30       	cpi	r25, 0x01	; 1
    2774:	09 f0       	breq	.+2      	; 0x2778 <DISPLAY_MainFunction+0x2a2>
    2776:	4a c0       	rjmp	.+148    	; 0x280c <DISPLAY_MainFunction+0x336>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSRIGHT)!=OperationSuccess);
    2778:	84 e1       	ldi	r24, 0x14	; 20
    277a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    277e:	81 11       	cpse	r24, r1
    2780:	fb cf       	rjmp	.-10     	; 0x2778 <DISPLAY_MainFunction+0x2a2>
				LCD_SendNumber(RemainingSeconds);
    2782:	60 91 ba 07 	lds	r22, 0x07BA	; 0x8007ba <RemainingSeconds>
    2786:	70 91 bb 07 	lds	r23, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    278a:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    278e:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    2792:	0e 94 86 0a 	call	0x150c	; 0x150c <LCD_SendNumber>
				if(RemainingSeconds/10)
    2796:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <RemainingSeconds>
    279a:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    279e:	a0 91 bc 07 	lds	r26, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    27a2:	b0 91 bd 07 	lds	r27, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    27a6:	0a 97       	sbiw	r24, 0x0a	; 10
    27a8:	a1 05       	cpc	r26, r1
    27aa:	b1 05       	cpc	r27, r1
    27ac:	a8 f0       	brcs	.+42     	; 0x27d8 <DISPLAY_MainFunction+0x302>
				{
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    27ae:	80 e2       	ldi	r24, 0x20	; 32
    27b0:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    27b4:	81 11       	cpse	r24, r1
    27b6:	fb cf       	rjmp	.-10     	; 0x27ae <DISPLAY_MainFunction+0x2d8>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    27b8:	80 e1       	ldi	r24, 0x10	; 16
    27ba:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    27be:	81 11       	cpse	r24, r1
    27c0:	fb cf       	rjmp	.-10     	; 0x27b8 <DISPLAY_MainFunction+0x2e2>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    27c2:	80 e1       	ldi	r24, 0x10	; 16
    27c4:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    27c8:	81 11       	cpse	r24, r1
    27ca:	fb cf       	rjmp	.-10     	; 0x27c2 <DISPLAY_MainFunction+0x2ec>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    27cc:	80 e1       	ldi	r24, 0x10	; 16
    27ce:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    27d2:	81 11       	cpse	r24, r1
    27d4:	fb cf       	rjmp	.-10     	; 0x27cc <DISPLAY_MainFunction+0x2f6>
    27d6:	0f c1       	rjmp	.+542    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
				else
				{
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    27d8:	80 e2       	ldi	r24, 0x20	; 32
    27da:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    27de:	81 11       	cpse	r24, r1
    27e0:	fb cf       	rjmp	.-10     	; 0x27d8 <DISPLAY_MainFunction+0x302>
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    27e2:	80 e2       	ldi	r24, 0x20	; 32
    27e4:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    27e8:	81 11       	cpse	r24, r1
    27ea:	fb cf       	rjmp	.-10     	; 0x27e2 <DISPLAY_MainFunction+0x30c>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    27ec:	80 e1       	ldi	r24, 0x10	; 16
    27ee:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    27f2:	81 11       	cpse	r24, r1
    27f4:	fb cf       	rjmp	.-10     	; 0x27ec <DISPLAY_MainFunction+0x316>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    27f6:	80 e1       	ldi	r24, 0x10	; 16
    27f8:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    27fc:	81 11       	cpse	r24, r1
    27fe:	fb cf       	rjmp	.-10     	; 0x27f6 <DISPLAY_MainFunction+0x320>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2800:	80 e1       	ldi	r24, 0x10	; 16
    2802:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2806:	81 11       	cpse	r24, r1
    2808:	fb cf       	rjmp	.-10     	; 0x2800 <DISPLAY_MainFunction+0x32a>
    280a:	f5 c0       	rjmp	.+490    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
			}
			else if ((Shifting_State == ShiftingRight) && (LastShiftingState == ShiftingRight))
    280c:	82 30       	cpi	r24, 0x02	; 2
    280e:	09 f0       	breq	.+2      	; 0x2812 <DISPLAY_MainFunction+0x33c>
    2810:	4f c0       	rjmp	.+158    	; 0x28b0 <DISPLAY_MainFunction+0x3da>
    2812:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <LastShiftingState>
    2816:	92 30       	cpi	r25, 0x02	; 2
    2818:	09 f0       	breq	.+2      	; 0x281c <DISPLAY_MainFunction+0x346>
    281a:	4a c0       	rjmp	.+148    	; 0x28b0 <DISPLAY_MainFunction+0x3da>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    281c:	80 e1       	ldi	r24, 0x10	; 16
    281e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2822:	81 11       	cpse	r24, r1
    2824:	fb cf       	rjmp	.-10     	; 0x281c <DISPLAY_MainFunction+0x346>
				LCD_SendNumber(RemainingSeconds);
    2826:	60 91 ba 07 	lds	r22, 0x07BA	; 0x8007ba <RemainingSeconds>
    282a:	70 91 bb 07 	lds	r23, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    282e:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    2832:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    2836:	0e 94 86 0a 	call	0x150c	; 0x150c <LCD_SendNumber>
				if(RemainingSeconds/10)
    283a:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <RemainingSeconds>
    283e:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    2842:	a0 91 bc 07 	lds	r26, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    2846:	b0 91 bd 07 	lds	r27, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    284a:	0a 97       	sbiw	r24, 0x0a	; 10
    284c:	a1 05       	cpc	r26, r1
    284e:	b1 05       	cpc	r27, r1
    2850:	a8 f0       	brcs	.+42     	; 0x287c <DISPLAY_MainFunction+0x3a6>
				{
					while(LCD_SendData(' ')!=OperationSuccess);
    2852:	80 e2       	ldi	r24, 0x20	; 32
    2854:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2858:	81 11       	cpse	r24, r1
    285a:	fb cf       	rjmp	.-10     	; 0x2852 <DISPLAY_MainFunction+0x37c>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    285c:	80 e1       	ldi	r24, 0x10	; 16
    285e:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2862:	81 11       	cpse	r24, r1
    2864:	fb cf       	rjmp	.-10     	; 0x285c <DISPLAY_MainFunction+0x386>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2866:	80 e1       	ldi	r24, 0x10	; 16
    2868:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    286c:	81 11       	cpse	r24, r1
    286e:	fb cf       	rjmp	.-10     	; 0x2866 <DISPLAY_MainFunction+0x390>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2870:	80 e1       	ldi	r24, 0x10	; 16
    2872:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2876:	81 11       	cpse	r24, r1
    2878:	fb cf       	rjmp	.-10     	; 0x2870 <DISPLAY_MainFunction+0x39a>
    287a:	bd c0       	rjmp	.+378    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
				else
				{
					while(LCD_SendData(' ')!=OperationSuccess);
    287c:	80 e2       	ldi	r24, 0x20	; 32
    287e:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2882:	81 11       	cpse	r24, r1
    2884:	fb cf       	rjmp	.-10     	; 0x287c <DISPLAY_MainFunction+0x3a6>
					while(LCD_SendData(' ')!=OperationSuccess);
    2886:	80 e2       	ldi	r24, 0x20	; 32
    2888:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    288c:	81 11       	cpse	r24, r1
    288e:	fb cf       	rjmp	.-10     	; 0x2886 <DISPLAY_MainFunction+0x3b0>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2890:	80 e1       	ldi	r24, 0x10	; 16
    2892:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2896:	81 11       	cpse	r24, r1
    2898:	fb cf       	rjmp	.-10     	; 0x2890 <DISPLAY_MainFunction+0x3ba>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    289a:	80 e1       	ldi	r24, 0x10	; 16
    289c:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    28a0:	81 11       	cpse	r24, r1
    28a2:	fb cf       	rjmp	.-10     	; 0x289a <DISPLAY_MainFunction+0x3c4>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    28a4:	80 e1       	ldi	r24, 0x10	; 16
    28a6:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    28aa:	81 11       	cpse	r24, r1
    28ac:	fb cf       	rjmp	.-10     	; 0x28a4 <DISPLAY_MainFunction+0x3ce>
    28ae:	a3 c0       	rjmp	.+326    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
			}
			else if ((Shifting_State == ShiftingRight) && (LastShiftingState == ShiftingLeft))
    28b0:	82 30       	cpi	r24, 0x02	; 2
    28b2:	09 f0       	breq	.+2      	; 0x28b6 <DISPLAY_MainFunction+0x3e0>
    28b4:	4f c0       	rjmp	.+158    	; 0x2954 <DISPLAY_MainFunction+0x47e>
    28b6:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <LastShiftingState>
    28ba:	91 30       	cpi	r25, 0x01	; 1
    28bc:	09 f0       	breq	.+2      	; 0x28c0 <DISPLAY_MainFunction+0x3ea>
    28be:	4a c0       	rjmp	.+148    	; 0x2954 <DISPLAY_MainFunction+0x47e>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSRIGHT)!=OperationSuccess);
    28c0:	84 e1       	ldi	r24, 0x14	; 20
    28c2:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    28c6:	81 11       	cpse	r24, r1
    28c8:	fb cf       	rjmp	.-10     	; 0x28c0 <DISPLAY_MainFunction+0x3ea>
				LCD_SendNumber(RemainingSeconds);
    28ca:	60 91 ba 07 	lds	r22, 0x07BA	; 0x8007ba <RemainingSeconds>
    28ce:	70 91 bb 07 	lds	r23, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    28d2:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    28d6:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    28da:	0e 94 86 0a 	call	0x150c	; 0x150c <LCD_SendNumber>
				if(RemainingSeconds/10)
    28de:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <RemainingSeconds>
    28e2:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    28e6:	a0 91 bc 07 	lds	r26, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    28ea:	b0 91 bd 07 	lds	r27, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    28ee:	0a 97       	sbiw	r24, 0x0a	; 10
    28f0:	a1 05       	cpc	r26, r1
    28f2:	b1 05       	cpc	r27, r1
    28f4:	a8 f0       	brcs	.+42     	; 0x2920 <DISPLAY_MainFunction+0x44a>
				{
					while(LCD_SendData(' ')!=OperationSuccess);
    28f6:	80 e2       	ldi	r24, 0x20	; 32
    28f8:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    28fc:	81 11       	cpse	r24, r1
    28fe:	fb cf       	rjmp	.-10     	; 0x28f6 <DISPLAY_MainFunction+0x420>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2900:	80 e1       	ldi	r24, 0x10	; 16
    2902:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2906:	81 11       	cpse	r24, r1
    2908:	fb cf       	rjmp	.-10     	; 0x2900 <DISPLAY_MainFunction+0x42a>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    290a:	80 e1       	ldi	r24, 0x10	; 16
    290c:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2910:	81 11       	cpse	r24, r1
    2912:	fb cf       	rjmp	.-10     	; 0x290a <DISPLAY_MainFunction+0x434>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2914:	80 e1       	ldi	r24, 0x10	; 16
    2916:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    291a:	81 11       	cpse	r24, r1
    291c:	fb cf       	rjmp	.-10     	; 0x2914 <DISPLAY_MainFunction+0x43e>
    291e:	6b c0       	rjmp	.+214    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
				else
				{
					while(LCD_SendData(' ')!=OperationSuccess);
    2920:	80 e2       	ldi	r24, 0x20	; 32
    2922:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2926:	81 11       	cpse	r24, r1
    2928:	fb cf       	rjmp	.-10     	; 0x2920 <DISPLAY_MainFunction+0x44a>
					while(LCD_SendData(' ')!=OperationSuccess);
    292a:	80 e2       	ldi	r24, 0x20	; 32
    292c:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2930:	81 11       	cpse	r24, r1
    2932:	fb cf       	rjmp	.-10     	; 0x292a <DISPLAY_MainFunction+0x454>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2934:	80 e1       	ldi	r24, 0x10	; 16
    2936:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    293a:	81 11       	cpse	r24, r1
    293c:	fb cf       	rjmp	.-10     	; 0x2934 <DISPLAY_MainFunction+0x45e>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    293e:	80 e1       	ldi	r24, 0x10	; 16
    2940:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2944:	81 11       	cpse	r24, r1
    2946:	fb cf       	rjmp	.-10     	; 0x293e <DISPLAY_MainFunction+0x468>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2948:	80 e1       	ldi	r24, 0x10	; 16
    294a:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    294e:	81 11       	cpse	r24, r1
    2950:	fb cf       	rjmp	.-10     	; 0x2948 <DISPLAY_MainFunction+0x472>
    2952:	51 c0       	rjmp	.+162    	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
			}
			else if ((Shifting_State == ShiftingLeft) && (LastShiftingState == ShiftingRight))
    2954:	81 30       	cpi	r24, 0x01	; 1
    2956:	09 f0       	breq	.+2      	; 0x295a <DISPLAY_MainFunction+0x484>
    2958:	4e c0       	rjmp	.+156    	; 0x29f6 <DISPLAY_MainFunction+0x520>
    295a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <LastShiftingState>
    295e:	82 30       	cpi	r24, 0x02	; 2
    2960:	09 f0       	breq	.+2      	; 0x2964 <DISPLAY_MainFunction+0x48e>
    2962:	49 c0       	rjmp	.+146    	; 0x29f6 <DISPLAY_MainFunction+0x520>
			{
				while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    2964:	80 e1       	ldi	r24, 0x10	; 16
    2966:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    296a:	81 11       	cpse	r24, r1
    296c:	fb cf       	rjmp	.-10     	; 0x2964 <DISPLAY_MainFunction+0x48e>
				LCD_SendNumber(RemainingSeconds);
    296e:	60 91 ba 07 	lds	r22, 0x07BA	; 0x8007ba <RemainingSeconds>
    2972:	70 91 bb 07 	lds	r23, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    2976:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    297a:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    297e:	0e 94 86 0a 	call	0x150c	; 0x150c <LCD_SendNumber>
				if(RemainingSeconds/10)
    2982:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <RemainingSeconds>
    2986:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <RemainingSeconds+0x1>
    298a:	a0 91 bc 07 	lds	r26, 0x07BC	; 0x8007bc <RemainingSeconds+0x2>
    298e:	b0 91 bd 07 	lds	r27, 0x07BD	; 0x8007bd <RemainingSeconds+0x3>
    2992:	0a 97       	sbiw	r24, 0x0a	; 10
    2994:	a1 05       	cpc	r26, r1
    2996:	b1 05       	cpc	r27, r1
    2998:	a8 f0       	brcs	.+42     	; 0x29c4 <DISPLAY_MainFunction+0x4ee>
				{
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    299a:	80 e2       	ldi	r24, 0x20	; 32
    299c:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    29a0:	81 11       	cpse	r24, r1
    29a2:	fb cf       	rjmp	.-10     	; 0x299a <DISPLAY_MainFunction+0x4c4>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29a4:	80 e1       	ldi	r24, 0x10	; 16
    29a6:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29aa:	81 11       	cpse	r24, r1
    29ac:	fb cf       	rjmp	.-10     	; 0x29a4 <DISPLAY_MainFunction+0x4ce>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29ae:	80 e1       	ldi	r24, 0x10	; 16
    29b0:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29b4:	81 11       	cpse	r24, r1
    29b6:	fb cf       	rjmp	.-10     	; 0x29ae <DISPLAY_MainFunction+0x4d8>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29b8:	80 e1       	ldi	r24, 0x10	; 16
    29ba:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29be:	81 11       	cpse	r24, r1
    29c0:	fb cf       	rjmp	.-10     	; 0x29b8 <DISPLAY_MainFunction+0x4e2>
    29c2:	19 c0       	rjmp	.+50     	; 0x29f6 <DISPLAY_MainFunction+0x520>
				}
				else
				{
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    29c4:	80 e2       	ldi	r24, 0x20	; 32
    29c6:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    29ca:	81 11       	cpse	r24, r1
    29cc:	fb cf       	rjmp	.-10     	; 0x29c4 <DISPLAY_MainFunction+0x4ee>
					while(LCD_SendData(' ')!=OperationSuccess);/**/
    29ce:	80 e2       	ldi	r24, 0x20	; 32
    29d0:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    29d4:	81 11       	cpse	r24, r1
    29d6:	fb cf       	rjmp	.-10     	; 0x29ce <DISPLAY_MainFunction+0x4f8>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29d8:	80 e1       	ldi	r24, 0x10	; 16
    29da:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29de:	81 11       	cpse	r24, r1
    29e0:	fb cf       	rjmp	.-10     	; 0x29d8 <DISPLAY_MainFunction+0x502>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29e2:	80 e1       	ldi	r24, 0x10	; 16
    29e4:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29e8:	81 11       	cpse	r24, r1
    29ea:	fb cf       	rjmp	.-10     	; 0x29e2 <DISPLAY_MainFunction+0x50c>
					while(LCD_SendCommand(LCD_SHIFTCURSLEFT)!=OperationSuccess);
    29ec:	80 e1       	ldi	r24, 0x10	; 16
    29ee:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    29f2:	81 11       	cpse	r24, r1
    29f4:	fb cf       	rjmp	.-10     	; 0x29ec <DISPLAY_MainFunction+0x516>
				}
			}
			LastShiftingState = Shifting_State;
    29f6:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <Shifting_State>
    29fa:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <LastShiftingState>
			//if(Counter == (uint8_t)((TenSeconds/MainFunction_Periodicity)-1))
			if(Counter == 200)
    29fe:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <Counter.1754>
    2a02:	88 3c       	cpi	r24, 0xC8	; 200
    2a04:	09 f0       	breq	.+2      	; 0x2a08 <DISPLAY_MainFunction+0x532>
    2a06:	5c c0       	rjmp	.+184    	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			{
				WrongPassEntries = 0;
    2a08:	10 92 be 07 	sts	0x07BE, r1	; 0x8007be <WrongPassEntries>
				Counter = 0;
    2a0c:	10 92 b9 07 	sts	0x07B9, r1	; 0x8007b9 <Counter.1754>
				DISPLAY_SetState(PassEntering);
    2a10:	85 e0       	ldi	r24, 0x05	; 5
    2a12:	0e 94 76 15 	call	0x2aec	; 0x2aec <DISPLAY_SetState>
    2a16:	54 c0       	rjmp	.+168    	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			}
			break;
		case SevenSegments:
			if(Last_state != State)
    2a18:	23 17       	cp	r18, r19
    2a1a:	a9 f0       	breq	.+42     	; 0x2a46 <DISPLAY_MainFunction+0x570>
			{
				Position = 0;
    2a1c:	10 92 c0 07 	sts	0x07C0, r1	; 0x8007c0 <Position>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    2a20:	81 e0       	ldi	r24, 0x01	; 1
    2a22:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a26:	81 11       	cpse	r24, r1
    2a28:	fb cf       	rjmp	.-10     	; 0x2a20 <DISPLAY_MainFunction+0x54a>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    2a2a:	82 e0       	ldi	r24, 0x02	; 2
    2a2c:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a30:	81 11       	cpse	r24, r1
    2a32:	fb cf       	rjmp	.-10     	; 0x2a2a <DISPLAY_MainFunction+0x554>
				while (LCD_SendString((uint8_t*)"System is ON") != OperationSuccess);
    2a34:	82 e1       	ldi	r24, 0x12	; 18
    2a36:	91 e0       	ldi	r25, 0x01	; 1
    2a38:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    2a3c:	81 11       	cpse	r24, r1
    2a3e:	fa cf       	rjmp	.-12     	; 0x2a34 <DISPLAY_MainFunction+0x55e>
				Shifting_State = ShiftingRight;
    2a40:	82 e0       	ldi	r24, 0x02	; 2
    2a42:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
			}
			DISPLAY_START_SHIFTING(SystemOn_StringWidth,0);
    2a46:	60 e0       	ldi	r22, 0x00	; 0
    2a48:	8c e0       	ldi	r24, 0x0C	; 12
    2a4a:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <DISPLAY_START_SHIFTING>
			break;
    2a4e:	38 c0       	rjmp	.+112    	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
		case ChangePassword:
			if(Last_state != State)
    2a50:	23 17       	cp	r18, r19
    2a52:	b1 f1       	breq	.+108    	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
			{
				Position = DISPLAY_WIDTH-ChangePassword_StringWidth;
    2a54:	83 e0       	ldi	r24, 0x03	; 3
    2a56:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <Position>
				while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    2a5a:	81 e0       	ldi	r24, 0x01	; 1
    2a5c:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a60:	81 11       	cpse	r24, r1
    2a62:	fb cf       	rjmp	.-10     	; 0x2a5a <DISPLAY_MainFunction+0x584>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
    2a64:	82 e0       	ldi	r24, 0x02	; 2
    2a66:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a6a:	81 11       	cpse	r24, r1
    2a6c:	fb cf       	rjmp	.-10     	; 0x2a64 <DISPLAY_MainFunction+0x58e>
				while (LCD_SendCommand(LCD_CURS_Position0|Position)!=OperationSuccess);
    2a6e:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <Position>
    2a72:	80 68       	ori	r24, 0x80	; 128
    2a74:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a78:	81 11       	cpse	r24, r1
    2a7a:	f9 cf       	rjmp	.-14     	; 0x2a6e <DISPLAY_MainFunction+0x598>
				while (LCD_SendString((uint8_t*)"Changing Pass") != OperationSuccess);
    2a7c:	8f e1       	ldi	r24, 0x1F	; 31
    2a7e:	91 e0       	ldi	r25, 0x01	; 1
    2a80:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_SendString>
    2a84:	81 11       	cpse	r24, r1
    2a86:	fa cf       	rjmp	.-12     	; 0x2a7c <DISPLAY_MainFunction+0x5a6>
				Shifting_State = ShiftingLeft;
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <Shifting_State>
				while (LCD_SendCommand(0xc0)!=OperationSuccess);
    2a8e:	80 ec       	ldi	r24, 0xC0	; 192
    2a90:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2a94:	81 11       	cpse	r24, r1
    2a96:	fb cf       	rjmp	.-10     	; 0x2a8e <DISPLAY_MainFunction+0x5b8>
    2a98:	10 e0       	ldi	r17, 0x00	; 0
    2a9a:	08 c0       	rjmp	.+16     	; 0x2aac <DISPLAY_MainFunction+0x5d6>
				for(uint8_t i = 0; i < Number_of_Asteriks; i++)
				{
					while(LCD_SendData('*')!= OperationSuccess);
    2a9c:	8a e2       	ldi	r24, 0x2A	; 42
    2a9e:	0e 94 47 08 	call	0x108e	; 0x108e <LCD_SendData>
    2aa2:	81 11       	cpse	r24, r1
    2aa4:	fb cf       	rjmp	.-10     	; 0x2a9c <DISPLAY_MainFunction+0x5c6>
					if (i>5)
    2aa6:	16 30       	cpi	r17, 0x06	; 6
    2aa8:	58 f4       	brcc	.+22     	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
				while (LCD_SendCommand(LCD_HOME)!=OperationSuccess);
				while (LCD_SendCommand(LCD_CURS_Position0|Position)!=OperationSuccess);
				while (LCD_SendString((uint8_t*)"Changing Pass") != OperationSuccess);
				Shifting_State = ShiftingLeft;
				while (LCD_SendCommand(0xc0)!=OperationSuccess);
				for(uint8_t i = 0; i < Number_of_Asteriks; i++)
    2aaa:	1f 5f       	subi	r17, 0xFF	; 255
    2aac:	80 91 bf 07 	lds	r24, 0x07BF	; 0x8007bf <Number_of_Asteriks>
    2ab0:	18 17       	cp	r17, r24
    2ab2:	a0 f3       	brcs	.-24     	; 0x2a9c <DISPLAY_MainFunction+0x5c6>
    2ab4:	05 c0       	rjmp	.+10     	; 0x2ac0 <DISPLAY_MainFunction+0x5ea>
					}
				}
			}
			break;
		default:
			while (LCD_SendCommand(LCD_CLR)!=OperationSuccess);
    2ab6:	81 e0       	ldi	r24, 0x01	; 1
    2ab8:	0e 94 2a 07 	call	0xe54	; 0xe54 <LCD_SendCommand>
    2abc:	81 11       	cpse	r24, r1
    2abe:	fb cf       	rjmp	.-10     	; 0x2ab6 <DISPLAY_MainFunction+0x5e0>
			break;
	}
	Last_state = State;
    2ac0:	89 81       	ldd	r24, Y+1	; 0x01
    2ac2:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <Last_state.1753>
}
    2ac6:	0f 90       	pop	r0
    2ac8:	df 91       	pop	r29
    2aca:	cf 91       	pop	r28
    2acc:	1f 91       	pop	r17
    2ace:	ff 90       	pop	r15
    2ad0:	ef 90       	pop	r14
    2ad2:	df 90       	pop	r13
    2ad4:	cf 90       	pop	r12
    2ad6:	08 95       	ret

00002ad8 <DISPLAY_GetState>:
uint8_t static State = OperationStarted;
uint8_t static Number_of_Asteriks = 0;

void DISPLAY_GetState(uint8_t* StateVal)
{
	*StateVal = State;
    2ad8:	20 91 68 00 	lds	r18, 0x0068	; 0x800068 <State>
    2adc:	fc 01       	movw	r30, r24
    2ade:	20 83       	st	Z, r18
    2ae0:	08 95       	ret

00002ae2 <DISPLAY_GetNumber_of_Asterisk>:
}
void DISPLAY_GetNumber_of_Asterisk(uint8_t* AsterisksNumVal)
{
	*AsterisksNumVal = Number_of_Asteriks;
    2ae2:	20 91 c1 07 	lds	r18, 0x07C1	; 0x8007c1 <Number_of_Asteriks>
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	20 83       	st	Z, r18
    2aea:	08 95       	ret

00002aec <DISPLAY_SetState>:
}
void DISPLAY_SetState(uint8_t StateVal)
{
	State = StateVal;
    2aec:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <State>
    2af0:	08 95       	ret

00002af2 <DISPLAY_SetNumber_of_Asterisk>:
}
void DISPLAY_SetNumber_of_Asterisk(uint8_t AsterisksNumVal)
{
	Number_of_Asteriks = AsterisksNumVal;
    2af2:	80 93 c1 07 	sts	0x07C1, r24	; 0x8007c1 <Number_of_Asteriks>
    2af6:	08 95       	ret

00002af8 <SSD_Display_MainFunction>:
* @brief: This function is the Display main function.
*
* @return function error state.
*/
extern void SSD_Display_MainFunction(void)
{
    2af8:	0f 93       	push	r16
    2afa:	1f 93       	push	r17
    2afc:	cf 93       	push	r28
    2afe:	df 93       	push	r29
    2b00:	1f 92       	push	r1
    2b02:	cd b7       	in	r28, 0x3d	; 61
    2b04:	de b7       	in	r29, 0x3e	; 62
   static uint8_t u8_Init = 0;  
   uint8_t u8_SevenSegmentNumber; 
   static Enu_SSDDisplayStateMachine State = SSD_Display_FirstNumber;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    2b06:	80 91 c3 07 	lds	r24, 0x07C3	; 0x8007c3 <u8_Init.1656>
    2b0a:	81 11       	cpse	r24, r1
    2b0c:	0d c0       	rjmp	.+26     	; 0x2b28 <SSD_Display_MainFunction+0x30>
   {
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh0);
    2b0e:	0d e2       	ldi	r16, 0x2D	; 45
    2b10:	11 e0       	ldi	r17, 0x01	; 1
    2b12:	f8 01       	movw	r30, r16
    2b14:	80 81       	ld	r24, Z
    2b16:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <SevenSeg_Init>
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh1);
    2b1a:	f8 01       	movw	r30, r16
    2b1c:	81 81       	ldd	r24, Z+1	; 0x01
    2b1e:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <SevenSeg_Init>
      u8_Init = 1;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	80 93 c3 07 	sts	0x07C3, r24	; 0x8007c3 <u8_Init.1656>
   }
   
   /* Get the number to display. */
   SSD_Display_GetSevenSegment(&u8_SevenSegmentNumber);
    2b28:	ce 01       	movw	r24, r28
    2b2a:	01 96       	adiw	r24, 0x01	; 1
    2b2c:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <SSD_Display_GetSevenSegment>
   
   switch(State)
    2b30:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <State.1658>
    2b34:	88 23       	and	r24, r24
    2b36:	19 f0       	breq	.+6      	; 0x2b3e <SSD_Display_MainFunction+0x46>
    2b38:	81 30       	cpi	r24, 0x01	; 1
    2b3a:	b9 f0       	breq	.+46     	; 0x2b6a <SSD_Display_MainFunction+0x72>
    2b3c:	24 c0       	rjmp	.+72     	; 0x2b86 <SSD_Display_MainFunction+0x8e>
   {
      case SSD_Display_FirstNumber:
         /* Display the first number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh0, u8_SevenSegmentNumber%10);
    2b3e:	69 81       	ldd	r22, Y+1	; 0x01
    2b40:	8d ec       	ldi	r24, 0xCD	; 205
    2b42:	68 9f       	mul	r22, r24
    2b44:	81 2d       	mov	r24, r1
    2b46:	11 24       	eor	r1, r1
    2b48:	86 95       	lsr	r24
    2b4a:	86 95       	lsr	r24
    2b4c:	86 95       	lsr	r24
    2b4e:	88 0f       	add	r24, r24
    2b50:	98 2f       	mov	r25, r24
    2b52:	99 0f       	add	r25, r25
    2b54:	99 0f       	add	r25, r25
    2b56:	89 0f       	add	r24, r25
    2b58:	68 1b       	sub	r22, r24
    2b5a:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <STR_DisplaySegmentConfig>
    2b5e:	0e 94 09 0c 	call	0x1812	; 0x1812 <SevenSeg_Display>
         State = SSD_Display_SecondNumber;
    2b62:	81 e0       	ldi	r24, 0x01	; 1
    2b64:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <State.1658>
         break;
    2b68:	0e c0       	rjmp	.+28     	; 0x2b86 <SSD_Display_MainFunction+0x8e>
      case SSD_Display_SecondNumber:
         /* Display the second number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh1, u8_SevenSegmentNumber/10);
    2b6a:	89 81       	ldd	r24, Y+1	; 0x01
    2b6c:	6d ec       	ldi	r22, 0xCD	; 205
    2b6e:	86 9f       	mul	r24, r22
    2b70:	61 2d       	mov	r22, r1
    2b72:	11 24       	eor	r1, r1
    2b74:	66 95       	lsr	r22
    2b76:	66 95       	lsr	r22
    2b78:	66 95       	lsr	r22
    2b7a:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <STR_DisplaySegmentConfig+0x1>
    2b7e:	0e 94 09 0c 	call	0x1812	; 0x1812 <SevenSeg_Display>
         State = SSD_Display_FirstNumber;
    2b82:	10 92 c2 07 	sts	0x07C2, r1	; 0x8007c2 <State.1658>
         break;
   }      
    2b86:	0f 90       	pop	r0
    2b88:	df 91       	pop	r29
    2b8a:	cf 91       	pop	r28
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	08 95       	ret

00002b92 <SSD_Display_GetSevenSegment>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Display_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    2b92:	00 97       	sbiw	r24, 0x00	; 0
    2b94:	31 f0       	breq	.+12     	; 0x2ba2 <SSD_Display_GetSevenSegment+0x10>
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
   }
   else
   {
      /* Return the segment value. */
      *Value = gu8_SevenSegmentValue;
    2b96:	20 91 c4 07 	lds	r18, 0x07C4	; 0x8007c4 <gu8_SevenSegmentValue>
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	20 83       	st	Z, r18
      Display_ErrorState = ERROR_OK;
    2b9e:	80 e0       	ldi	r24, 0x00	; 0
    2ba0:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
    2ba2:	82 e9       	ldi	r24, 0x92	; 146
      Display_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Display_ErrorState;
}
    2ba4:	08 95       	ret

00002ba6 <SSD_Display_SetSevenSegment>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Display_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
    2ba6:	84 36       	cpi	r24, 0x64	; 100
    2ba8:	20 f4       	brcc	.+8      	; 0x2bb2 <SSD_Display_SetSevenSegment+0xc>
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
   }
   else
   {
      /* Set the segment value. */
      gu8_SevenSegmentValue = Value;
    2baa:	80 93 c4 07 	sts	0x07C4, r24	; 0x8007c4 <gu8_SevenSegmentValue>
      Display_ErrorState = ERROR_OK;
    2bae:	80 e0       	ldi	r24, 0x00	; 0
    2bb0:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
   {
      /* Set invalid Value error. */
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
    2bb2:	81 e9       	ldi	r24, 0x91	; 145
      Display_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Display_ErrorState;
    2bb4:	08 95       	ret

00002bb6 <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    2bb6:	0e 94 0b 11 	call	0x2216	; 0x2216 <Indicator_MainFunction>
    2bba:	fd cf       	rjmp	.-6      	; 0x2bb6 <Feedback_Task>

00002bbc <SSD_Display_Task>:
   }
}

void SSD_Display_Task( void *pvParameters )
{
    2bbc:	cf 93       	push	r28
    2bbe:	df 93       	push	r29
    2bc0:	00 d0       	rcall	.+0      	; 0x2bc2 <SSD_Display_Task+0x6>
    2bc2:	cd b7       	in	r28, 0x3d	; 61
    2bc4:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    2bc6:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskGetTickCount>
    2bca:	9a 83       	std	Y+2, r25	; 0x02
    2bcc:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      SSD_Display_MainFunction();
    2bce:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <SSD_Display_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 10);
    2bd2:	6a e0       	ldi	r22, 0x0A	; 10
    2bd4:	70 e0       	ldi	r23, 0x00	; 0
    2bd6:	ce 01       	movw	r24, r28
    2bd8:	01 96       	adiw	r24, 0x01	; 1
    2bda:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
    2bde:	f7 cf       	rjmp	.-18     	; 0x2bce <SSD_Display_Task+0x12>

00002be0 <LCD_Display_Task>:
   }
}

#include "LCD_DISPLAY_Interface.h"
void LCD_Display_Task( void *pvParameters )
{
    2be0:	cf 93       	push	r28
    2be2:	df 93       	push	r29
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <LCD_Display_Task+0x6>
    2be6:	cd b7       	in	r28, 0x3d	; 61
    2be8:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    2bea:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskGetTickCount>
    2bee:	9a 83       	std	Y+2, r25	; 0x02
    2bf0:	89 83       	std	Y+1, r24	; 0x01
   DISPLAY_SetState(PassEntering);
    2bf2:	85 e0       	ldi	r24, 0x05	; 5
    2bf4:	0e 94 76 15 	call	0x2aec	; 0x2aec <DISPLAY_SetState>
   for( ;; )
   {
      DISPLAY_MainFunction();
    2bf8:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <DISPLAY_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    2bfc:	62 e3       	ldi	r22, 0x32	; 50
    2bfe:	70 e0       	ldi	r23, 0x00	; 0
    2c00:	ce 01       	movw	r24, r28
    2c02:	01 96       	adiw	r24, 0x01	; 1
    2c04:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
    2c08:	f7 cf       	rjmp	.-18     	; 0x2bf8 <LCD_Display_Task+0x18>

00002c0a <NumberChange_Task>:
}

#if 1
#include "SSD_Display_Interface.h"
void NumberChange_Task( void *pvParameters )
{
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	00 d0       	rcall	.+0      	; 0x2c10 <NumberChange_Task+0x6>
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    2c14:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskGetTickCount>
    2c18:	9a 83       	std	Y+2, r25	; 0x02
    2c1a:	89 83       	std	Y+1, r24	; 0x01
   
   static uint8_t Number = 1;
   static uint8_t ast = 2;
   vTaskDelayUntil(&xLastWakeTime, 1000);
    2c1c:	68 ee       	ldi	r22, 0xE8	; 232
    2c1e:	73 e0       	ldi	r23, 0x03	; 3
    2c20:	ce 01       	movw	r24, r28
    2c22:	01 96       	adiw	r24, 0x01	; 1
    2c24:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
   for( ;; )
   {
      DISPLAY_SetNumber_of_Asterisk(ast);
    2c28:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <ast.2123>
    2c2c:	0e 94 79 15 	call	0x2af2	; 0x2af2 <DISPLAY_SetNumber_of_Asterisk>
      SSD_Display_SetSevenSegment(Number);
    2c30:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Number.2122>
    2c34:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <SSD_Display_SetSevenSegment>
      Number++;
    2c38:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Number.2122>
    2c3c:	8f 5f       	subi	r24, 0xFF	; 255
    2c3e:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <Number.2122>
      ast++;
    2c42:	90 91 6a 00 	lds	r25, 0x006A	; 0x80006a <ast.2123>
    2c46:	9f 5f       	subi	r25, 0xFF	; 255
    2c48:	90 93 6a 00 	sts	0x006A, r25	; 0x80006a <ast.2123>
      if(Number > 99)
    2c4c:	84 36       	cpi	r24, 0x64	; 100
    2c4e:	10 f0       	brcs	.+4      	; 0x2c54 <NumberChange_Task+0x4a>
      {
         Number = 0;
    2c50:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <Number.2122>
      }
      vTaskDelayUntil(&xLastWakeTime, 1000);
    2c54:	68 ee       	ldi	r22, 0xE8	; 232
    2c56:	73 e0       	ldi	r23, 0x03	; 3
    2c58:	ce 01       	movw	r24, r28
    2c5a:	01 96       	adiw	r24, 0x01	; 1
    2c5c:	0e 94 95 06 	call	0xd2a	; 0xd2a <vTaskDelayUntil>
   }
    2c60:	e3 cf       	rjmp	.-58     	; 0x2c28 <NumberChange_Task+0x1e>

00002c62 <main>:
}
#endif

int main(void)
{   
   while(ERROR_OK != LCD_Init());
    2c62:	0e 94 47 09 	call	0x128e	; 0x128e <LCD_Init>
    2c66:	81 11       	cpse	r24, r1
    2c68:	fc cf       	rjmp	.-8      	; 0x2c62 <main>
   
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2c6a:	e1 2c       	mov	r14, r1
    2c6c:	f1 2c       	mov	r15, r1
    2c6e:	01 e0       	ldi	r16, 0x01	; 1
    2c70:	20 e0       	ldi	r18, 0x00	; 0
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	45 e5       	ldi	r20, 0x55	; 85
    2c76:	50 e0       	ldi	r21, 0x00	; 0
    2c78:	63 e4       	ldi	r22, 0x43	; 67
    2c7a:	71 e0       	ldi	r23, 0x01	; 1
    2c7c:	8b ed       	ldi	r24, 0xDB	; 219
    2c7e:	95 e1       	ldi	r25, 0x15	; 21
    2c80:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xTaskCreate>
   xTaskCreate( SSD_Display_Task, "SevenSegment", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2c84:	20 e0       	ldi	r18, 0x00	; 0
    2c86:	30 e0       	ldi	r19, 0x00	; 0
    2c88:	45 e5       	ldi	r20, 0x55	; 85
    2c8a:	50 e0       	ldi	r21, 0x00	; 0
    2c8c:	6d e4       	ldi	r22, 0x4D	; 77
    2c8e:	71 e0       	ldi	r23, 0x01	; 1
    2c90:	8e ed       	ldi	r24, 0xDE	; 222
    2c92:	95 e1       	ldi	r25, 0x15	; 21
    2c94:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xTaskCreate>
   xTaskCreate( NumberChange_Task, "number", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2c98:	20 e0       	ldi	r18, 0x00	; 0
    2c9a:	30 e0       	ldi	r19, 0x00	; 0
    2c9c:	45 e5       	ldi	r20, 0x55	; 85
    2c9e:	50 e0       	ldi	r21, 0x00	; 0
    2ca0:	6a e5       	ldi	r22, 0x5A	; 90
    2ca2:	71 e0       	ldi	r23, 0x01	; 1
    2ca4:	85 e0       	ldi	r24, 0x05	; 5
    2ca6:	96 e1       	ldi	r25, 0x16	; 22
    2ca8:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xTaskCreate>
   xTaskCreate( LCD_Display_Task, "LCD", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2cac:	20 e0       	ldi	r18, 0x00	; 0
    2cae:	30 e0       	ldi	r19, 0x00	; 0
    2cb0:	45 e5       	ldi	r20, 0x55	; 85
    2cb2:	50 e0       	ldi	r21, 0x00	; 0
    2cb4:	61 e6       	ldi	r22, 0x61	; 97
    2cb6:	71 e0       	ldi	r23, 0x01	; 1
    2cb8:	80 ef       	ldi	r24, 0xF0	; 240
    2cba:	95 e1       	ldi	r25, 0x15	; 21
    2cbc:	0e 94 db 04 	call	0x9b6	; 0x9b6 <xTaskCreate>
   
   vTaskStartScheduler();
    2cc0:	0e 94 2f 05 	call	0xa5e	; 0xa5e <vTaskStartScheduler>
    2cc4:	ff cf       	rjmp	.-2      	; 0x2cc4 <main+0x62>

00002cc6 <__subsf3>:
    2cc6:	50 58       	subi	r21, 0x80	; 128

00002cc8 <__addsf3>:
    2cc8:	bb 27       	eor	r27, r27
    2cca:	aa 27       	eor	r26, r26
    2ccc:	0e 94 7b 16 	call	0x2cf6	; 0x2cf6 <__addsf3x>
    2cd0:	0c 94 ee 17 	jmp	0x2fdc	; 0x2fdc <__fp_round>
    2cd4:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <__fp_pscA>
    2cd8:	38 f0       	brcs	.+14     	; 0x2ce8 <__addsf3+0x20>
    2cda:	0e 94 e7 17 	call	0x2fce	; 0x2fce <__fp_pscB>
    2cde:	20 f0       	brcs	.+8      	; 0x2ce8 <__addsf3+0x20>
    2ce0:	39 f4       	brne	.+14     	; 0x2cf0 <__addsf3+0x28>
    2ce2:	9f 3f       	cpi	r25, 0xFF	; 255
    2ce4:	19 f4       	brne	.+6      	; 0x2cec <__addsf3+0x24>
    2ce6:	26 f4       	brtc	.+8      	; 0x2cf0 <__addsf3+0x28>
    2ce8:	0c 94 dd 17 	jmp	0x2fba	; 0x2fba <__fp_nan>
    2cec:	0e f4       	brtc	.+2      	; 0x2cf0 <__addsf3+0x28>
    2cee:	e0 95       	com	r30
    2cf0:	e7 fb       	bst	r30, 7
    2cf2:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <__fp_inf>

00002cf6 <__addsf3x>:
    2cf6:	e9 2f       	mov	r30, r25
    2cf8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <__fp_split3>
    2cfc:	58 f3       	brcs	.-42     	; 0x2cd4 <__addsf3+0xc>
    2cfe:	ba 17       	cp	r27, r26
    2d00:	62 07       	cpc	r22, r18
    2d02:	73 07       	cpc	r23, r19
    2d04:	84 07       	cpc	r24, r20
    2d06:	95 07       	cpc	r25, r21
    2d08:	20 f0       	brcs	.+8      	; 0x2d12 <__addsf3x+0x1c>
    2d0a:	79 f4       	brne	.+30     	; 0x2d2a <__addsf3x+0x34>
    2d0c:	a6 f5       	brtc	.+104    	; 0x2d76 <__addsf3x+0x80>
    2d0e:	0c 94 21 18 	jmp	0x3042	; 0x3042 <__fp_zero>
    2d12:	0e f4       	brtc	.+2      	; 0x2d16 <__addsf3x+0x20>
    2d14:	e0 95       	com	r30
    2d16:	0b 2e       	mov	r0, r27
    2d18:	ba 2f       	mov	r27, r26
    2d1a:	a0 2d       	mov	r26, r0
    2d1c:	0b 01       	movw	r0, r22
    2d1e:	b9 01       	movw	r22, r18
    2d20:	90 01       	movw	r18, r0
    2d22:	0c 01       	movw	r0, r24
    2d24:	ca 01       	movw	r24, r20
    2d26:	a0 01       	movw	r20, r0
    2d28:	11 24       	eor	r1, r1
    2d2a:	ff 27       	eor	r31, r31
    2d2c:	59 1b       	sub	r21, r25
    2d2e:	99 f0       	breq	.+38     	; 0x2d56 <__addsf3x+0x60>
    2d30:	59 3f       	cpi	r21, 0xF9	; 249
    2d32:	50 f4       	brcc	.+20     	; 0x2d48 <__addsf3x+0x52>
    2d34:	50 3e       	cpi	r21, 0xE0	; 224
    2d36:	68 f1       	brcs	.+90     	; 0x2d92 <__addsf3x+0x9c>
    2d38:	1a 16       	cp	r1, r26
    2d3a:	f0 40       	sbci	r31, 0x00	; 0
    2d3c:	a2 2f       	mov	r26, r18
    2d3e:	23 2f       	mov	r18, r19
    2d40:	34 2f       	mov	r19, r20
    2d42:	44 27       	eor	r20, r20
    2d44:	58 5f       	subi	r21, 0xF8	; 248
    2d46:	f3 cf       	rjmp	.-26     	; 0x2d2e <__addsf3x+0x38>
    2d48:	46 95       	lsr	r20
    2d4a:	37 95       	ror	r19
    2d4c:	27 95       	ror	r18
    2d4e:	a7 95       	ror	r26
    2d50:	f0 40       	sbci	r31, 0x00	; 0
    2d52:	53 95       	inc	r21
    2d54:	c9 f7       	brne	.-14     	; 0x2d48 <__addsf3x+0x52>
    2d56:	7e f4       	brtc	.+30     	; 0x2d76 <__addsf3x+0x80>
    2d58:	1f 16       	cp	r1, r31
    2d5a:	ba 0b       	sbc	r27, r26
    2d5c:	62 0b       	sbc	r22, r18
    2d5e:	73 0b       	sbc	r23, r19
    2d60:	84 0b       	sbc	r24, r20
    2d62:	ba f0       	brmi	.+46     	; 0x2d92 <__addsf3x+0x9c>
    2d64:	91 50       	subi	r25, 0x01	; 1
    2d66:	a1 f0       	breq	.+40     	; 0x2d90 <__addsf3x+0x9a>
    2d68:	ff 0f       	add	r31, r31
    2d6a:	bb 1f       	adc	r27, r27
    2d6c:	66 1f       	adc	r22, r22
    2d6e:	77 1f       	adc	r23, r23
    2d70:	88 1f       	adc	r24, r24
    2d72:	c2 f7       	brpl	.-16     	; 0x2d64 <__addsf3x+0x6e>
    2d74:	0e c0       	rjmp	.+28     	; 0x2d92 <__addsf3x+0x9c>
    2d76:	ba 0f       	add	r27, r26
    2d78:	62 1f       	adc	r22, r18
    2d7a:	73 1f       	adc	r23, r19
    2d7c:	84 1f       	adc	r24, r20
    2d7e:	48 f4       	brcc	.+18     	; 0x2d92 <__addsf3x+0x9c>
    2d80:	87 95       	ror	r24
    2d82:	77 95       	ror	r23
    2d84:	67 95       	ror	r22
    2d86:	b7 95       	ror	r27
    2d88:	f7 95       	ror	r31
    2d8a:	9e 3f       	cpi	r25, 0xFE	; 254
    2d8c:	08 f0       	brcs	.+2      	; 0x2d90 <__addsf3x+0x9a>
    2d8e:	b0 cf       	rjmp	.-160    	; 0x2cf0 <__addsf3+0x28>
    2d90:	93 95       	inc	r25
    2d92:	88 0f       	add	r24, r24
    2d94:	08 f0       	brcs	.+2      	; 0x2d98 <__addsf3x+0xa2>
    2d96:	99 27       	eor	r25, r25
    2d98:	ee 0f       	add	r30, r30
    2d9a:	97 95       	ror	r25
    2d9c:	87 95       	ror	r24
    2d9e:	08 95       	ret

00002da0 <__cmpsf2>:
    2da0:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <__fp_cmp>
    2da4:	08 f4       	brcc	.+2      	; 0x2da8 <__cmpsf2+0x8>
    2da6:	81 e0       	ldi	r24, 0x01	; 1
    2da8:	08 95       	ret

00002daa <__divsf3>:
    2daa:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <__divsf3x>
    2dae:	0c 94 ee 17 	jmp	0x2fdc	; 0x2fdc <__fp_round>
    2db2:	0e 94 e7 17 	call	0x2fce	; 0x2fce <__fp_pscB>
    2db6:	58 f0       	brcs	.+22     	; 0x2dce <__divsf3+0x24>
    2db8:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <__fp_pscA>
    2dbc:	40 f0       	brcs	.+16     	; 0x2dce <__divsf3+0x24>
    2dbe:	29 f4       	brne	.+10     	; 0x2dca <__divsf3+0x20>
    2dc0:	5f 3f       	cpi	r21, 0xFF	; 255
    2dc2:	29 f0       	breq	.+10     	; 0x2dce <__divsf3+0x24>
    2dc4:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <__fp_inf>
    2dc8:	51 11       	cpse	r21, r1
    2dca:	0c 94 22 18 	jmp	0x3044	; 0x3044 <__fp_szero>
    2dce:	0c 94 dd 17 	jmp	0x2fba	; 0x2fba <__fp_nan>

00002dd2 <__divsf3x>:
    2dd2:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <__fp_split3>
    2dd6:	68 f3       	brcs	.-38     	; 0x2db2 <__divsf3+0x8>

00002dd8 <__divsf3_pse>:
    2dd8:	99 23       	and	r25, r25
    2dda:	b1 f3       	breq	.-20     	; 0x2dc8 <__divsf3+0x1e>
    2ddc:	55 23       	and	r21, r21
    2dde:	91 f3       	breq	.-28     	; 0x2dc4 <__divsf3+0x1a>
    2de0:	95 1b       	sub	r25, r21
    2de2:	55 0b       	sbc	r21, r21
    2de4:	bb 27       	eor	r27, r27
    2de6:	aa 27       	eor	r26, r26
    2de8:	62 17       	cp	r22, r18
    2dea:	73 07       	cpc	r23, r19
    2dec:	84 07       	cpc	r24, r20
    2dee:	38 f0       	brcs	.+14     	; 0x2dfe <__divsf3_pse+0x26>
    2df0:	9f 5f       	subi	r25, 0xFF	; 255
    2df2:	5f 4f       	sbci	r21, 0xFF	; 255
    2df4:	22 0f       	add	r18, r18
    2df6:	33 1f       	adc	r19, r19
    2df8:	44 1f       	adc	r20, r20
    2dfa:	aa 1f       	adc	r26, r26
    2dfc:	a9 f3       	breq	.-22     	; 0x2de8 <__divsf3_pse+0x10>
    2dfe:	35 d0       	rcall	.+106    	; 0x2e6a <__divsf3_pse+0x92>
    2e00:	0e 2e       	mov	r0, r30
    2e02:	3a f0       	brmi	.+14     	; 0x2e12 <__divsf3_pse+0x3a>
    2e04:	e0 e8       	ldi	r30, 0x80	; 128
    2e06:	32 d0       	rcall	.+100    	; 0x2e6c <__divsf3_pse+0x94>
    2e08:	91 50       	subi	r25, 0x01	; 1
    2e0a:	50 40       	sbci	r21, 0x00	; 0
    2e0c:	e6 95       	lsr	r30
    2e0e:	00 1c       	adc	r0, r0
    2e10:	ca f7       	brpl	.-14     	; 0x2e04 <__divsf3_pse+0x2c>
    2e12:	2b d0       	rcall	.+86     	; 0x2e6a <__divsf3_pse+0x92>
    2e14:	fe 2f       	mov	r31, r30
    2e16:	29 d0       	rcall	.+82     	; 0x2e6a <__divsf3_pse+0x92>
    2e18:	66 0f       	add	r22, r22
    2e1a:	77 1f       	adc	r23, r23
    2e1c:	88 1f       	adc	r24, r24
    2e1e:	bb 1f       	adc	r27, r27
    2e20:	26 17       	cp	r18, r22
    2e22:	37 07       	cpc	r19, r23
    2e24:	48 07       	cpc	r20, r24
    2e26:	ab 07       	cpc	r26, r27
    2e28:	b0 e8       	ldi	r27, 0x80	; 128
    2e2a:	09 f0       	breq	.+2      	; 0x2e2e <__divsf3_pse+0x56>
    2e2c:	bb 0b       	sbc	r27, r27
    2e2e:	80 2d       	mov	r24, r0
    2e30:	bf 01       	movw	r22, r30
    2e32:	ff 27       	eor	r31, r31
    2e34:	93 58       	subi	r25, 0x83	; 131
    2e36:	5f 4f       	sbci	r21, 0xFF	; 255
    2e38:	3a f0       	brmi	.+14     	; 0x2e48 <__divsf3_pse+0x70>
    2e3a:	9e 3f       	cpi	r25, 0xFE	; 254
    2e3c:	51 05       	cpc	r21, r1
    2e3e:	78 f0       	brcs	.+30     	; 0x2e5e <__divsf3_pse+0x86>
    2e40:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <__fp_inf>
    2e44:	0c 94 22 18 	jmp	0x3044	; 0x3044 <__fp_szero>
    2e48:	5f 3f       	cpi	r21, 0xFF	; 255
    2e4a:	e4 f3       	brlt	.-8      	; 0x2e44 <__divsf3_pse+0x6c>
    2e4c:	98 3e       	cpi	r25, 0xE8	; 232
    2e4e:	d4 f3       	brlt	.-12     	; 0x2e44 <__divsf3_pse+0x6c>
    2e50:	86 95       	lsr	r24
    2e52:	77 95       	ror	r23
    2e54:	67 95       	ror	r22
    2e56:	b7 95       	ror	r27
    2e58:	f7 95       	ror	r31
    2e5a:	9f 5f       	subi	r25, 0xFF	; 255
    2e5c:	c9 f7       	brne	.-14     	; 0x2e50 <__divsf3_pse+0x78>
    2e5e:	88 0f       	add	r24, r24
    2e60:	91 1d       	adc	r25, r1
    2e62:	96 95       	lsr	r25
    2e64:	87 95       	ror	r24
    2e66:	97 f9       	bld	r25, 7
    2e68:	08 95       	ret
    2e6a:	e1 e0       	ldi	r30, 0x01	; 1
    2e6c:	66 0f       	add	r22, r22
    2e6e:	77 1f       	adc	r23, r23
    2e70:	88 1f       	adc	r24, r24
    2e72:	bb 1f       	adc	r27, r27
    2e74:	62 17       	cp	r22, r18
    2e76:	73 07       	cpc	r23, r19
    2e78:	84 07       	cpc	r24, r20
    2e7a:	ba 07       	cpc	r27, r26
    2e7c:	20 f0       	brcs	.+8      	; 0x2e86 <__divsf3_pse+0xae>
    2e7e:	62 1b       	sub	r22, r18
    2e80:	73 0b       	sbc	r23, r19
    2e82:	84 0b       	sbc	r24, r20
    2e84:	ba 0b       	sbc	r27, r26
    2e86:	ee 1f       	adc	r30, r30
    2e88:	88 f7       	brcc	.-30     	; 0x2e6c <__divsf3_pse+0x94>
    2e8a:	e0 95       	com	r30
    2e8c:	08 95       	ret

00002e8e <__fixunssfsi>:
    2e8e:	0e 94 07 18 	call	0x300e	; 0x300e <__fp_splitA>
    2e92:	88 f0       	brcs	.+34     	; 0x2eb6 <__fixunssfsi+0x28>
    2e94:	9f 57       	subi	r25, 0x7F	; 127
    2e96:	98 f0       	brcs	.+38     	; 0x2ebe <__fixunssfsi+0x30>
    2e98:	b9 2f       	mov	r27, r25
    2e9a:	99 27       	eor	r25, r25
    2e9c:	b7 51       	subi	r27, 0x17	; 23
    2e9e:	b0 f0       	brcs	.+44     	; 0x2ecc <__fixunssfsi+0x3e>
    2ea0:	e1 f0       	breq	.+56     	; 0x2eda <__fixunssfsi+0x4c>
    2ea2:	66 0f       	add	r22, r22
    2ea4:	77 1f       	adc	r23, r23
    2ea6:	88 1f       	adc	r24, r24
    2ea8:	99 1f       	adc	r25, r25
    2eaa:	1a f0       	brmi	.+6      	; 0x2eb2 <__fixunssfsi+0x24>
    2eac:	ba 95       	dec	r27
    2eae:	c9 f7       	brne	.-14     	; 0x2ea2 <__fixunssfsi+0x14>
    2eb0:	14 c0       	rjmp	.+40     	; 0x2eda <__fixunssfsi+0x4c>
    2eb2:	b1 30       	cpi	r27, 0x01	; 1
    2eb4:	91 f0       	breq	.+36     	; 0x2eda <__fixunssfsi+0x4c>
    2eb6:	0e 94 21 18 	call	0x3042	; 0x3042 <__fp_zero>
    2eba:	b1 e0       	ldi	r27, 0x01	; 1
    2ebc:	08 95       	ret
    2ebe:	0c 94 21 18 	jmp	0x3042	; 0x3042 <__fp_zero>
    2ec2:	67 2f       	mov	r22, r23
    2ec4:	78 2f       	mov	r23, r24
    2ec6:	88 27       	eor	r24, r24
    2ec8:	b8 5f       	subi	r27, 0xF8	; 248
    2eca:	39 f0       	breq	.+14     	; 0x2eda <__fixunssfsi+0x4c>
    2ecc:	b9 3f       	cpi	r27, 0xF9	; 249
    2ece:	cc f3       	brlt	.-14     	; 0x2ec2 <__fixunssfsi+0x34>
    2ed0:	86 95       	lsr	r24
    2ed2:	77 95       	ror	r23
    2ed4:	67 95       	ror	r22
    2ed6:	b3 95       	inc	r27
    2ed8:	d9 f7       	brne	.-10     	; 0x2ed0 <__fixunssfsi+0x42>
    2eda:	3e f4       	brtc	.+14     	; 0x2eea <__fixunssfsi+0x5c>
    2edc:	90 95       	com	r25
    2ede:	80 95       	com	r24
    2ee0:	70 95       	com	r23
    2ee2:	61 95       	neg	r22
    2ee4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee6:	8f 4f       	sbci	r24, 0xFF	; 255
    2ee8:	9f 4f       	sbci	r25, 0xFF	; 255
    2eea:	08 95       	ret

00002eec <__floatunsisf>:
    2eec:	e8 94       	clt
    2eee:	09 c0       	rjmp	.+18     	; 0x2f02 <__floatsisf+0x12>

00002ef0 <__floatsisf>:
    2ef0:	97 fb       	bst	r25, 7
    2ef2:	3e f4       	brtc	.+14     	; 0x2f02 <__floatsisf+0x12>
    2ef4:	90 95       	com	r25
    2ef6:	80 95       	com	r24
    2ef8:	70 95       	com	r23
    2efa:	61 95       	neg	r22
    2efc:	7f 4f       	sbci	r23, 0xFF	; 255
    2efe:	8f 4f       	sbci	r24, 0xFF	; 255
    2f00:	9f 4f       	sbci	r25, 0xFF	; 255
    2f02:	99 23       	and	r25, r25
    2f04:	a9 f0       	breq	.+42     	; 0x2f30 <__floatsisf+0x40>
    2f06:	f9 2f       	mov	r31, r25
    2f08:	96 e9       	ldi	r25, 0x96	; 150
    2f0a:	bb 27       	eor	r27, r27
    2f0c:	93 95       	inc	r25
    2f0e:	f6 95       	lsr	r31
    2f10:	87 95       	ror	r24
    2f12:	77 95       	ror	r23
    2f14:	67 95       	ror	r22
    2f16:	b7 95       	ror	r27
    2f18:	f1 11       	cpse	r31, r1
    2f1a:	f8 cf       	rjmp	.-16     	; 0x2f0c <__floatsisf+0x1c>
    2f1c:	fa f4       	brpl	.+62     	; 0x2f5c <__floatsisf+0x6c>
    2f1e:	bb 0f       	add	r27, r27
    2f20:	11 f4       	brne	.+4      	; 0x2f26 <__floatsisf+0x36>
    2f22:	60 ff       	sbrs	r22, 0
    2f24:	1b c0       	rjmp	.+54     	; 0x2f5c <__floatsisf+0x6c>
    2f26:	6f 5f       	subi	r22, 0xFF	; 255
    2f28:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2a:	8f 4f       	sbci	r24, 0xFF	; 255
    2f2c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f2e:	16 c0       	rjmp	.+44     	; 0x2f5c <__floatsisf+0x6c>
    2f30:	88 23       	and	r24, r24
    2f32:	11 f0       	breq	.+4      	; 0x2f38 <__floatsisf+0x48>
    2f34:	96 e9       	ldi	r25, 0x96	; 150
    2f36:	11 c0       	rjmp	.+34     	; 0x2f5a <__floatsisf+0x6a>
    2f38:	77 23       	and	r23, r23
    2f3a:	21 f0       	breq	.+8      	; 0x2f44 <__floatsisf+0x54>
    2f3c:	9e e8       	ldi	r25, 0x8E	; 142
    2f3e:	87 2f       	mov	r24, r23
    2f40:	76 2f       	mov	r23, r22
    2f42:	05 c0       	rjmp	.+10     	; 0x2f4e <__floatsisf+0x5e>
    2f44:	66 23       	and	r22, r22
    2f46:	71 f0       	breq	.+28     	; 0x2f64 <__floatsisf+0x74>
    2f48:	96 e8       	ldi	r25, 0x86	; 134
    2f4a:	86 2f       	mov	r24, r22
    2f4c:	70 e0       	ldi	r23, 0x00	; 0
    2f4e:	60 e0       	ldi	r22, 0x00	; 0
    2f50:	2a f0       	brmi	.+10     	; 0x2f5c <__floatsisf+0x6c>
    2f52:	9a 95       	dec	r25
    2f54:	66 0f       	add	r22, r22
    2f56:	77 1f       	adc	r23, r23
    2f58:	88 1f       	adc	r24, r24
    2f5a:	da f7       	brpl	.-10     	; 0x2f52 <__floatsisf+0x62>
    2f5c:	88 0f       	add	r24, r24
    2f5e:	96 95       	lsr	r25
    2f60:	87 95       	ror	r24
    2f62:	97 f9       	bld	r25, 7
    2f64:	08 95       	ret

00002f66 <__fp_cmp>:
    2f66:	99 0f       	add	r25, r25
    2f68:	00 08       	sbc	r0, r0
    2f6a:	55 0f       	add	r21, r21
    2f6c:	aa 0b       	sbc	r26, r26
    2f6e:	e0 e8       	ldi	r30, 0x80	; 128
    2f70:	fe ef       	ldi	r31, 0xFE	; 254
    2f72:	16 16       	cp	r1, r22
    2f74:	17 06       	cpc	r1, r23
    2f76:	e8 07       	cpc	r30, r24
    2f78:	f9 07       	cpc	r31, r25
    2f7a:	c0 f0       	brcs	.+48     	; 0x2fac <__fp_cmp+0x46>
    2f7c:	12 16       	cp	r1, r18
    2f7e:	13 06       	cpc	r1, r19
    2f80:	e4 07       	cpc	r30, r20
    2f82:	f5 07       	cpc	r31, r21
    2f84:	98 f0       	brcs	.+38     	; 0x2fac <__fp_cmp+0x46>
    2f86:	62 1b       	sub	r22, r18
    2f88:	73 0b       	sbc	r23, r19
    2f8a:	84 0b       	sbc	r24, r20
    2f8c:	95 0b       	sbc	r25, r21
    2f8e:	39 f4       	brne	.+14     	; 0x2f9e <__fp_cmp+0x38>
    2f90:	0a 26       	eor	r0, r26
    2f92:	61 f0       	breq	.+24     	; 0x2fac <__fp_cmp+0x46>
    2f94:	23 2b       	or	r18, r19
    2f96:	24 2b       	or	r18, r20
    2f98:	25 2b       	or	r18, r21
    2f9a:	21 f4       	brne	.+8      	; 0x2fa4 <__fp_cmp+0x3e>
    2f9c:	08 95       	ret
    2f9e:	0a 26       	eor	r0, r26
    2fa0:	09 f4       	brne	.+2      	; 0x2fa4 <__fp_cmp+0x3e>
    2fa2:	a1 40       	sbci	r26, 0x01	; 1
    2fa4:	a6 95       	lsr	r26
    2fa6:	8f ef       	ldi	r24, 0xFF	; 255
    2fa8:	81 1d       	adc	r24, r1
    2faa:	81 1d       	adc	r24, r1
    2fac:	08 95       	ret

00002fae <__fp_inf>:
    2fae:	97 f9       	bld	r25, 7
    2fb0:	9f 67       	ori	r25, 0x7F	; 127
    2fb2:	80 e8       	ldi	r24, 0x80	; 128
    2fb4:	70 e0       	ldi	r23, 0x00	; 0
    2fb6:	60 e0       	ldi	r22, 0x00	; 0
    2fb8:	08 95       	ret

00002fba <__fp_nan>:
    2fba:	9f ef       	ldi	r25, 0xFF	; 255
    2fbc:	80 ec       	ldi	r24, 0xC0	; 192
    2fbe:	08 95       	ret

00002fc0 <__fp_pscA>:
    2fc0:	00 24       	eor	r0, r0
    2fc2:	0a 94       	dec	r0
    2fc4:	16 16       	cp	r1, r22
    2fc6:	17 06       	cpc	r1, r23
    2fc8:	18 06       	cpc	r1, r24
    2fca:	09 06       	cpc	r0, r25
    2fcc:	08 95       	ret

00002fce <__fp_pscB>:
    2fce:	00 24       	eor	r0, r0
    2fd0:	0a 94       	dec	r0
    2fd2:	12 16       	cp	r1, r18
    2fd4:	13 06       	cpc	r1, r19
    2fd6:	14 06       	cpc	r1, r20
    2fd8:	05 06       	cpc	r0, r21
    2fda:	08 95       	ret

00002fdc <__fp_round>:
    2fdc:	09 2e       	mov	r0, r25
    2fde:	03 94       	inc	r0
    2fe0:	00 0c       	add	r0, r0
    2fe2:	11 f4       	brne	.+4      	; 0x2fe8 <__fp_round+0xc>
    2fe4:	88 23       	and	r24, r24
    2fe6:	52 f0       	brmi	.+20     	; 0x2ffc <__fp_round+0x20>
    2fe8:	bb 0f       	add	r27, r27
    2fea:	40 f4       	brcc	.+16     	; 0x2ffc <__fp_round+0x20>
    2fec:	bf 2b       	or	r27, r31
    2fee:	11 f4       	brne	.+4      	; 0x2ff4 <__fp_round+0x18>
    2ff0:	60 ff       	sbrs	r22, 0
    2ff2:	04 c0       	rjmp	.+8      	; 0x2ffc <__fp_round+0x20>
    2ff4:	6f 5f       	subi	r22, 0xFF	; 255
    2ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ff8:	8f 4f       	sbci	r24, 0xFF	; 255
    2ffa:	9f 4f       	sbci	r25, 0xFF	; 255
    2ffc:	08 95       	ret

00002ffe <__fp_split3>:
    2ffe:	57 fd       	sbrc	r21, 7
    3000:	90 58       	subi	r25, 0x80	; 128
    3002:	44 0f       	add	r20, r20
    3004:	55 1f       	adc	r21, r21
    3006:	59 f0       	breq	.+22     	; 0x301e <__fp_splitA+0x10>
    3008:	5f 3f       	cpi	r21, 0xFF	; 255
    300a:	71 f0       	breq	.+28     	; 0x3028 <__fp_splitA+0x1a>
    300c:	47 95       	ror	r20

0000300e <__fp_splitA>:
    300e:	88 0f       	add	r24, r24
    3010:	97 fb       	bst	r25, 7
    3012:	99 1f       	adc	r25, r25
    3014:	61 f0       	breq	.+24     	; 0x302e <__fp_splitA+0x20>
    3016:	9f 3f       	cpi	r25, 0xFF	; 255
    3018:	79 f0       	breq	.+30     	; 0x3038 <__fp_splitA+0x2a>
    301a:	87 95       	ror	r24
    301c:	08 95       	ret
    301e:	12 16       	cp	r1, r18
    3020:	13 06       	cpc	r1, r19
    3022:	14 06       	cpc	r1, r20
    3024:	55 1f       	adc	r21, r21
    3026:	f2 cf       	rjmp	.-28     	; 0x300c <__fp_split3+0xe>
    3028:	46 95       	lsr	r20
    302a:	f1 df       	rcall	.-30     	; 0x300e <__fp_splitA>
    302c:	08 c0       	rjmp	.+16     	; 0x303e <__fp_splitA+0x30>
    302e:	16 16       	cp	r1, r22
    3030:	17 06       	cpc	r1, r23
    3032:	18 06       	cpc	r1, r24
    3034:	99 1f       	adc	r25, r25
    3036:	f1 cf       	rjmp	.-30     	; 0x301a <__fp_splitA+0xc>
    3038:	86 95       	lsr	r24
    303a:	71 05       	cpc	r23, r1
    303c:	61 05       	cpc	r22, r1
    303e:	08 94       	sec
    3040:	08 95       	ret

00003042 <__fp_zero>:
    3042:	e8 94       	clt

00003044 <__fp_szero>:
    3044:	bb 27       	eor	r27, r27
    3046:	66 27       	eor	r22, r22
    3048:	77 27       	eor	r23, r23
    304a:	cb 01       	movw	r24, r22
    304c:	97 f9       	bld	r25, 7
    304e:	08 95       	ret

00003050 <__mulsf3>:
    3050:	0e 94 3b 18 	call	0x3076	; 0x3076 <__mulsf3x>
    3054:	0c 94 ee 17 	jmp	0x2fdc	; 0x2fdc <__fp_round>
    3058:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <__fp_pscA>
    305c:	38 f0       	brcs	.+14     	; 0x306c <__mulsf3+0x1c>
    305e:	0e 94 e7 17 	call	0x2fce	; 0x2fce <__fp_pscB>
    3062:	20 f0       	brcs	.+8      	; 0x306c <__mulsf3+0x1c>
    3064:	95 23       	and	r25, r21
    3066:	11 f0       	breq	.+4      	; 0x306c <__mulsf3+0x1c>
    3068:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <__fp_inf>
    306c:	0c 94 dd 17 	jmp	0x2fba	; 0x2fba <__fp_nan>
    3070:	11 24       	eor	r1, r1
    3072:	0c 94 22 18 	jmp	0x3044	; 0x3044 <__fp_szero>

00003076 <__mulsf3x>:
    3076:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <__fp_split3>
    307a:	70 f3       	brcs	.-36     	; 0x3058 <__mulsf3+0x8>

0000307c <__mulsf3_pse>:
    307c:	95 9f       	mul	r25, r21
    307e:	c1 f3       	breq	.-16     	; 0x3070 <__mulsf3+0x20>
    3080:	95 0f       	add	r25, r21
    3082:	50 e0       	ldi	r21, 0x00	; 0
    3084:	55 1f       	adc	r21, r21
    3086:	62 9f       	mul	r22, r18
    3088:	f0 01       	movw	r30, r0
    308a:	72 9f       	mul	r23, r18
    308c:	bb 27       	eor	r27, r27
    308e:	f0 0d       	add	r31, r0
    3090:	b1 1d       	adc	r27, r1
    3092:	63 9f       	mul	r22, r19
    3094:	aa 27       	eor	r26, r26
    3096:	f0 0d       	add	r31, r0
    3098:	b1 1d       	adc	r27, r1
    309a:	aa 1f       	adc	r26, r26
    309c:	64 9f       	mul	r22, r20
    309e:	66 27       	eor	r22, r22
    30a0:	b0 0d       	add	r27, r0
    30a2:	a1 1d       	adc	r26, r1
    30a4:	66 1f       	adc	r22, r22
    30a6:	82 9f       	mul	r24, r18
    30a8:	22 27       	eor	r18, r18
    30aa:	b0 0d       	add	r27, r0
    30ac:	a1 1d       	adc	r26, r1
    30ae:	62 1f       	adc	r22, r18
    30b0:	73 9f       	mul	r23, r19
    30b2:	b0 0d       	add	r27, r0
    30b4:	a1 1d       	adc	r26, r1
    30b6:	62 1f       	adc	r22, r18
    30b8:	83 9f       	mul	r24, r19
    30ba:	a0 0d       	add	r26, r0
    30bc:	61 1d       	adc	r22, r1
    30be:	22 1f       	adc	r18, r18
    30c0:	74 9f       	mul	r23, r20
    30c2:	33 27       	eor	r19, r19
    30c4:	a0 0d       	add	r26, r0
    30c6:	61 1d       	adc	r22, r1
    30c8:	23 1f       	adc	r18, r19
    30ca:	84 9f       	mul	r24, r20
    30cc:	60 0d       	add	r22, r0
    30ce:	21 1d       	adc	r18, r1
    30d0:	82 2f       	mov	r24, r18
    30d2:	76 2f       	mov	r23, r22
    30d4:	6a 2f       	mov	r22, r26
    30d6:	11 24       	eor	r1, r1
    30d8:	9f 57       	subi	r25, 0x7F	; 127
    30da:	50 40       	sbci	r21, 0x00	; 0
    30dc:	9a f0       	brmi	.+38     	; 0x3104 <__mulsf3_pse+0x88>
    30de:	f1 f0       	breq	.+60     	; 0x311c <__mulsf3_pse+0xa0>
    30e0:	88 23       	and	r24, r24
    30e2:	4a f0       	brmi	.+18     	; 0x30f6 <__mulsf3_pse+0x7a>
    30e4:	ee 0f       	add	r30, r30
    30e6:	ff 1f       	adc	r31, r31
    30e8:	bb 1f       	adc	r27, r27
    30ea:	66 1f       	adc	r22, r22
    30ec:	77 1f       	adc	r23, r23
    30ee:	88 1f       	adc	r24, r24
    30f0:	91 50       	subi	r25, 0x01	; 1
    30f2:	50 40       	sbci	r21, 0x00	; 0
    30f4:	a9 f7       	brne	.-22     	; 0x30e0 <__mulsf3_pse+0x64>
    30f6:	9e 3f       	cpi	r25, 0xFE	; 254
    30f8:	51 05       	cpc	r21, r1
    30fa:	80 f0       	brcs	.+32     	; 0x311c <__mulsf3_pse+0xa0>
    30fc:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <__fp_inf>
    3100:	0c 94 22 18 	jmp	0x3044	; 0x3044 <__fp_szero>
    3104:	5f 3f       	cpi	r21, 0xFF	; 255
    3106:	e4 f3       	brlt	.-8      	; 0x3100 <__mulsf3_pse+0x84>
    3108:	98 3e       	cpi	r25, 0xE8	; 232
    310a:	d4 f3       	brlt	.-12     	; 0x3100 <__mulsf3_pse+0x84>
    310c:	86 95       	lsr	r24
    310e:	77 95       	ror	r23
    3110:	67 95       	ror	r22
    3112:	b7 95       	ror	r27
    3114:	f7 95       	ror	r31
    3116:	e7 95       	ror	r30
    3118:	9f 5f       	subi	r25, 0xFF	; 255
    311a:	c1 f7       	brne	.-16     	; 0x310c <__mulsf3_pse+0x90>
    311c:	fe 2b       	or	r31, r30
    311e:	88 0f       	add	r24, r24
    3120:	91 1d       	adc	r25, r1
    3122:	96 95       	lsr	r25
    3124:	87 95       	ror	r24
    3126:	97 f9       	bld	r25, 7
    3128:	08 95       	ret

0000312a <__udivmodsi4>:
    312a:	a1 e2       	ldi	r26, 0x21	; 33
    312c:	1a 2e       	mov	r1, r26
    312e:	aa 1b       	sub	r26, r26
    3130:	bb 1b       	sub	r27, r27
    3132:	fd 01       	movw	r30, r26
    3134:	0d c0       	rjmp	.+26     	; 0x3150 <__udivmodsi4_ep>

00003136 <__udivmodsi4_loop>:
    3136:	aa 1f       	adc	r26, r26
    3138:	bb 1f       	adc	r27, r27
    313a:	ee 1f       	adc	r30, r30
    313c:	ff 1f       	adc	r31, r31
    313e:	a2 17       	cp	r26, r18
    3140:	b3 07       	cpc	r27, r19
    3142:	e4 07       	cpc	r30, r20
    3144:	f5 07       	cpc	r31, r21
    3146:	20 f0       	brcs	.+8      	; 0x3150 <__udivmodsi4_ep>
    3148:	a2 1b       	sub	r26, r18
    314a:	b3 0b       	sbc	r27, r19
    314c:	e4 0b       	sbc	r30, r20
    314e:	f5 0b       	sbc	r31, r21

00003150 <__udivmodsi4_ep>:
    3150:	66 1f       	adc	r22, r22
    3152:	77 1f       	adc	r23, r23
    3154:	88 1f       	adc	r24, r24
    3156:	99 1f       	adc	r25, r25
    3158:	1a 94       	dec	r1
    315a:	69 f7       	brne	.-38     	; 0x3136 <__udivmodsi4_loop>
    315c:	60 95       	com	r22
    315e:	70 95       	com	r23
    3160:	80 95       	com	r24
    3162:	90 95       	com	r25
    3164:	9b 01       	movw	r18, r22
    3166:	ac 01       	movw	r20, r24
    3168:	bd 01       	movw	r22, r26
    316a:	cf 01       	movw	r24, r30
    316c:	08 95       	ret

0000316e <__tablejump2__>:
    316e:	ee 0f       	add	r30, r30
    3170:	ff 1f       	adc	r31, r31
    3172:	05 90       	lpm	r0, Z+
    3174:	f4 91       	lpm	r31, Z
    3176:	e0 2d       	mov	r30, r0
    3178:	09 94       	ijmp

0000317a <__umulhisi3>:
    317a:	a2 9f       	mul	r26, r18
    317c:	b0 01       	movw	r22, r0
    317e:	b3 9f       	mul	r27, r19
    3180:	c0 01       	movw	r24, r0
    3182:	a3 9f       	mul	r26, r19
    3184:	70 0d       	add	r23, r0
    3186:	81 1d       	adc	r24, r1
    3188:	11 24       	eor	r1, r1
    318a:	91 1d       	adc	r25, r1
    318c:	b2 9f       	mul	r27, r18
    318e:	70 0d       	add	r23, r0
    3190:	81 1d       	adc	r24, r1
    3192:	11 24       	eor	r1, r1
    3194:	91 1d       	adc	r25, r1
    3196:	08 95       	ret

00003198 <__muluhisi3>:
    3198:	0e 94 bd 18 	call	0x317a	; 0x317a <__umulhisi3>
    319c:	a5 9f       	mul	r26, r21
    319e:	90 0d       	add	r25, r0
    31a0:	b4 9f       	mul	r27, r20
    31a2:	90 0d       	add	r25, r0
    31a4:	a4 9f       	mul	r26, r20
    31a6:	80 0d       	add	r24, r0
    31a8:	91 1d       	adc	r25, r1
    31aa:	11 24       	eor	r1, r1
    31ac:	08 95       	ret

000031ae <_exit>:
    31ae:	f8 94       	cli

000031b0 <__stop_program>:
    31b0:	ff cf       	rjmp	.-2      	; 0x31b0 <__stop_program>
