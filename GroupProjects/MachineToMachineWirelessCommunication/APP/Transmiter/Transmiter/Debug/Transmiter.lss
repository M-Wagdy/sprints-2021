
Transmiter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003030  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000164  00800060  00003030  000030c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000060c  008001c4  008001c4  00003228  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003228  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003258  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000738  00000000  00000000  00003294  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006eba  00000000  00000000  000039cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002259  00000000  00000000  0000a886  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000483d  00000000  00000000  0000cadf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000105c  00000000  00000000  0001131c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000025a9  00000000  00000000  00012378  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005085  00000000  00000000  00014921  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000670  00000000  00000000  000199a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	34 c0       	rjmp	.+104    	; 0x6a <__ctors_end>
       2:	00 00       	nop
       4:	4f c0       	rjmp	.+158    	; 0xa4 <__bad_interrupt>
       6:	00 00       	nop
       8:	4d c0       	rjmp	.+154    	; 0xa4 <__bad_interrupt>
       a:	00 00       	nop
       c:	4b c0       	rjmp	.+150    	; 0xa4 <__bad_interrupt>
       e:	00 00       	nop
      10:	49 c0       	rjmp	.+146    	; 0xa4 <__bad_interrupt>
      12:	00 00       	nop
      14:	47 c0       	rjmp	.+142    	; 0xa4 <__bad_interrupt>
      16:	00 00       	nop
      18:	45 c0       	rjmp	.+138    	; 0xa4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	23 c2       	rjmp	.+1094   	; 0x464 <__vector_7>
      1e:	00 00       	nop
      20:	41 c0       	rjmp	.+130    	; 0xa4 <__bad_interrupt>
      22:	00 00       	nop
      24:	3f c0       	rjmp	.+126    	; 0xa4 <__bad_interrupt>
      26:	00 00       	nop
      28:	3d c0       	rjmp	.+122    	; 0xa4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3b c0       	rjmp	.+118    	; 0xa4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	39 c0       	rjmp	.+114    	; 0xa4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 1a 11 	jmp	0x2234	; 0x2234 <__vector_13>
      38:	35 c0       	rjmp	.+106    	; 0xa4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	33 c0       	rjmp	.+102    	; 0xa4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	31 c0       	rjmp	.+98     	; 0xa4 <__bad_interrupt>
      42:	00 00       	nop
      44:	2f c0       	rjmp	.+94     	; 0xa4 <__bad_interrupt>
      46:	00 00       	nop
      48:	2d c0       	rjmp	.+90     	; 0xa4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2b c0       	rjmp	.+86     	; 0xa4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	29 c0       	rjmp	.+82     	; 0xa4 <__bad_interrupt>
      52:	00 00       	nop
      54:	24 13       	cpse	r18, r20
      56:	3a 13       	cpse	r19, r26
      58:	22 13       	cpse	r18, r18
      5a:	50 13       	cpse	r21, r16
      5c:	7d 13       	cpse	r23, r29
      5e:	8b 13       	cpse	r24, r27
      60:	94 13       	cpse	r25, r20
      62:	dd 13       	cpse	r29, r29
      64:	f1 13       	cpse	r31, r17
      66:	18 14       	cp	r1, r8
      68:	14 14       	cp	r1, r4

0000006a <__ctors_end>:
      6a:	11 24       	eor	r1, r1
      6c:	1f be       	out	0x3f, r1	; 63
      6e:	cf e5       	ldi	r28, 0x5F	; 95
      70:	d8 e0       	ldi	r29, 0x08	; 8
      72:	de bf       	out	0x3e, r29	; 62
      74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a0 e6       	ldi	r26, 0x60	; 96
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	e0 e3       	ldi	r30, 0x30	; 48
      7e:	f0 e3       	ldi	r31, 0x30	; 48
      80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
      82:	05 90       	lpm	r0, Z+
      84:	0d 92       	st	X+, r0
      86:	a4 3c       	cpi	r26, 0xC4	; 196
      88:	b1 07       	cpc	r27, r17
      8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
      8c:	27 e0       	ldi	r18, 0x07	; 7
      8e:	a4 ec       	ldi	r26, 0xC4	; 196
      90:	b1 e0       	ldi	r27, 0x01	; 1
      92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
      94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
      96:	a0 3d       	cpi	r26, 0xD0	; 208
      98:	b2 07       	cpc	r27, r18
      9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>
      9c:	0e 94 01 16 	call	0x2c02	; 0x2c02 <main>
      a0:	0c 94 16 18 	jmp	0x302c	; 0x302c <_exit>

000000a4 <__bad_interrupt>:
      a4:	ad cf       	rjmp	.-166    	; 0x0 <__vectors>

000000a6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      a6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a8:	03 96       	adiw	r24, 0x03	; 3
      aa:	92 83       	std	Z+2, r25	; 0x02
      ac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      ae:	2f ef       	ldi	r18, 0xFF	; 255
      b0:	3f ef       	ldi	r19, 0xFF	; 255
      b2:	34 83       	std	Z+4, r19	; 0x04
      b4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      b6:	96 83       	std	Z+6, r25	; 0x06
      b8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ba:	90 87       	std	Z+8, r25	; 0x08
      bc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      be:	10 82       	st	Z, r1
      c0:	08 95       	ret

000000c2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      c2:	fc 01       	movw	r30, r24
      c4:	11 86       	std	Z+9, r1	; 0x09
      c6:	10 86       	std	Z+8, r1	; 0x08
      c8:	08 95       	ret

000000ca <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	9c 01       	movw	r18, r24
      d0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      d2:	dc 01       	movw	r26, r24
      d4:	11 96       	adiw	r26, 0x01	; 1
      d6:	cd 91       	ld	r28, X+
      d8:	dc 91       	ld	r29, X
      da:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      dc:	d3 83       	std	Z+3, r29	; 0x03
      de:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      e0:	8c 81       	ldd	r24, Y+4	; 0x04
      e2:	9d 81       	ldd	r25, Y+5	; 0x05
      e4:	95 83       	std	Z+5, r25	; 0x05
      e6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      e8:	8c 81       	ldd	r24, Y+4	; 0x04
      ea:	9d 81       	ldd	r25, Y+5	; 0x05
      ec:	dc 01       	movw	r26, r24
      ee:	13 96       	adiw	r26, 0x03	; 3
      f0:	7c 93       	st	X, r23
      f2:	6e 93       	st	-X, r22
      f4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
      f6:	7d 83       	std	Y+5, r23	; 0x05
      f8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
      fa:	31 87       	std	Z+9, r19	; 0x09
      fc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
      fe:	f9 01       	movw	r30, r18
     100:	80 81       	ld	r24, Z
     102:	8f 5f       	subi	r24, 0xFF	; 255
     104:	80 83       	st	Z, r24
}
     106:	df 91       	pop	r29
     108:	cf 91       	pop	r28
     10a:	08 95       	ret

0000010c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     10c:	cf 93       	push	r28
     10e:	df 93       	push	r29
     110:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     112:	48 81       	ld	r20, Y
     114:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     116:	4f 3f       	cpi	r20, 0xFF	; 255
     118:	2f ef       	ldi	r18, 0xFF	; 255
     11a:	52 07       	cpc	r21, r18
     11c:	21 f4       	brne	.+8      	; 0x126 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     11e:	fc 01       	movw	r30, r24
     120:	a7 81       	ldd	r26, Z+7	; 0x07
     122:	b0 85       	ldd	r27, Z+8	; 0x08
     124:	0d c0       	rjmp	.+26     	; 0x140 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     126:	dc 01       	movw	r26, r24
     128:	13 96       	adiw	r26, 0x03	; 3
     12a:	01 c0       	rjmp	.+2      	; 0x12e <vListInsert+0x22>
     12c:	df 01       	movw	r26, r30
     12e:	12 96       	adiw	r26, 0x02	; 2
     130:	ed 91       	ld	r30, X+
     132:	fc 91       	ld	r31, X
     134:	13 97       	sbiw	r26, 0x03	; 3
     136:	20 81       	ld	r18, Z
     138:	31 81       	ldd	r19, Z+1	; 0x01
     13a:	42 17       	cp	r20, r18
     13c:	53 07       	cpc	r21, r19
     13e:	b0 f7       	brcc	.-20     	; 0x12c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     140:	12 96       	adiw	r26, 0x02	; 2
     142:	ed 91       	ld	r30, X+
     144:	fc 91       	ld	r31, X
     146:	13 97       	sbiw	r26, 0x03	; 3
     148:	fb 83       	std	Y+3, r31	; 0x03
     14a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     14c:	d5 83       	std	Z+5, r29	; 0x05
     14e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     150:	bd 83       	std	Y+5, r27	; 0x05
     152:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     154:	13 96       	adiw	r26, 0x03	; 3
     156:	dc 93       	st	X, r29
     158:	ce 93       	st	-X, r28
     15a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     15c:	99 87       	std	Y+9, r25	; 0x09
     15e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     160:	fc 01       	movw	r30, r24
     162:	20 81       	ld	r18, Z
     164:	2f 5f       	subi	r18, 0xFF	; 255
     166:	20 83       	st	Z, r18
}
     168:	df 91       	pop	r29
     16a:	cf 91       	pop	r28
     16c:	08 95       	ret

0000016e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     16e:	cf 93       	push	r28
     170:	df 93       	push	r29
     172:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     174:	a0 85       	ldd	r26, Z+8	; 0x08
     176:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     178:	c2 81       	ldd	r28, Z+2	; 0x02
     17a:	d3 81       	ldd	r29, Z+3	; 0x03
     17c:	84 81       	ldd	r24, Z+4	; 0x04
     17e:	95 81       	ldd	r25, Z+5	; 0x05
     180:	9d 83       	std	Y+5, r25	; 0x05
     182:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     184:	c4 81       	ldd	r28, Z+4	; 0x04
     186:	d5 81       	ldd	r29, Z+5	; 0x05
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	93 81       	ldd	r25, Z+3	; 0x03
     18c:	9b 83       	std	Y+3, r25	; 0x03
     18e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     190:	11 96       	adiw	r26, 0x01	; 1
     192:	8d 91       	ld	r24, X+
     194:	9c 91       	ld	r25, X
     196:	12 97       	sbiw	r26, 0x02	; 2
     198:	e8 17       	cp	r30, r24
     19a:	f9 07       	cpc	r31, r25
     19c:	31 f4       	brne	.+12     	; 0x1aa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     19e:	84 81       	ldd	r24, Z+4	; 0x04
     1a0:	95 81       	ldd	r25, Z+5	; 0x05
     1a2:	12 96       	adiw	r26, 0x02	; 2
     1a4:	9c 93       	st	X, r25
     1a6:	8e 93       	st	-X, r24
     1a8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1aa:	11 86       	std	Z+9, r1	; 0x09
     1ac:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1ae:	8c 91       	ld	r24, X
     1b0:	81 50       	subi	r24, 0x01	; 1
     1b2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1b4:	df 91       	pop	r29
     1b6:	cf 91       	pop	r28
     1b8:	08 95       	ret

000001ba <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     1ba:	1b bc       	out	0x2b, r1	; 43
     1bc:	89 ef       	ldi	r24, 0xF9	; 249
     1be:	8a bd       	out	0x2a, r24	; 42
     1c0:	8b e0       	ldi	r24, 0x0B	; 11
     1c2:	8e bd       	out	0x2e, r24	; 46
     1c4:	89 b7       	in	r24, 0x39	; 57
     1c6:	80 61       	ori	r24, 0x10	; 16
     1c8:	89 bf       	out	0x39, r24	; 57
     1ca:	08 95       	ret

000001cc <pxPortInitialiseStack>:
     1cc:	31 e1       	ldi	r19, 0x11	; 17
     1ce:	fc 01       	movw	r30, r24
     1d0:	30 83       	st	Z, r19
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	22 e2       	ldi	r18, 0x22	; 34
     1d6:	20 83       	st	Z, r18
     1d8:	31 97       	sbiw	r30, 0x01	; 1
     1da:	a3 e3       	ldi	r26, 0x33	; 51
     1dc:	a0 83       	st	Z, r26
     1de:	31 97       	sbiw	r30, 0x01	; 1
     1e0:	60 83       	st	Z, r22
     1e2:	31 97       	sbiw	r30, 0x01	; 1
     1e4:	70 83       	st	Z, r23
     1e6:	31 97       	sbiw	r30, 0x01	; 1
     1e8:	10 82       	st	Z, r1
     1ea:	31 97       	sbiw	r30, 0x01	; 1
     1ec:	60 e8       	ldi	r22, 0x80	; 128
     1ee:	60 83       	st	Z, r22
     1f0:	31 97       	sbiw	r30, 0x01	; 1
     1f2:	10 82       	st	Z, r1
     1f4:	31 97       	sbiw	r30, 0x01	; 1
     1f6:	62 e0       	ldi	r22, 0x02	; 2
     1f8:	60 83       	st	Z, r22
     1fa:	31 97       	sbiw	r30, 0x01	; 1
     1fc:	63 e0       	ldi	r22, 0x03	; 3
     1fe:	60 83       	st	Z, r22
     200:	31 97       	sbiw	r30, 0x01	; 1
     202:	64 e0       	ldi	r22, 0x04	; 4
     204:	60 83       	st	Z, r22
     206:	31 97       	sbiw	r30, 0x01	; 1
     208:	65 e0       	ldi	r22, 0x05	; 5
     20a:	60 83       	st	Z, r22
     20c:	31 97       	sbiw	r30, 0x01	; 1
     20e:	66 e0       	ldi	r22, 0x06	; 6
     210:	60 83       	st	Z, r22
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	67 e0       	ldi	r22, 0x07	; 7
     216:	60 83       	st	Z, r22
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	68 e0       	ldi	r22, 0x08	; 8
     21c:	60 83       	st	Z, r22
     21e:	31 97       	sbiw	r30, 0x01	; 1
     220:	69 e0       	ldi	r22, 0x09	; 9
     222:	60 83       	st	Z, r22
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	60 e1       	ldi	r22, 0x10	; 16
     228:	60 83       	st	Z, r22
     22a:	31 97       	sbiw	r30, 0x01	; 1
     22c:	30 83       	st	Z, r19
     22e:	31 97       	sbiw	r30, 0x01	; 1
     230:	32 e1       	ldi	r19, 0x12	; 18
     232:	30 83       	st	Z, r19
     234:	31 97       	sbiw	r30, 0x01	; 1
     236:	33 e1       	ldi	r19, 0x13	; 19
     238:	30 83       	st	Z, r19
     23a:	31 97       	sbiw	r30, 0x01	; 1
     23c:	34 e1       	ldi	r19, 0x14	; 20
     23e:	30 83       	st	Z, r19
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	35 e1       	ldi	r19, 0x15	; 21
     244:	30 83       	st	Z, r19
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	36 e1       	ldi	r19, 0x16	; 22
     24a:	30 83       	st	Z, r19
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	37 e1       	ldi	r19, 0x17	; 23
     250:	30 83       	st	Z, r19
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	38 e1       	ldi	r19, 0x18	; 24
     256:	30 83       	st	Z, r19
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	39 e1       	ldi	r19, 0x19	; 25
     25c:	30 83       	st	Z, r19
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	30 e2       	ldi	r19, 0x20	; 32
     262:	30 83       	st	Z, r19
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	31 e2       	ldi	r19, 0x21	; 33
     268:	30 83       	st	Z, r19
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	20 83       	st	Z, r18
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	23 e2       	ldi	r18, 0x23	; 35
     272:	20 83       	st	Z, r18
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	40 83       	st	Z, r20
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	50 83       	st	Z, r21
     27c:	31 97       	sbiw	r30, 0x01	; 1
     27e:	26 e2       	ldi	r18, 0x26	; 38
     280:	20 83       	st	Z, r18
     282:	31 97       	sbiw	r30, 0x01	; 1
     284:	27 e2       	ldi	r18, 0x27	; 39
     286:	20 83       	st	Z, r18
     288:	31 97       	sbiw	r30, 0x01	; 1
     28a:	28 e2       	ldi	r18, 0x28	; 40
     28c:	20 83       	st	Z, r18
     28e:	31 97       	sbiw	r30, 0x01	; 1
     290:	29 e2       	ldi	r18, 0x29	; 41
     292:	20 83       	st	Z, r18
     294:	31 97       	sbiw	r30, 0x01	; 1
     296:	20 e3       	ldi	r18, 0x30	; 48
     298:	20 83       	st	Z, r18
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	21 e3       	ldi	r18, 0x31	; 49
     29e:	20 83       	st	Z, r18
     2a0:	86 97       	sbiw	r24, 0x26	; 38
     2a2:	08 95       	ret

000002a4 <xPortStartScheduler>:
     2a4:	8a df       	rcall	.-236    	; 0x1ba <prvSetupTimerInterrupt>
     2a6:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <pxCurrentTCB>
     2aa:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     2ae:	cd 91       	ld	r28, X+
     2b0:	cd bf       	out	0x3d, r28	; 61
     2b2:	dd 91       	ld	r29, X+
     2b4:	de bf       	out	0x3e, r29	; 62
     2b6:	ff 91       	pop	r31
     2b8:	ef 91       	pop	r30
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	bf 91       	pop	r27
     2c0:	af 91       	pop	r26
     2c2:	9f 91       	pop	r25
     2c4:	8f 91       	pop	r24
     2c6:	7f 91       	pop	r23
     2c8:	6f 91       	pop	r22
     2ca:	5f 91       	pop	r21
     2cc:	4f 91       	pop	r20
     2ce:	3f 91       	pop	r19
     2d0:	2f 91       	pop	r18
     2d2:	1f 91       	pop	r17
     2d4:	0f 91       	pop	r16
     2d6:	ff 90       	pop	r15
     2d8:	ef 90       	pop	r14
     2da:	df 90       	pop	r13
     2dc:	cf 90       	pop	r12
     2de:	bf 90       	pop	r11
     2e0:	af 90       	pop	r10
     2e2:	9f 90       	pop	r9
     2e4:	8f 90       	pop	r8
     2e6:	7f 90       	pop	r7
     2e8:	6f 90       	pop	r6
     2ea:	5f 90       	pop	r5
     2ec:	4f 90       	pop	r4
     2ee:	3f 90       	pop	r3
     2f0:	2f 90       	pop	r2
     2f2:	1f 90       	pop	r1
     2f4:	0f 90       	pop	r0
     2f6:	0f be       	out	0x3f, r0	; 63
     2f8:	0f 90       	pop	r0
     2fa:	08 95       	ret
     2fc:	81 e0       	ldi	r24, 0x01	; 1
     2fe:	08 95       	ret

00000300 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     300:	0f 92       	push	r0
     302:	0f b6       	in	r0, 0x3f	; 63
     304:	f8 94       	cli
     306:	0f 92       	push	r0
     308:	1f 92       	push	r1
     30a:	11 24       	eor	r1, r1
     30c:	2f 92       	push	r2
     30e:	3f 92       	push	r3
     310:	4f 92       	push	r4
     312:	5f 92       	push	r5
     314:	6f 92       	push	r6
     316:	7f 92       	push	r7
     318:	8f 92       	push	r8
     31a:	9f 92       	push	r9
     31c:	af 92       	push	r10
     31e:	bf 92       	push	r11
     320:	cf 92       	push	r12
     322:	df 92       	push	r13
     324:	ef 92       	push	r14
     326:	ff 92       	push	r15
     328:	0f 93       	push	r16
     32a:	1f 93       	push	r17
     32c:	2f 93       	push	r18
     32e:	3f 93       	push	r19
     330:	4f 93       	push	r20
     332:	5f 93       	push	r21
     334:	6f 93       	push	r22
     336:	7f 93       	push	r23
     338:	8f 93       	push	r24
     33a:	9f 93       	push	r25
     33c:	af 93       	push	r26
     33e:	bf 93       	push	r27
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	ef 93       	push	r30
     346:	ff 93       	push	r31
     348:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <pxCurrentTCB>
     34c:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     350:	0d b6       	in	r0, 0x3d	; 61
     352:	0d 92       	st	X+, r0
     354:	0e b6       	in	r0, 0x3e	; 62
     356:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     358:	f5 d4       	rcall	.+2538   	; 0xd44 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     35a:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <pxCurrentTCB>
     35e:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     362:	cd 91       	ld	r28, X+
     364:	cd bf       	out	0x3d, r28	; 61
     366:	dd 91       	ld	r29, X+
     368:	de bf       	out	0x3e, r29	; 62
     36a:	ff 91       	pop	r31
     36c:	ef 91       	pop	r30
     36e:	df 91       	pop	r29
     370:	cf 91       	pop	r28
     372:	bf 91       	pop	r27
     374:	af 91       	pop	r26
     376:	9f 91       	pop	r25
     378:	8f 91       	pop	r24
     37a:	7f 91       	pop	r23
     37c:	6f 91       	pop	r22
     37e:	5f 91       	pop	r21
     380:	4f 91       	pop	r20
     382:	3f 91       	pop	r19
     384:	2f 91       	pop	r18
     386:	1f 91       	pop	r17
     388:	0f 91       	pop	r16
     38a:	ff 90       	pop	r15
     38c:	ef 90       	pop	r14
     38e:	df 90       	pop	r13
     390:	cf 90       	pop	r12
     392:	bf 90       	pop	r11
     394:	af 90       	pop	r10
     396:	9f 90       	pop	r9
     398:	8f 90       	pop	r8
     39a:	7f 90       	pop	r7
     39c:	6f 90       	pop	r6
     39e:	5f 90       	pop	r5
     3a0:	4f 90       	pop	r4
     3a2:	3f 90       	pop	r3
     3a4:	2f 90       	pop	r2
     3a6:	1f 90       	pop	r1
     3a8:	0f 90       	pop	r0
     3aa:	0f be       	out	0x3f, r0	; 63
     3ac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     3ae:	08 95       	ret

000003b0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3b0:	0f 92       	push	r0
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0
     3b8:	1f 92       	push	r1
     3ba:	11 24       	eor	r1, r1
     3bc:	2f 92       	push	r2
     3be:	3f 92       	push	r3
     3c0:	4f 92       	push	r4
     3c2:	5f 92       	push	r5
     3c4:	6f 92       	push	r6
     3c6:	7f 92       	push	r7
     3c8:	8f 92       	push	r8
     3ca:	9f 92       	push	r9
     3cc:	af 92       	push	r10
     3ce:	bf 92       	push	r11
     3d0:	cf 92       	push	r12
     3d2:	df 92       	push	r13
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
     3da:	1f 93       	push	r17
     3dc:	2f 93       	push	r18
     3de:	3f 93       	push	r19
     3e0:	4f 93       	push	r20
     3e2:	5f 93       	push	r21
     3e4:	6f 93       	push	r22
     3e6:	7f 93       	push	r23
     3e8:	8f 93       	push	r24
     3ea:	9f 93       	push	r25
     3ec:	af 93       	push	r26
     3ee:	bf 93       	push	r27
     3f0:	cf 93       	push	r28
     3f2:	df 93       	push	r29
     3f4:	ef 93       	push	r30
     3f6:	ff 93       	push	r31
     3f8:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <pxCurrentTCB>
     3fc:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     400:	0d b6       	in	r0, 0x3d	; 61
     402:	0d 92       	st	X+, r0
     404:	0e b6       	in	r0, 0x3e	; 62
     406:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     408:	3e d3       	rcall	.+1660   	; 0xa86 <xTaskIncrementTick>
     40a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     40c:	9b d4       	rcall	.+2358   	; 0xd44 <vTaskSwitchContext>
     40e:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
     412:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     416:	cd 91       	ld	r28, X+
     418:	cd bf       	out	0x3d, r28	; 61
     41a:	dd 91       	ld	r29, X+
     41c:	de bf       	out	0x3e, r29	; 62
     41e:	ff 91       	pop	r31
     420:	ef 91       	pop	r30
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	bf 91       	pop	r27
     428:	af 91       	pop	r26
     42a:	9f 91       	pop	r25
     42c:	8f 91       	pop	r24
     42e:	7f 91       	pop	r23
     430:	6f 91       	pop	r22
     432:	5f 91       	pop	r21
     434:	4f 91       	pop	r20
     436:	3f 91       	pop	r19
     438:	2f 91       	pop	r18
     43a:	1f 91       	pop	r17
     43c:	0f 91       	pop	r16
     43e:	ff 90       	pop	r15
     440:	ef 90       	pop	r14
     442:	df 90       	pop	r13
     444:	cf 90       	pop	r12
     446:	bf 90       	pop	r11
     448:	af 90       	pop	r10
     44a:	9f 90       	pop	r9
     44c:	8f 90       	pop	r8
     44e:	7f 90       	pop	r7
     450:	6f 90       	pop	r6
     452:	5f 90       	pop	r5
     454:	4f 90       	pop	r4
     456:	3f 90       	pop	r3
     458:	2f 90       	pop	r2
     45a:	1f 90       	pop	r1
     45c:	0f 90       	pop	r0
     45e:	0f be       	out	0x3f, r0	; 63
     460:	0f 90       	pop	r0
     462:	08 95       	ret

00000464 <__vector_7>:

	asm volatile ( "ret" );
     464:	a5 df       	rcall	.-182    	; 0x3b0 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     466:	18 95       	reti

00000468 <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     468:	ec ec       	ldi	r30, 0xCC	; 204
     46a:	f1 e0       	ldi	r31, 0x01	; 1
     46c:	a0 ed       	ldi	r26, 0xD0	; 208
     46e:	b1 e0       	ldi	r27, 0x01	; 1
     470:	b1 83       	std	Z+1, r27	; 0x01
     472:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     474:	13 82       	std	Z+3, r1	; 0x03
     476:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     478:	e4 eb       	ldi	r30, 0xB4	; 180
     47a:	f5 e0       	ldi	r31, 0x05	; 5
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     47c:	f0 93 cb 01 	sts	0x01CB, r31	; 0x8001cb <pxEnd+0x1>
     480:	e0 93 ca 01 	sts	0x01CA, r30	; 0x8001ca <pxEnd>
	pxEnd->xBlockSize = 0;
     484:	13 82       	std	Z+3, r1	; 0x03
     486:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     488:	11 82       	std	Z+1, r1	; 0x01
     48a:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     48c:	84 ee       	ldi	r24, 0xE4	; 228
     48e:	93 e0       	ldi	r25, 0x03	; 3
     490:	13 96       	adiw	r26, 0x03	; 3
     492:	9c 93       	st	X, r25
     494:	8e 93       	st	-X, r24
     496:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     498:	ed 93       	st	X+, r30
     49a:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     49c:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <xMinimumEverFreeBytesRemaining+0x1>
     4a0:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4a4:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <xFreeBytesRemaining+0x1>
     4a8:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	90 e8       	ldi	r25, 0x80	; 128
     4b0:	90 93 c5 01 	sts	0x01C5, r25	; 0x8001c5 <__data_end+0x1>
     4b4:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__data_end>
     4b8:	08 95       	ret

000004ba <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     4ba:	cf 93       	push	r28
     4bc:	df 93       	push	r29
     4be:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     4c0:	ac ec       	ldi	r26, 0xCC	; 204
     4c2:	b1 e0       	ldi	r27, 0x01	; 1
     4c4:	01 c0       	rjmp	.+2      	; 0x4c8 <prvInsertBlockIntoFreeList+0xe>
     4c6:	df 01       	movw	r26, r30
     4c8:	ed 91       	ld	r30, X+
     4ca:	fc 91       	ld	r31, X
     4cc:	11 97       	sbiw	r26, 0x01	; 1
     4ce:	ec 17       	cp	r30, r28
     4d0:	fd 07       	cpc	r31, r29
     4d2:	c8 f3       	brcs	.-14     	; 0x4c6 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     4d4:	12 96       	adiw	r26, 0x02	; 2
     4d6:	8d 91       	ld	r24, X+
     4d8:	9c 91       	ld	r25, X
     4da:	13 97       	sbiw	r26, 0x03	; 3
     4dc:	9d 01       	movw	r18, r26
     4de:	28 0f       	add	r18, r24
     4e0:	39 1f       	adc	r19, r25
     4e2:	c2 17       	cp	r28, r18
     4e4:	d3 07       	cpc	r29, r19
     4e6:	49 f4       	brne	.+18     	; 0x4fa <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     4e8:	2a 81       	ldd	r18, Y+2	; 0x02
     4ea:	3b 81       	ldd	r19, Y+3	; 0x03
     4ec:	82 0f       	add	r24, r18
     4ee:	93 1f       	adc	r25, r19
     4f0:	13 96       	adiw	r26, 0x03	; 3
     4f2:	9c 93       	st	X, r25
     4f4:	8e 93       	st	-X, r24
     4f6:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     4f8:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     4fa:	8a 81       	ldd	r24, Y+2	; 0x02
     4fc:	9b 81       	ldd	r25, Y+3	; 0x03
     4fe:	9e 01       	movw	r18, r28
     500:	28 0f       	add	r18, r24
     502:	39 1f       	adc	r19, r25
     504:	e2 17       	cp	r30, r18
     506:	f3 07       	cpc	r31, r19
     508:	c1 f4       	brne	.+48     	; 0x53a <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     50a:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <pxEnd>
     50e:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <pxEnd+0x1>
     512:	e2 17       	cp	r30, r18
     514:	f3 07       	cpc	r31, r19
     516:	71 f0       	breq	.+28     	; 0x534 <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     518:	22 81       	ldd	r18, Z+2	; 0x02
     51a:	33 81       	ldd	r19, Z+3	; 0x03
     51c:	82 0f       	add	r24, r18
     51e:	93 1f       	adc	r25, r19
     520:	9b 83       	std	Y+3, r25	; 0x03
     522:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     524:	ed 91       	ld	r30, X+
     526:	fc 91       	ld	r31, X
     528:	11 97       	sbiw	r26, 0x01	; 1
     52a:	80 81       	ld	r24, Z
     52c:	91 81       	ldd	r25, Z+1	; 0x01
     52e:	99 83       	std	Y+1, r25	; 0x01
     530:	88 83       	st	Y, r24
     532:	05 c0       	rjmp	.+10     	; 0x53e <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     534:	39 83       	std	Y+1, r19	; 0x01
     536:	28 83       	st	Y, r18
     538:	02 c0       	rjmp	.+4      	; 0x53e <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     53a:	f9 83       	std	Y+1, r31	; 0x01
     53c:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     53e:	ca 17       	cp	r28, r26
     540:	db 07       	cpc	r29, r27
     542:	11 f0       	breq	.+4      	; 0x548 <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     544:	cd 93       	st	X+, r28
     546:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	08 95       	ret

0000054e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     54e:	ef 92       	push	r14
     550:	ff 92       	push	r15
     552:	0f 93       	push	r16
     554:	1f 93       	push	r17
     556:	cf 93       	push	r28
     558:	df 93       	push	r29
     55a:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     55c:	84 d2       	rcall	.+1288   	; 0xa66 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     55e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <pxEnd>
     562:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <pxEnd+0x1>
     566:	89 2b       	or	r24, r25
		{
			prvHeapInit();
     568:	09 f4       	brne	.+2      	; 0x56c <pvPortMalloc+0x1e>
     56a:	7e df       	rcall	.-260    	; 0x468 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     56c:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <__data_end>
     570:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <__data_end+0x1>
     574:	80 23       	and	r24, r16
     576:	91 23       	and	r25, r17
     578:	89 2b       	or	r24, r25
     57a:	09 f0       	breq	.+2      	; 0x57e <pvPortMalloc+0x30>
     57c:	66 c0       	rjmp	.+204    	; 0x64a <pvPortMalloc+0xfc>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     57e:	01 15       	cp	r16, r1
     580:	11 05       	cpc	r17, r1
     582:	11 f0       	breq	.+4      	; 0x588 <pvPortMalloc+0x3a>
			{
				xWantedSize += xHeapStructSize;
     584:	0c 5f       	subi	r16, 0xFC	; 252
     586:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     588:	01 15       	cp	r16, r1
     58a:	11 05       	cpc	r17, r1
     58c:	09 f4       	brne	.+2      	; 0x590 <pvPortMalloc+0x42>
     58e:	60 c0       	rjmp	.+192    	; 0x650 <pvPortMalloc+0x102>
     590:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <xFreeBytesRemaining>
     594:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <xFreeBytesRemaining+0x1>
     598:	80 17       	cp	r24, r16
     59a:	91 07       	cpc	r25, r17
     59c:	08 f4       	brcc	.+2      	; 0x5a0 <pvPortMalloc+0x52>
     59e:	5b c0       	rjmp	.+182    	; 0x656 <pvPortMalloc+0x108>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     5a0:	c0 91 cc 01 	lds	r28, 0x01CC	; 0x8001cc <xStart>
     5a4:	d0 91 cd 01 	lds	r29, 0x01CD	; 0x8001cd <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5a8:	ec ec       	ldi	r30, 0xCC	; 204
     5aa:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <pvPortMalloc+0x64>
				{
					pxPreviousBlock = pxBlock;
     5ae:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     5b0:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5b2:	8a 81       	ldd	r24, Y+2	; 0x02
     5b4:	9b 81       	ldd	r25, Y+3	; 0x03
     5b6:	80 17       	cp	r24, r16
     5b8:	91 07       	cpc	r25, r17
     5ba:	20 f4       	brcc	.+8      	; 0x5c4 <pvPortMalloc+0x76>
     5bc:	88 81       	ld	r24, Y
     5be:	99 81       	ldd	r25, Y+1	; 0x01
     5c0:	00 97       	sbiw	r24, 0x00	; 0
     5c2:	a9 f7       	brne	.-22     	; 0x5ae <pvPortMalloc+0x60>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     5c4:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <pxEnd>
     5c8:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <pxEnd+0x1>
     5cc:	c8 17       	cp	r28, r24
     5ce:	d9 07       	cpc	r29, r25
     5d0:	09 f4       	brne	.+2      	; 0x5d4 <pvPortMalloc+0x86>
     5d2:	44 c0       	rjmp	.+136    	; 0x65c <pvPortMalloc+0x10e>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     5d4:	e0 80       	ld	r14, Z
     5d6:	f1 80       	ldd	r15, Z+1	; 0x01
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	e8 0e       	add	r14, r24
     5dc:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5de:	88 81       	ld	r24, Y
     5e0:	99 81       	ldd	r25, Y+1	; 0x01
     5e2:	91 83       	std	Z+1, r25	; 0x01
     5e4:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5e6:	2a 81       	ldd	r18, Y+2	; 0x02
     5e8:	3b 81       	ldd	r19, Y+3	; 0x03
     5ea:	20 1b       	sub	r18, r16
     5ec:	31 0b       	sbc	r19, r17
     5ee:	29 30       	cpi	r18, 0x09	; 9
     5f0:	31 05       	cpc	r19, r1
     5f2:	48 f0       	brcs	.+18     	; 0x606 <pvPortMalloc+0xb8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5f4:	ce 01       	movw	r24, r28
     5f6:	80 0f       	add	r24, r16
     5f8:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5fa:	fc 01       	movw	r30, r24
     5fc:	33 83       	std	Z+3, r19	; 0x03
     5fe:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     600:	1b 83       	std	Y+3, r17	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     602:	0a 83       	std	Y+2, r16	; 0x02
     604:	5a df       	rcall	.-332    	; 0x4ba <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     606:	2a 81       	ldd	r18, Y+2	; 0x02
     608:	3b 81       	ldd	r19, Y+3	; 0x03
     60a:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <xFreeBytesRemaining>
     60e:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <xFreeBytesRemaining+0x1>
     612:	82 1b       	sub	r24, r18
     614:	93 0b       	sbc	r25, r19
     616:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <xFreeBytesRemaining+0x1>
     61a:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     61e:	40 91 c6 01 	lds	r20, 0x01C6	; 0x8001c6 <xMinimumEverFreeBytesRemaining>
     622:	50 91 c7 01 	lds	r21, 0x01C7	; 0x8001c7 <xMinimumEverFreeBytesRemaining+0x1>
     626:	84 17       	cp	r24, r20
     628:	95 07       	cpc	r25, r21
     62a:	20 f4       	brcc	.+8      	; 0x634 <pvPortMalloc+0xe6>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     62c:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <xMinimumEverFreeBytesRemaining+0x1>
     630:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     634:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <__data_end>
     638:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <__data_end+0x1>
     63c:	28 2b       	or	r18, r24
     63e:	39 2b       	or	r19, r25
     640:	3b 83       	std	Y+3, r19	; 0x03
     642:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     644:	19 82       	std	Y+1, r1	; 0x01
     646:	18 82       	st	Y, r1
     648:	0b c0       	rjmp	.+22     	; 0x660 <pvPortMalloc+0x112>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     64a:	e1 2c       	mov	r14, r1
     64c:	f1 2c       	mov	r15, r1
     64e:	08 c0       	rjmp	.+16     	; 0x660 <pvPortMalloc+0x112>
     650:	e1 2c       	mov	r14, r1
     652:	f1 2c       	mov	r15, r1
     654:	05 c0       	rjmp	.+10     	; 0x660 <pvPortMalloc+0x112>
     656:	e1 2c       	mov	r14, r1
     658:	f1 2c       	mov	r15, r1
     65a:	02 c0       	rjmp	.+4      	; 0x660 <pvPortMalloc+0x112>
     65c:	e1 2c       	mov	r14, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     65e:	f1 2c       	mov	r15, r1
     660:	c8 d2       	rcall	.+1424   	; 0xbf2 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     662:	c7 01       	movw	r24, r14
     664:	df 91       	pop	r29
     666:	cf 91       	pop	r28
     668:	1f 91       	pop	r17
     66a:	0f 91       	pop	r16
     66c:	ff 90       	pop	r15
     66e:	ef 90       	pop	r14
     670:	08 95       	ret

00000672 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     67a:	00 97       	sbiw	r24, 0x00	; 0
     67c:	39 f1       	breq	.+78     	; 0x6cc <vPortFree+0x5a>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     67e:	ec 01       	movw	r28, r24
     680:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     682:	4a 81       	ldd	r20, Y+2	; 0x02
     684:	5b 81       	ldd	r21, Y+3	; 0x03
     686:	20 91 c4 01 	lds	r18, 0x01C4	; 0x8001c4 <__data_end>
     68a:	30 91 c5 01 	lds	r19, 0x01C5	; 0x8001c5 <__data_end+0x1>
     68e:	ba 01       	movw	r22, r20
     690:	62 23       	and	r22, r18
     692:	73 23       	and	r23, r19
     694:	67 2b       	or	r22, r23
     696:	d1 f0       	breq	.+52     	; 0x6cc <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     698:	68 81       	ld	r22, Y
     69a:	79 81       	ldd	r23, Y+1	; 0x01
     69c:	67 2b       	or	r22, r23
     69e:	b1 f4       	brne	.+44     	; 0x6cc <vPortFree+0x5a>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     6a0:	20 95       	com	r18
     6a2:	30 95       	com	r19
     6a4:	24 23       	and	r18, r20
     6a6:	35 23       	and	r19, r21
     6a8:	3b 83       	std	Y+3, r19	; 0x03
     6aa:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     6ac:	dc d1       	rcall	.+952    	; 0xa66 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	9b 81       	ldd	r25, Y+3	; 0x03
     6b2:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <xFreeBytesRemaining>
     6b6:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <xFreeBytesRemaining+0x1>
     6ba:	82 0f       	add	r24, r18
     6bc:	93 1f       	adc	r25, r19
     6be:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <xFreeBytesRemaining+0x1>
     6c2:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     6c6:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
     6c8:	f8 de       	rcall	.-528    	; 0x4ba <prvInsertBlockIntoFreeList>
     6ca:	93 d2       	rcall	.+1318   	; 0xbf2 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	08 95       	ret

000006d6 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6d6:	e0 91 d1 05 	lds	r30, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     6da:	f0 91 d2 05 	lds	r31, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     6de:	80 81       	ld	r24, Z
     6e0:	81 11       	cpse	r24, r1
     6e2:	07 c0       	rjmp	.+14     	; 0x6f2 <prvResetNextTaskUnblockTime+0x1c>
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	9f ef       	ldi	r25, 0xFF	; 255
     6e8:	90 93 bc 05 	sts	0x05BC, r25	; 0x8005bc <xNextTaskUnblockTime+0x1>
     6ec:	80 93 bb 05 	sts	0x05BB, r24	; 0x8005bb <xNextTaskUnblockTime>
     6f0:	08 95       	ret
     6f2:	e0 91 d1 05 	lds	r30, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     6f6:	f0 91 d2 05 	lds	r31, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     6fa:	05 80       	ldd	r0, Z+5	; 0x05
     6fc:	f6 81       	ldd	r31, Z+6	; 0x06
     6fe:	e0 2d       	mov	r30, r0
     700:	06 80       	ldd	r0, Z+6	; 0x06
     702:	f7 81       	ldd	r31, Z+7	; 0x07
     704:	e0 2d       	mov	r30, r0
     706:	82 81       	ldd	r24, Z+2	; 0x02
     708:	93 81       	ldd	r25, Z+3	; 0x03
     70a:	90 93 bc 05 	sts	0x05BC, r25	; 0x8005bc <xNextTaskUnblockTime+0x1>
     70e:	80 93 bb 05 	sts	0x05BB, r24	; 0x8005bb <xNextTaskUnblockTime>
     712:	08 95       	ret

00000714 <prvInitialiseNewTask>:
     714:	6f 92       	push	r6
     716:	7f 92       	push	r7
     718:	8f 92       	push	r8
     71a:	9f 92       	push	r9
     71c:	af 92       	push	r10
     71e:	bf 92       	push	r11
     720:	cf 92       	push	r12
     722:	df 92       	push	r13
     724:	ef 92       	push	r14
     726:	0f 93       	push	r16
     728:	1f 93       	push	r17
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	cd b7       	in	r28, 0x3d	; 61
     730:	de b7       	in	r29, 0x3e	; 62
     732:	4c 01       	movw	r8, r24
     734:	f5 01       	movw	r30, r10
     736:	87 89       	ldd	r24, Z+23	; 0x17
     738:	90 8d       	ldd	r25, Z+24	; 0x18
     73a:	21 50       	subi	r18, 0x01	; 1
     73c:	31 09       	sbc	r19, r1
     73e:	3c 01       	movw	r6, r24
     740:	62 0e       	add	r6, r18
     742:	73 1e       	adc	r7, r19
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	0f c0       	rjmp	.+30     	; 0x766 <prvInitialiseNewTask+0x52>
     748:	82 2f       	mov	r24, r18
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	fb 01       	movw	r30, r22
     74e:	e8 0f       	add	r30, r24
     750:	f9 1f       	adc	r31, r25
     752:	30 81       	ld	r19, Z
     754:	d5 01       	movw	r26, r10
     756:	a8 0f       	add	r26, r24
     758:	b9 1f       	adc	r27, r25
     75a:	59 96       	adiw	r26, 0x19	; 25
     75c:	3c 93       	st	X, r19
     75e:	80 81       	ld	r24, Z
     760:	88 23       	and	r24, r24
     762:	19 f0       	breq	.+6      	; 0x76a <prvInitialiseNewTask+0x56>
     764:	2f 5f       	subi	r18, 0xFF	; 255
     766:	28 30       	cpi	r18, 0x08	; 8
     768:	78 f3       	brcs	.-34     	; 0x748 <prvInitialiseNewTask+0x34>
     76a:	f5 01       	movw	r30, r10
     76c:	10 a2       	std	Z+32, r1	; 0x20
     76e:	f3 e0       	ldi	r31, 0x03	; 3
     770:	fe 15       	cp	r31, r14
     772:	20 f4       	brcc	.+8      	; 0x77c <prvInitialiseNewTask+0x68>
     774:	0f 2e       	mov	r0, r31
     776:	f3 e0       	ldi	r31, 0x03	; 3
     778:	ef 2e       	mov	r14, r31
     77a:	f0 2d       	mov	r31, r0
     77c:	f5 01       	movw	r30, r10
     77e:	e6 8a       	std	Z+22, r14	; 0x16
     780:	c5 01       	movw	r24, r10
     782:	02 96       	adiw	r24, 0x02	; 2
     784:	9e dc       	rcall	.-1732   	; 0xc2 <vListInitialiseItem>
     786:	c5 01       	movw	r24, r10
     788:	0c 96       	adiw	r24, 0x0c	; 12
     78a:	9b dc       	rcall	.-1738   	; 0xc2 <vListInitialiseItem>
     78c:	f5 01       	movw	r30, r10
     78e:	b1 86       	std	Z+9, r11	; 0x09
     790:	a0 86       	std	Z+8, r10	; 0x08
     792:	84 e0       	ldi	r24, 0x04	; 4
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	8e 19       	sub	r24, r14
     798:	91 09       	sbc	r25, r1
     79a:	95 87       	std	Z+13, r25	; 0x0d
     79c:	84 87       	std	Z+12, r24	; 0x0c
     79e:	b3 8a       	std	Z+19, r11	; 0x13
     7a0:	a2 8a       	std	Z+18, r10	; 0x12
     7a2:	11 a2       	std	Z+33, r1	; 0x21
     7a4:	12 a2       	std	Z+34, r1	; 0x22
     7a6:	13 a2       	std	Z+35, r1	; 0x23
     7a8:	14 a2       	std	Z+36, r1	; 0x24
     7aa:	15 a2       	std	Z+37, r1	; 0x25
     7ac:	a8 01       	movw	r20, r16
     7ae:	b4 01       	movw	r22, r8
     7b0:	c3 01       	movw	r24, r6
     7b2:	0c dd       	rcall	.-1512   	; 0x1cc <pxPortInitialiseStack>
     7b4:	f5 01       	movw	r30, r10
     7b6:	91 83       	std	Z+1, r25	; 0x01
     7b8:	80 83       	st	Z, r24
     7ba:	c1 14       	cp	r12, r1
     7bc:	d1 04       	cpc	r13, r1
     7be:	19 f0       	breq	.+6      	; 0x7c6 <prvInitialiseNewTask+0xb2>
     7c0:	f6 01       	movw	r30, r12
     7c2:	b1 82       	std	Z+1, r11	; 0x01
     7c4:	a0 82       	st	Z, r10
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ef 90       	pop	r14
     7d0:	df 90       	pop	r13
     7d2:	cf 90       	pop	r12
     7d4:	bf 90       	pop	r11
     7d6:	af 90       	pop	r10
     7d8:	9f 90       	pop	r9
     7da:	8f 90       	pop	r8
     7dc:	7f 90       	pop	r7
     7de:	6f 90       	pop	r6
     7e0:	08 95       	ret

000007e2 <prvIdleTask>:
     7e2:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <pxReadyTasksLists>
     7e6:	82 30       	cpi	r24, 0x02	; 2
     7e8:	e0 f3       	brcs	.-8      	; 0x7e2 <prvIdleTask>
     7ea:	8a dd       	rcall	.-1260   	; 0x300 <vPortYield>
     7ec:	fa cf       	rjmp	.-12     	; 0x7e2 <prvIdleTask>

000007ee <prvInitialiseTaskLists>:
     7ee:	cf 93       	push	r28
     7f0:	c0 e0       	ldi	r28, 0x00	; 0
     7f2:	0f c0       	rjmp	.+30     	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     7f4:	8c 2f       	mov	r24, r28
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	9c 01       	movw	r18, r24
     7fa:	22 0f       	add	r18, r18
     7fc:	33 1f       	adc	r19, r19
     7fe:	22 0f       	add	r18, r18
     800:	33 1f       	adc	r19, r19
     802:	22 0f       	add	r18, r18
     804:	33 1f       	adc	r19, r19
     806:	82 0f       	add	r24, r18
     808:	93 1f       	adc	r25, r19
     80a:	8b 51       	subi	r24, 0x1B	; 27
     80c:	9a 4f       	sbci	r25, 0xFA	; 250
     80e:	4b dc       	rcall	.-1898   	; 0xa6 <vListInitialise>
     810:	cf 5f       	subi	r28, 0xFF	; 255
     812:	c4 30       	cpi	r28, 0x04	; 4
     814:	78 f3       	brcs	.-34     	; 0x7f4 <prvInitialiseTaskLists+0x6>
     816:	8c ed       	ldi	r24, 0xDC	; 220
     818:	95 e0       	ldi	r25, 0x05	; 5
     81a:	45 dc       	rcall	.-1910   	; 0xa6 <vListInitialise>
     81c:	83 ed       	ldi	r24, 0xD3	; 211
     81e:	95 e0       	ldi	r25, 0x05	; 5
     820:	42 dc       	rcall	.-1916   	; 0xa6 <vListInitialise>
     822:	86 ec       	ldi	r24, 0xC6	; 198
     824:	95 e0       	ldi	r25, 0x05	; 5
     826:	3f dc       	rcall	.-1922   	; 0xa6 <vListInitialise>
     828:	8c ed       	ldi	r24, 0xDC	; 220
     82a:	95 e0       	ldi	r25, 0x05	; 5
     82c:	90 93 d2 05 	sts	0x05D2, r25	; 0x8005d2 <pxDelayedTaskList+0x1>
     830:	80 93 d1 05 	sts	0x05D1, r24	; 0x8005d1 <pxDelayedTaskList>
     834:	83 ed       	ldi	r24, 0xD3	; 211
     836:	95 e0       	ldi	r25, 0x05	; 5
     838:	90 93 d0 05 	sts	0x05D0, r25	; 0x8005d0 <pxOverflowDelayedTaskList+0x1>
     83c:	80 93 cf 05 	sts	0x05CF, r24	; 0x8005cf <pxOverflowDelayedTaskList>
     840:	cf 91       	pop	r28
     842:	08 95       	ret

00000844 <prvAddNewTaskToReadyList>:
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	ec 01       	movw	r28, r24
     84a:	0f b6       	in	r0, 0x3f	; 63
     84c:	f8 94       	cli
     84e:	0f 92       	push	r0
     850:	80 91 c5 05 	lds	r24, 0x05C5	; 0x8005c5 <uxCurrentNumberOfTasks>
     854:	8f 5f       	subi	r24, 0xFF	; 255
     856:	80 93 c5 05 	sts	0x05C5, r24	; 0x8005c5 <uxCurrentNumberOfTasks>
     85a:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <pxCurrentTCB>
     85e:	90 91 0a 06 	lds	r25, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     862:	89 2b       	or	r24, r25
     864:	51 f4       	brne	.+20     	; 0x87a <__stack+0x1b>
     866:	d0 93 0a 06 	sts	0x060A, r29	; 0x80060a <pxCurrentTCB+0x1>
     86a:	c0 93 09 06 	sts	0x0609, r28	; 0x800609 <pxCurrentTCB>
     86e:	80 91 c5 05 	lds	r24, 0x05C5	; 0x8005c5 <uxCurrentNumberOfTasks>
     872:	81 30       	cpi	r24, 0x01	; 1
     874:	91 f4       	brne	.+36     	; 0x89a <__stack+0x3b>
     876:	bb df       	rcall	.-138    	; 0x7ee <prvInitialiseTaskLists>
     878:	10 c0       	rjmp	.+32     	; 0x89a <__stack+0x3b>
     87a:	80 91 c1 05 	lds	r24, 0x05C1	; 0x8005c1 <xSchedulerRunning>
     87e:	81 11       	cpse	r24, r1
     880:	0c c0       	rjmp	.+24     	; 0x89a <__stack+0x3b>
     882:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     886:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     88a:	96 89       	ldd	r25, Z+22	; 0x16
     88c:	8e 89       	ldd	r24, Y+22	; 0x16
     88e:	89 17       	cp	r24, r25
     890:	20 f0       	brcs	.+8      	; 0x89a <__stack+0x3b>
     892:	d0 93 0a 06 	sts	0x060A, r29	; 0x80060a <pxCurrentTCB+0x1>
     896:	c0 93 09 06 	sts	0x0609, r28	; 0x800609 <pxCurrentTCB>
     89a:	80 91 bd 05 	lds	r24, 0x05BD	; 0x8005bd <uxTaskNumber>
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	80 93 bd 05 	sts	0x05BD, r24	; 0x8005bd <uxTaskNumber>
     8a4:	8e 89       	ldd	r24, Y+22	; 0x16
     8a6:	90 91 c2 05 	lds	r25, 0x05C2	; 0x8005c2 <uxTopReadyPriority>
     8aa:	98 17       	cp	r25, r24
     8ac:	10 f4       	brcc	.+4      	; 0x8b2 <__stack+0x53>
     8ae:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <uxTopReadyPriority>
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	9c 01       	movw	r18, r24
     8b6:	22 0f       	add	r18, r18
     8b8:	33 1f       	adc	r19, r19
     8ba:	22 0f       	add	r18, r18
     8bc:	33 1f       	adc	r19, r19
     8be:	22 0f       	add	r18, r18
     8c0:	33 1f       	adc	r19, r19
     8c2:	82 0f       	add	r24, r18
     8c4:	93 1f       	adc	r25, r19
     8c6:	be 01       	movw	r22, r28
     8c8:	6e 5f       	subi	r22, 0xFE	; 254
     8ca:	7f 4f       	sbci	r23, 0xFF	; 255
     8cc:	8b 51       	subi	r24, 0x1B	; 27
     8ce:	9a 4f       	sbci	r25, 0xFA	; 250
     8d0:	fc db       	rcall	.-2056   	; 0xca <vListInsertEnd>
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	80 91 c1 05 	lds	r24, 0x05C1	; 0x8005c1 <xSchedulerRunning>
     8da:	88 23       	and	r24, r24
     8dc:	49 f0       	breq	.+18     	; 0x8f0 <__stack+0x91>
     8de:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     8e2:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     8e6:	96 89       	ldd	r25, Z+22	; 0x16
     8e8:	8e 89       	ldd	r24, Y+22	; 0x16
     8ea:	98 17       	cp	r25, r24
     8ec:	08 f4       	brcc	.+2      	; 0x8f0 <__stack+0x91>
     8ee:	08 dd       	rcall	.-1520   	; 0x300 <vPortYield>
     8f0:	df 91       	pop	r29
     8f2:	cf 91       	pop	r28
     8f4:	08 95       	ret

000008f6 <prvAddCurrentTaskToDelayedList>:
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	ec 01       	movw	r28, r24
     900:	00 91 c3 05 	lds	r16, 0x05C3	; 0x8005c3 <xTickCount>
     904:	10 91 c4 05 	lds	r17, 0x05C4	; 0x8005c4 <xTickCount+0x1>
     908:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <pxCurrentTCB>
     90c:	90 91 0a 06 	lds	r25, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     910:	02 96       	adiw	r24, 0x02	; 2
     912:	2d dc       	rcall	.-1958   	; 0x16e <uxListRemove>
     914:	c0 0f       	add	r28, r16
     916:	d1 1f       	adc	r29, r17
     918:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     91c:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     920:	d3 83       	std	Z+3, r29	; 0x03
     922:	c2 83       	std	Z+2, r28	; 0x02
     924:	c0 17       	cp	r28, r16
     926:	d1 07       	cpc	r29, r17
     928:	60 f4       	brcc	.+24     	; 0x942 <prvAddCurrentTaskToDelayedList+0x4c>
     92a:	60 91 09 06 	lds	r22, 0x0609	; 0x800609 <pxCurrentTCB>
     92e:	70 91 0a 06 	lds	r23, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     932:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <pxOverflowDelayedTaskList>
     936:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <pxOverflowDelayedTaskList+0x1>
     93a:	6e 5f       	subi	r22, 0xFE	; 254
     93c:	7f 4f       	sbci	r23, 0xFF	; 255
     93e:	e6 db       	rcall	.-2100   	; 0x10c <vListInsert>
     940:	16 c0       	rjmp	.+44     	; 0x96e <prvAddCurrentTaskToDelayedList+0x78>
     942:	60 91 09 06 	lds	r22, 0x0609	; 0x800609 <pxCurrentTCB>
     946:	70 91 0a 06 	lds	r23, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     94a:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     94e:	90 91 d2 05 	lds	r25, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     952:	6e 5f       	subi	r22, 0xFE	; 254
     954:	7f 4f       	sbci	r23, 0xFF	; 255
     956:	da db       	rcall	.-2124   	; 0x10c <vListInsert>
     958:	80 91 bb 05 	lds	r24, 0x05BB	; 0x8005bb <xNextTaskUnblockTime>
     95c:	90 91 bc 05 	lds	r25, 0x05BC	; 0x8005bc <xNextTaskUnblockTime+0x1>
     960:	c8 17       	cp	r28, r24
     962:	d9 07       	cpc	r29, r25
     964:	20 f4       	brcc	.+8      	; 0x96e <prvAddCurrentTaskToDelayedList+0x78>
     966:	d0 93 bc 05 	sts	0x05BC, r29	; 0x8005bc <xNextTaskUnblockTime+0x1>
     96a:	c0 93 bb 05 	sts	0x05BB, r28	; 0x8005bb <xNextTaskUnblockTime>
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	08 95       	ret

00000978 <xTaskCreate>:
     978:	2f 92       	push	r2
     97a:	3f 92       	push	r3
     97c:	4f 92       	push	r4
     97e:	5f 92       	push	r5
     980:	6f 92       	push	r6
     982:	7f 92       	push	r7
     984:	8f 92       	push	r8
     986:	9f 92       	push	r9
     988:	af 92       	push	r10
     98a:	bf 92       	push	r11
     98c:	cf 92       	push	r12
     98e:	df 92       	push	r13
     990:	ef 92       	push	r14
     992:	ff 92       	push	r15
     994:	0f 93       	push	r16
     996:	1f 93       	push	r17
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	3c 01       	movw	r6, r24
     99e:	1b 01       	movw	r2, r22
     9a0:	5a 01       	movw	r10, r20
     9a2:	29 01       	movw	r4, r18
     9a4:	ca 01       	movw	r24, r20
     9a6:	d3 dd       	rcall	.-1114   	; 0x54e <pvPortMalloc>
     9a8:	6c 01       	movw	r12, r24
     9aa:	89 2b       	or	r24, r25
     9ac:	61 f0       	breq	.+24     	; 0x9c6 <xTaskCreate+0x4e>
     9ae:	86 e2       	ldi	r24, 0x26	; 38
     9b0:	90 e0       	ldi	r25, 0x00	; 0
     9b2:	cd dd       	rcall	.-1126   	; 0x54e <pvPortMalloc>
     9b4:	ec 01       	movw	r28, r24
     9b6:	89 2b       	or	r24, r25
     9b8:	19 f0       	breq	.+6      	; 0x9c0 <xTaskCreate+0x48>
     9ba:	d8 8e       	std	Y+24, r13	; 0x18
     9bc:	cf 8a       	std	Y+23, r12	; 0x17
     9be:	05 c0       	rjmp	.+10     	; 0x9ca <xTaskCreate+0x52>
     9c0:	c6 01       	movw	r24, r12
     9c2:	57 de       	rcall	.-850    	; 0x672 <vPortFree>
     9c4:	02 c0       	rjmp	.+4      	; 0x9ca <xTaskCreate+0x52>
     9c6:	c0 e0       	ldi	r28, 0x00	; 0
     9c8:	d0 e0       	ldi	r29, 0x00	; 0
     9ca:	20 97       	sbiw	r28, 0x00	; 0
     9cc:	81 f0       	breq	.+32     	; 0x9ee <xTaskCreate+0x76>
     9ce:	95 01       	movw	r18, r10
     9d0:	40 e0       	ldi	r20, 0x00	; 0
     9d2:	50 e0       	ldi	r21, 0x00	; 0
     9d4:	81 2c       	mov	r8, r1
     9d6:	91 2c       	mov	r9, r1
     9d8:	5e 01       	movw	r10, r28
     9da:	67 01       	movw	r12, r14
     9dc:	e0 2e       	mov	r14, r16
     9de:	82 01       	movw	r16, r4
     9e0:	b1 01       	movw	r22, r2
     9e2:	c3 01       	movw	r24, r6
     9e4:	97 de       	rcall	.-722    	; 0x714 <prvInitialiseNewTask>
     9e6:	ce 01       	movw	r24, r28
     9e8:	2d df       	rcall	.-422    	; 0x844 <prvAddNewTaskToReadyList>
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	01 c0       	rjmp	.+2      	; 0x9f0 <xTaskCreate+0x78>
     9ee:	8f ef       	ldi	r24, 0xFF	; 255
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	ff 90       	pop	r15
     9fa:	ef 90       	pop	r14
     9fc:	df 90       	pop	r13
     9fe:	cf 90       	pop	r12
     a00:	bf 90       	pop	r11
     a02:	af 90       	pop	r10
     a04:	9f 90       	pop	r9
     a06:	8f 90       	pop	r8
     a08:	7f 90       	pop	r7
     a0a:	6f 90       	pop	r6
     a0c:	5f 90       	pop	r5
     a0e:	4f 90       	pop	r4
     a10:	3f 90       	pop	r3
     a12:	2f 90       	pop	r2
     a14:	08 95       	ret

00000a16 <vTaskStartScheduler>:
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	0f 93       	push	r16
     a1c:	0f 2e       	mov	r0, r31
     a1e:	f9 eb       	ldi	r31, 0xB9	; 185
     a20:	ef 2e       	mov	r14, r31
     a22:	f5 e0       	ldi	r31, 0x05	; 5
     a24:	ff 2e       	mov	r15, r31
     a26:	f0 2d       	mov	r31, r0
     a28:	00 e0       	ldi	r16, 0x00	; 0
     a2a:	20 e0       	ldi	r18, 0x00	; 0
     a2c:	30 e0       	ldi	r19, 0x00	; 0
     a2e:	45 e5       	ldi	r20, 0x55	; 85
     a30:	50 e0       	ldi	r21, 0x00	; 0
     a32:	6f e9       	ldi	r22, 0x9F	; 159
     a34:	70 e0       	ldi	r23, 0x00	; 0
     a36:	81 ef       	ldi	r24, 0xF1	; 241
     a38:	93 e0       	ldi	r25, 0x03	; 3
     a3a:	9e df       	rcall	.-196    	; 0x978 <xTaskCreate>
     a3c:	81 30       	cpi	r24, 0x01	; 1
     a3e:	79 f4       	brne	.+30     	; 0xa5e <vTaskStartScheduler+0x48>
     a40:	f8 94       	cli
     a42:	8f ef       	ldi	r24, 0xFF	; 255
     a44:	9f ef       	ldi	r25, 0xFF	; 255
     a46:	90 93 bc 05 	sts	0x05BC, r25	; 0x8005bc <xNextTaskUnblockTime+0x1>
     a4a:	80 93 bb 05 	sts	0x05BB, r24	; 0x8005bb <xNextTaskUnblockTime>
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	80 93 c1 05 	sts	0x05C1, r24	; 0x8005c1 <xSchedulerRunning>
     a54:	10 92 c4 05 	sts	0x05C4, r1	; 0x8005c4 <xTickCount+0x1>
     a58:	10 92 c3 05 	sts	0x05C3, r1	; 0x8005c3 <xTickCount>
     a5c:	23 dc       	rcall	.-1978   	; 0x2a4 <xPortStartScheduler>
     a5e:	0f 91       	pop	r16
     a60:	ff 90       	pop	r15
     a62:	ef 90       	pop	r14
     a64:	08 95       	ret

00000a66 <vTaskSuspendAll>:
     a66:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <uxSchedulerSuspended>
     a6a:	8f 5f       	subi	r24, 0xFF	; 255
     a6c:	80 93 b8 05 	sts	0x05B8, r24	; 0x8005b8 <uxSchedulerSuspended>
     a70:	08 95       	ret

00000a72 <xTaskGetTickCount>:
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	0f 92       	push	r0
     a78:	80 91 c3 05 	lds	r24, 0x05C3	; 0x8005c3 <xTickCount>
     a7c:	90 91 c4 05 	lds	r25, 0x05C4	; 0x8005c4 <xTickCount+0x1>
     a80:	0f 90       	pop	r0
     a82:	0f be       	out	0x3f, r0	; 63
     a84:	08 95       	ret

00000a86 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     a86:	df 92       	push	r13
     a88:	ef 92       	push	r14
     a8a:	ff 92       	push	r15
     a8c:	0f 93       	push	r16
     a8e:	1f 93       	push	r17
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a94:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <uxSchedulerSuspended>
     a98:	81 11       	cpse	r24, r1
     a9a:	93 c0       	rjmp	.+294    	; 0xbc2 <xTaskIncrementTick+0x13c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     a9c:	e0 90 c3 05 	lds	r14, 0x05C3	; 0x8005c3 <xTickCount>
     aa0:	f0 90 c4 05 	lds	r15, 0x05C4	; 0x8005c4 <xTickCount+0x1>
     aa4:	8f ef       	ldi	r24, 0xFF	; 255
     aa6:	e8 1a       	sub	r14, r24
     aa8:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     aaa:	f0 92 c4 05 	sts	0x05C4, r15	; 0x8005c4 <xTickCount+0x1>
     aae:	e0 92 c3 05 	sts	0x05C3, r14	; 0x8005c3 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     ab2:	e1 14       	cp	r14, r1
     ab4:	f1 04       	cpc	r15, r1
     ab6:	b1 f4       	brne	.+44     	; 0xae4 <xTaskIncrementTick+0x5e>
		{
			taskSWITCH_DELAYED_LISTS();
     ab8:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     abc:	90 91 d2 05 	lds	r25, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     ac0:	20 91 cf 05 	lds	r18, 0x05CF	; 0x8005cf <pxOverflowDelayedTaskList>
     ac4:	30 91 d0 05 	lds	r19, 0x05D0	; 0x8005d0 <pxOverflowDelayedTaskList+0x1>
     ac8:	30 93 d2 05 	sts	0x05D2, r19	; 0x8005d2 <pxDelayedTaskList+0x1>
     acc:	20 93 d1 05 	sts	0x05D1, r18	; 0x8005d1 <pxDelayedTaskList>
     ad0:	90 93 d0 05 	sts	0x05D0, r25	; 0x8005d0 <pxOverflowDelayedTaskList+0x1>
     ad4:	80 93 cf 05 	sts	0x05CF, r24	; 0x8005cf <pxOverflowDelayedTaskList>
     ad8:	80 91 be 05 	lds	r24, 0x05BE	; 0x8005be <xNumOfOverflows>
     adc:	8f 5f       	subi	r24, 0xFF	; 255
     ade:	80 93 be 05 	sts	0x05BE, r24	; 0x8005be <xNumOfOverflows>
     ae2:	f9 dd       	rcall	.-1038   	; 0x6d6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     ae4:	80 91 bb 05 	lds	r24, 0x05BB	; 0x8005bb <xNextTaskUnblockTime>
     ae8:	90 91 bc 05 	lds	r25, 0x05BC	; 0x8005bc <xNextTaskUnblockTime+0x1>
     aec:	e8 16       	cp	r14, r24
     aee:	f9 06       	cpc	r15, r25
     af0:	28 f4       	brcc	.+10     	; 0xafc <xTaskIncrementTick+0x76>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     af2:	d1 2c       	mov	r13, r1
     af4:	50 c0       	rjmp	.+160    	; 0xb96 <xTaskIncrementTick+0x110>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     af6:	dd 24       	eor	r13, r13
     af8:	d3 94       	inc	r13
     afa:	01 c0       	rjmp	.+2      	; 0xafe <xTaskIncrementTick+0x78>
     afc:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     afe:	e0 91 d1 05 	lds	r30, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     b02:	f0 91 d2 05 	lds	r31, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     b06:	80 81       	ld	r24, Z
     b08:	81 11       	cpse	r24, r1
     b0a:	07 c0       	rjmp	.+14     	; 0xb1a <xTaskIncrementTick+0x94>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b0c:	8f ef       	ldi	r24, 0xFF	; 255
     b0e:	9f ef       	ldi	r25, 0xFF	; 255
     b10:	90 93 bc 05 	sts	0x05BC, r25	; 0x8005bc <xNextTaskUnblockTime+0x1>
     b14:	80 93 bb 05 	sts	0x05BB, r24	; 0x8005bb <xNextTaskUnblockTime>
					break;
     b18:	3e c0       	rjmp	.+124    	; 0xb96 <xTaskIncrementTick+0x110>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b1a:	e0 91 d1 05 	lds	r30, 0x05D1	; 0x8005d1 <pxDelayedTaskList>
     b1e:	f0 91 d2 05 	lds	r31, 0x05D2	; 0x8005d2 <pxDelayedTaskList+0x1>
     b22:	05 80       	ldd	r0, Z+5	; 0x05
     b24:	f6 81       	ldd	r31, Z+6	; 0x06
     b26:	e0 2d       	mov	r30, r0
     b28:	c6 81       	ldd	r28, Z+6	; 0x06
     b2a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b2c:	8a 81       	ldd	r24, Y+2	; 0x02
     b2e:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     b30:	e8 16       	cp	r14, r24
     b32:	f9 06       	cpc	r15, r25
     b34:	28 f4       	brcc	.+10     	; 0xb40 <xTaskIncrementTick+0xba>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b36:	90 93 bc 05 	sts	0x05BC, r25	; 0x8005bc <xNextTaskUnblockTime+0x1>
     b3a:	80 93 bb 05 	sts	0x05BB, r24	; 0x8005bb <xNextTaskUnblockTime>
						break;
     b3e:	2b c0       	rjmp	.+86     	; 0xb96 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b40:	8e 01       	movw	r16, r28
     b42:	0e 5f       	subi	r16, 0xFE	; 254
     b44:	1f 4f       	sbci	r17, 0xFF	; 255
     b46:	c8 01       	movw	r24, r16
     b48:	12 db       	rcall	.-2524   	; 0x16e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b4a:	8c 89       	ldd	r24, Y+20	; 0x14
     b4c:	9d 89       	ldd	r25, Y+21	; 0x15
     b4e:	89 2b       	or	r24, r25
     b50:	19 f0       	breq	.+6      	; 0xb58 <xTaskIncrementTick+0xd2>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b52:	ce 01       	movw	r24, r28
     b54:	0c 96       	adiw	r24, 0x0c	; 12
     b56:	0b db       	rcall	.-2538   	; 0x16e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b58:	8e 89       	ldd	r24, Y+22	; 0x16
     b5a:	90 91 c2 05 	lds	r25, 0x05C2	; 0x8005c2 <uxTopReadyPriority>
     b5e:	98 17       	cp	r25, r24
     b60:	10 f4       	brcc	.+4      	; 0xb66 <xTaskIncrementTick+0xe0>
     b62:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <uxTopReadyPriority>
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	9c 01       	movw	r18, r24
     b6a:	22 0f       	add	r18, r18
     b6c:	33 1f       	adc	r19, r19
     b6e:	22 0f       	add	r18, r18
     b70:	33 1f       	adc	r19, r19
     b72:	22 0f       	add	r18, r18
     b74:	33 1f       	adc	r19, r19
     b76:	82 0f       	add	r24, r18
     b78:	93 1f       	adc	r25, r19
     b7a:	b8 01       	movw	r22, r16
     b7c:	8b 51       	subi	r24, 0x1B	; 27
     b7e:	9a 4f       	sbci	r25, 0xFA	; 250
     b80:	a4 da       	rcall	.-2744   	; 0xca <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     b82:	9e 89       	ldd	r25, Y+22	; 0x16
     b84:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     b88:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     b8c:	86 89       	ldd	r24, Z+22	; 0x16
     b8e:	98 17       	cp	r25, r24
     b90:	08 f0       	brcs	.+2      	; 0xb94 <xTaskIncrementTick+0x10e>
     b92:	b1 cf       	rjmp	.-158    	; 0xaf6 <xTaskIncrementTick+0x70>
     b94:	b4 cf       	rjmp	.-152    	; 0xafe <xTaskIncrementTick+0x78>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     b96:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     b9a:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     b9e:	86 89       	ldd	r24, Z+22	; 0x16
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	fc 01       	movw	r30, r24
     ba4:	ee 0f       	add	r30, r30
     ba6:	ff 1f       	adc	r31, r31
     ba8:	ee 0f       	add	r30, r30
     baa:	ff 1f       	adc	r31, r31
     bac:	ee 0f       	add	r30, r30
     bae:	ff 1f       	adc	r31, r31
     bb0:	8e 0f       	add	r24, r30
     bb2:	9f 1f       	adc	r25, r31
     bb4:	fc 01       	movw	r30, r24
     bb6:	eb 51       	subi	r30, 0x1B	; 27
     bb8:	fa 4f       	sbci	r31, 0xFA	; 250
     bba:	80 81       	ld	r24, Z
     bbc:	82 30       	cpi	r24, 0x02	; 2
     bbe:	40 f4       	brcc	.+16     	; 0xbd0 <xTaskIncrementTick+0x14a>
     bc0:	09 c0       	rjmp	.+18     	; 0xbd4 <xTaskIncrementTick+0x14e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bc2:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <uxPendedTicks>
     bc6:	8f 5f       	subi	r24, 0xFF	; 255
     bc8:	80 93 c0 05 	sts	0x05C0, r24	; 0x8005c0 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     bcc:	d1 2c       	mov	r13, r1
     bce:	02 c0       	rjmp	.+4      	; 0xbd4 <xTaskIncrementTick+0x14e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     bd0:	dd 24       	eor	r13, r13
     bd2:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     bd4:	80 91 bf 05 	lds	r24, 0x05BF	; 0x8005bf <xYieldPending>
     bd8:	88 23       	and	r24, r24
     bda:	11 f0       	breq	.+4      	; 0xbe0 <xTaskIncrementTick+0x15a>
		{
			xSwitchRequired = pdTRUE;
     bdc:	dd 24       	eor	r13, r13
     bde:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     be0:	8d 2d       	mov	r24, r13
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	1f 91       	pop	r17
     be8:	0f 91       	pop	r16
     bea:	ff 90       	pop	r15
     bec:	ef 90       	pop	r14
     bee:	df 90       	pop	r13
     bf0:	08 95       	ret

00000bf2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c00:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <uxSchedulerSuspended>
     c04:	81 50       	subi	r24, 0x01	; 1
     c06:	80 93 b8 05 	sts	0x05B8, r24	; 0x8005b8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c0a:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <uxSchedulerSuspended>
     c0e:	81 11       	cpse	r24, r1
     c10:	52 c0       	rjmp	.+164    	; 0xcb6 <xTaskResumeAll+0xc4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c12:	80 91 c5 05 	lds	r24, 0x05C5	; 0x8005c5 <uxCurrentNumberOfTasks>
     c16:	81 11       	cpse	r24, r1
     c18:	30 c0       	rjmp	.+96     	; 0xc7a <xTaskResumeAll+0x88>
     c1a:	50 c0       	rjmp	.+160    	; 0xcbc <xTaskResumeAll+0xca>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c1c:	e0 91 cb 05 	lds	r30, 0x05CB	; 0x8005cb <xPendingReadyList+0x5>
     c20:	f0 91 cc 05 	lds	r31, 0x05CC	; 0x8005cc <xPendingReadyList+0x6>
     c24:	c6 81       	ldd	r28, Z+6	; 0x06
     c26:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c28:	ce 01       	movw	r24, r28
     c2a:	0c 96       	adiw	r24, 0x0c	; 12
     c2c:	a0 da       	rcall	.-2752   	; 0x16e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c2e:	8e 01       	movw	r16, r28
     c30:	0e 5f       	subi	r16, 0xFE	; 254
     c32:	1f 4f       	sbci	r17, 0xFF	; 255
     c34:	c8 01       	movw	r24, r16
     c36:	9b da       	rcall	.-2762   	; 0x16e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c38:	8e 89       	ldd	r24, Y+22	; 0x16
     c3a:	90 91 c2 05 	lds	r25, 0x05C2	; 0x8005c2 <uxTopReadyPriority>
     c3e:	98 17       	cp	r25, r24
     c40:	10 f4       	brcc	.+4      	; 0xc46 <xTaskResumeAll+0x54>
     c42:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <uxTopReadyPriority>
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	9c 01       	movw	r18, r24
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	22 0f       	add	r18, r18
     c50:	33 1f       	adc	r19, r19
     c52:	22 0f       	add	r18, r18
     c54:	33 1f       	adc	r19, r19
     c56:	82 0f       	add	r24, r18
     c58:	93 1f       	adc	r25, r19
     c5a:	b8 01       	movw	r22, r16
     c5c:	8b 51       	subi	r24, 0x1B	; 27
     c5e:	9a 4f       	sbci	r25, 0xFA	; 250
     c60:	34 da       	rcall	.-2968   	; 0xca <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c62:	9e 89       	ldd	r25, Y+22	; 0x16
     c64:	e0 91 09 06 	lds	r30, 0x0609	; 0x800609 <pxCurrentTCB>
     c68:	f0 91 0a 06 	lds	r31, 0x060A	; 0x80060a <pxCurrentTCB+0x1>
     c6c:	86 89       	ldd	r24, Z+22	; 0x16
     c6e:	98 17       	cp	r25, r24
     c70:	30 f0       	brcs	.+12     	; 0xc7e <xTaskResumeAll+0x8c>
					{
						xYieldPending = pdTRUE;
     c72:	81 e0       	ldi	r24, 0x01	; 1
     c74:	80 93 bf 05 	sts	0x05BF, r24	; 0x8005bf <xYieldPending>
     c78:	02 c0       	rjmp	.+4      	; 0xc7e <xTaskResumeAll+0x8c>
     c7a:	c0 e0       	ldi	r28, 0x00	; 0
     c7c:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     c7e:	80 91 c6 05 	lds	r24, 0x05C6	; 0x8005c6 <xPendingReadyList>
     c82:	81 11       	cpse	r24, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     c84:	cb cf       	rjmp	.-106    	; 0xc1c <xTaskResumeAll+0x2a>
     c86:	cd 2b       	or	r28, r29
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     c88:	09 f0       	breq	.+2      	; 0xc8c <xTaskResumeAll+0x9a>
     c8a:	25 dd       	rcall	.-1462   	; 0x6d6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     c8c:	c0 91 c0 05 	lds	r28, 0x05C0	; 0x8005c0 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     c90:	cc 23       	and	r28, r28
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     c92:	51 f0       	breq	.+20     	; 0xca8 <xTaskResumeAll+0xb6>
     c94:	f8 de       	rcall	.-528    	; 0xa86 <xTaskIncrementTick>
     c96:	88 23       	and	r24, r24
     c98:	19 f0       	breq	.+6      	; 0xca0 <xTaskResumeAll+0xae>
							{
								xYieldPending = pdTRUE;
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	80 93 bf 05 	sts	0x05BF, r24	; 0x8005bf <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     ca0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     ca2:	c1 f7       	brne	.-16     	; 0xc94 <xTaskResumeAll+0xa2>

						uxPendedTicks = 0;
     ca4:	10 92 c0 05 	sts	0x05C0, r1	; 0x8005c0 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     ca8:	80 91 bf 05 	lds	r24, 0x05BF	; 0x8005bf <xYieldPending>
     cac:	88 23       	and	r24, r24
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cae:	29 f0       	breq	.+10     	; 0xcba <xTaskResumeAll+0xc8>
     cb0:	27 db       	rcall	.-2482   	; 0x300 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cb2:	81 e0       	ldi	r24, 0x01	; 1
     cb4:	03 c0       	rjmp	.+6      	; 0xcbc <xTaskResumeAll+0xca>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     cb6:	80 e0       	ldi	r24, 0x00	; 0
     cb8:	01 c0       	rjmp	.+2      	; 0xcbc <xTaskResumeAll+0xca>
     cba:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     cc0:	df 91       	pop	r29
     cc2:	cf 91       	pop	r28
     cc4:	1f 91       	pop	r17
     cc6:	0f 91       	pop	r16
     cc8:	08 95       	ret

00000cca <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	8c 01       	movw	r16, r24
     cd4:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     cd6:	c7 de       	rcall	.-626    	; 0xa66 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     cd8:	40 91 c3 05 	lds	r20, 0x05C3	; 0x8005c3 <xTickCount>
     cdc:	50 91 c4 05 	lds	r21, 0x05C4	; 0x8005c4 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     ce0:	f8 01       	movw	r30, r16
     ce2:	20 81       	ld	r18, Z
     ce4:	31 81       	ldd	r19, Z+1	; 0x01
     ce6:	c9 01       	movw	r24, r18
     ce8:	8c 0f       	add	r24, r28
     cea:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     cec:	42 17       	cp	r20, r18
     cee:	53 07       	cpc	r21, r19
     cf0:	40 f4       	brcc	.+16     	; 0xd02 <vTaskDelayUntil+0x38>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     cf2:	82 17       	cp	r24, r18
     cf4:	93 07       	cpc	r25, r19
     cf6:	68 f4       	brcc	.+26     	; 0xd12 <vTaskDelayUntil+0x48>
     cf8:	48 17       	cp	r20, r24
     cfa:	59 07       	cpc	r21, r25
     cfc:	60 f0       	brcs	.+24     	; 0xd16 <vTaskDelayUntil+0x4c>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	0f c0       	rjmp	.+30     	; 0xd20 <vTaskDelayUntil+0x56>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d02:	82 17       	cp	r24, r18
     d04:	93 07       	cpc	r25, r19
     d06:	48 f0       	brcs	.+18     	; 0xd1a <vTaskDelayUntil+0x50>
     d08:	48 17       	cp	r20, r24
     d0a:	59 07       	cpc	r21, r25
     d0c:	40 f0       	brcs	.+16     	; 0xd1e <vTaskDelayUntil+0x54>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	07 c0       	rjmp	.+14     	; 0xd20 <vTaskDelayUntil+0x56>
     d12:	20 e0       	ldi	r18, 0x00	; 0
     d14:	05 c0       	rjmp	.+10     	; 0xd20 <vTaskDelayUntil+0x56>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d16:	21 e0       	ldi	r18, 0x01	; 1
     d18:	03 c0       	rjmp	.+6      	; 0xd20 <vTaskDelayUntil+0x56>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d1a:	21 e0       	ldi	r18, 0x01	; 1
     d1c:	01 c0       	rjmp	.+2      	; 0xd20 <vTaskDelayUntil+0x56>
     d1e:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d20:	f8 01       	movw	r30, r16
     d22:	91 83       	std	Z+1, r25	; 0x01
     d24:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d26:	22 23       	and	r18, r18
     d28:	21 f0       	breq	.+8      	; 0xd32 <vTaskDelayUntil+0x68>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d2a:	60 e0       	ldi	r22, 0x00	; 0
     d2c:	84 1b       	sub	r24, r20
     d2e:	95 0b       	sbc	r25, r21
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d30:	e2 dd       	rcall	.-1084   	; 0x8f6 <prvAddCurrentTaskToDelayedList>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d32:	5f df       	rcall	.-322    	; 0xbf2 <xTaskResumeAll>
     d34:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
     d36:	01 c0       	rjmp	.+2      	; 0xd3a <vTaskDelayUntil+0x70>
     d38:	e3 da       	rcall	.-2618   	; 0x300 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d3a:	df 91       	pop	r29
     d3c:	cf 91       	pop	r28
     d3e:	1f 91       	pop	r17
     d40:	0f 91       	pop	r16
     d42:	08 95       	ret

00000d44 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     d44:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <uxSchedulerSuspended>
     d48:	88 23       	and	r24, r24
     d4a:	21 f0       	breq	.+8      	; 0xd54 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	80 93 bf 05 	sts	0x05BF, r24	; 0x8005bf <xYieldPending>
     d52:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     d54:	10 92 bf 05 	sts	0x05BF, r1	; 0x8005bf <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     d58:	20 91 c2 05 	lds	r18, 0x05C2	; 0x8005c2 <uxTopReadyPriority>
     d5c:	01 c0       	rjmp	.+2      	; 0xd60 <vTaskSwitchContext+0x1c>
     d5e:	21 50       	subi	r18, 0x01	; 1
     d60:	82 2f       	mov	r24, r18
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	fc 01       	movw	r30, r24
     d66:	ee 0f       	add	r30, r30
     d68:	ff 1f       	adc	r31, r31
     d6a:	ee 0f       	add	r30, r30
     d6c:	ff 1f       	adc	r31, r31
     d6e:	ee 0f       	add	r30, r30
     d70:	ff 1f       	adc	r31, r31
     d72:	e8 0f       	add	r30, r24
     d74:	f9 1f       	adc	r31, r25
     d76:	eb 51       	subi	r30, 0x1B	; 27
     d78:	fa 4f       	sbci	r31, 0xFA	; 250
     d7a:	30 81       	ld	r19, Z
     d7c:	33 23       	and	r19, r19
     d7e:	79 f3       	breq	.-34     	; 0xd5e <vTaskSwitchContext+0x1a>
     d80:	ac 01       	movw	r20, r24
     d82:	44 0f       	add	r20, r20
     d84:	55 1f       	adc	r21, r21
     d86:	44 0f       	add	r20, r20
     d88:	55 1f       	adc	r21, r21
     d8a:	44 0f       	add	r20, r20
     d8c:	55 1f       	adc	r21, r21
     d8e:	48 0f       	add	r20, r24
     d90:	59 1f       	adc	r21, r25
     d92:	df 01       	movw	r26, r30
     d94:	01 80       	ldd	r0, Z+1	; 0x01
     d96:	f2 81       	ldd	r31, Z+2	; 0x02
     d98:	e0 2d       	mov	r30, r0
     d9a:	02 80       	ldd	r0, Z+2	; 0x02
     d9c:	f3 81       	ldd	r31, Z+3	; 0x03
     d9e:	e0 2d       	mov	r30, r0
     da0:	12 96       	adiw	r26, 0x02	; 2
     da2:	fc 93       	st	X, r31
     da4:	ee 93       	st	-X, r30
     da6:	11 97       	sbiw	r26, 0x01	; 1
     da8:	48 51       	subi	r20, 0x18	; 24
     daa:	5a 4f       	sbci	r21, 0xFA	; 250
     dac:	e4 17       	cp	r30, r20
     dae:	f5 07       	cpc	r31, r21
     db0:	29 f4       	brne	.+10     	; 0xdbc <vTaskSwitchContext+0x78>
     db2:	42 81       	ldd	r20, Z+2	; 0x02
     db4:	53 81       	ldd	r21, Z+3	; 0x03
     db6:	fd 01       	movw	r30, r26
     db8:	52 83       	std	Z+2, r21	; 0x02
     dba:	41 83       	std	Z+1, r20	; 0x01
     dbc:	fc 01       	movw	r30, r24
     dbe:	ee 0f       	add	r30, r30
     dc0:	ff 1f       	adc	r31, r31
     dc2:	ee 0f       	add	r30, r30
     dc4:	ff 1f       	adc	r31, r31
     dc6:	ee 0f       	add	r30, r30
     dc8:	ff 1f       	adc	r31, r31
     dca:	8e 0f       	add	r24, r30
     dcc:	9f 1f       	adc	r25, r31
     dce:	fc 01       	movw	r30, r24
     dd0:	eb 51       	subi	r30, 0x1B	; 27
     dd2:	fa 4f       	sbci	r31, 0xFA	; 250
     dd4:	01 80       	ldd	r0, Z+1	; 0x01
     dd6:	f2 81       	ldd	r31, Z+2	; 0x02
     dd8:	e0 2d       	mov	r30, r0
     dda:	86 81       	ldd	r24, Z+6	; 0x06
     ddc:	97 81       	ldd	r25, Z+7	; 0x07
     dde:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <pxCurrentTCB+0x1>
     de2:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <pxCurrentTCB>
     de6:	20 93 c2 05 	sts	0x05C2, r18	; 0x8005c2 <uxTopReadyPriority>
     dea:	08 95       	ret

00000dec <BLUETOOTH_SetATMode>:
/*- FUNCTION DECLARATIONS ----------------------------------*/
static ERROR_STATE_t BLUETOOTH_SetATMode(uint8_t BluetoothNumber);

/*- FUNCTION IMPLEMENTATION ----------------------------------*/
static ERROR_STATE_t BLUETOOTH_SetATMode(uint8_t BluetoothNumber)
{
     dec:	df 92       	push	r13
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	cf 93       	push	r28
     df8:	df 93       	push	r29
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <BLUETOOTH_SetATMode+0x10>
     dfc:	cd b7       	in	r28, 0x3d	; 61
     dfe:	de b7       	in	r29, 0x3e	; 62
	uint8_t u8_ErrorState=ERROR_OK;
	/*AT Mode Sequance*/
	
   /*set the enable pin high*/
	DIO_WritePin(
     e00:	0c e8       	ldi	r16, 0x8C	; 140
     e02:	11 e0       	ldi	r17, 0x01	; 1
     e04:	f8 01       	movw	r30, r16
     e06:	e3 80       	ldd	r14, Z+3	; 0x03
     e08:	f4 80       	ldd	r15, Z+4	; 0x04
     e0a:	40 e0       	ldi	r20, 0x00	; 0
     e0c:	6e 2d       	mov	r22, r14
     e0e:	8f 2d       	mov	r24, r15
     e10:	e9 d7       	rcall	.+4050   	; 0x1de4 <DIO_WritePin>
	gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PIN,
	PIN_LOW
	);
   
   /*set the power pin low*/
	DIO_WritePin(
     e12:	f8 01       	movw	r30, r16
     e14:	d1 80       	ldd	r13, Z+1	; 0x01
     e16:	12 81       	ldd	r17, Z+2	; 0x02
     e18:	40 e0       	ldi	r20, 0x00	; 0
     e1a:	6d 2d       	mov	r22, r13
     e1c:	81 2f       	mov	r24, r17
     e1e:	e2 d7       	rcall	.+4036   	; 0x1de4 <DIO_WritePin>
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PIN,
					PIN_LOW
				);		
	
	/*set the power pin high*/
	DIO_WritePin(
     e20:	41 e0       	ldi	r20, 0x01	; 1
     e22:	6d 2d       	mov	r22, r13
     e24:	81 2f       	mov	r24, r17
     e26:	de d7       	rcall	.+4028   	; 0x1de4 <DIO_WritePin>
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PORT,
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PIN,
					PIN_HIGH
				);
				
   for(volatile uint8_t i = 0; i<100;i++)
     e28:	1a 82       	std	Y+2, r1	; 0x02
     e2a:	0b c0       	rjmp	.+22     	; 0xe42 <BLUETOOTH_SetATMode+0x56>
   {
      for(volatile uint8_t j = 0; j<3; j++)
     e2c:	19 82       	std	Y+1, r1	; 0x01
     e2e:	03 c0       	rjmp	.+6      	; 0xe36 <BLUETOOTH_SetATMode+0x4a>
     e30:	89 81       	ldd	r24, Y+1	; 0x01
     e32:	8f 5f       	subi	r24, 0xFF	; 255
     e34:	89 83       	std	Y+1, r24	; 0x01
     e36:	89 81       	ldd	r24, Y+1	; 0x01
     e38:	83 30       	cpi	r24, 0x03	; 3
     e3a:	d0 f3       	brcs	.-12     	; 0xe30 <BLUETOOTH_SetATMode+0x44>
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PORT,
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PIN,
					PIN_HIGH
				);
				
   for(volatile uint8_t i = 0; i<100;i++)
     e3c:	8a 81       	ldd	r24, Y+2	; 0x02
     e3e:	8f 5f       	subi	r24, 0xFF	; 255
     e40:	8a 83       	std	Y+2, r24	; 0x02
     e42:	8a 81       	ldd	r24, Y+2	; 0x02
     e44:	84 36       	cpi	r24, 0x64	; 100
     e46:	90 f3       	brcs	.-28     	; 0xe2c <BLUETOOTH_SetATMode+0x40>
      {
         
      }
   }      
	/*set the enable pin high*/
	DIO_WritePin(
     e48:	41 e0       	ldi	r20, 0x01	; 1
     e4a:	6e 2d       	mov	r22, r14
     e4c:	8f 2d       	mov	r24, r15
     e4e:	ca d7       	rcall	.+3988   	; 0x1de4 <DIO_WritePin>
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PORT,
					gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PIN,
					PIN_HIGH
				);			

	gu8_BluetoothMode=BLUETOOTH_MODE_AT;
     e50:	81 e0       	ldi	r24, 0x01	; 1
     e52:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <gu8_BluetoothMode>
	return u8_ErrorState ;	
}
     e56:	80 e0       	ldi	r24, 0x00	; 0
     e58:	0f 90       	pop	r0
     e5a:	0f 90       	pop	r0
     e5c:	df 91       	pop	r29
     e5e:	cf 91       	pop	r28
     e60:	1f 91       	pop	r17
     e62:	0f 91       	pop	r16
     e64:	ff 90       	pop	r15
     e66:	ef 90       	pop	r14
     e68:	df 90       	pop	r13
     e6a:	08 95       	ret

00000e6c <BLUETOOTH_SetDataMode>:
 */
 
 ERROR_STATE_t BLUETOOTH_SetDataMode(uint8_t BluetoothNumber)
 {
	uint8_t u8_ErrorState=ERROR_OK;
	gu8_BluetoothMode=BLUETOOTH_MODE_DATA;
     e6c:	82 e0       	ldi	r24, 0x02	; 2
     e6e:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <gu8_BluetoothMode>
	return u8_ErrorState ; 	 
 }
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	08 95       	ret

00000e76 <BLUETOOTH_Init>:

ERROR_STATE_t BLUETOOTH_Init(void)
{
     e76:	0f 93       	push	r16
     e78:	1f 93       	push	r17
     e7a:	cf 93       	push	r28
     e7c:	df 93       	push	r29
	uint8_t u8_ErrorState=ERROR_OK;
	/*check if bluetooth has been initialized*/
	if (NOT_INIT == gu8_InitFlag) //if bluetooth is not initialized
     e7e:	80 91 12 06 	lds	r24, 0x0612	; 0x800612 <gu8_InitFlag>
     e82:	81 11       	cpse	r24, r1
     e84:	1a c0       	rjmp	.+52     	; 0xeba <BLUETOOTH_Init+0x44>
	{
		/*set the power pin as an output*/
		DIO_SetPinDirection(
     e86:	cc e8       	ldi	r28, 0x8C	; 140
     e88:	d1 e0       	ldi	r29, 0x01	; 1
     e8a:	41 e0       	ldi	r20, 0x01	; 1
     e8c:	69 81       	ldd	r22, Y+1	; 0x01
     e8e:	8a 81       	ldd	r24, Y+2	; 0x02
     e90:	40 d7       	rcall	.+3712   	; 0x1d12 <DIO_SetPinDirection>
							gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PORT,
							gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_POWER_PIN,
							PIN_OUTPUT
							);		
		/*set the power pin as an output*/
		DIO_SetPinDirection(
     e92:	0b 81       	ldd	r16, Y+3	; 0x03
     e94:	1c 81       	ldd	r17, Y+4	; 0x04
     e96:	41 e0       	ldi	r20, 0x01	; 1
     e98:	60 2f       	mov	r22, r16
     e9a:	81 2f       	mov	r24, r17
     e9c:	3a d7       	rcall	.+3700   	; 0x1d12 <DIO_SetPinDirection>
							gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PORT,
							gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PIN,
							PIN_OUTPUT
							);
                     
      DIO_WritePin(
     e9e:	40 e0       	ldi	r20, 0x00	; 0
     ea0:	60 2f       	mov	r22, r16
     ea2:	81 2f       	mov	r24, r17
     ea4:	9f d7       	rcall	.+3902   	; 0x1de4 <DIO_WritePin>
         gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PORT,
         gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_ENABLE_PIN,
         PIN_LOW
      );
		/*init the uart ch_0*/
		UART_Init(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH);
     ea6:	88 81       	ld	r24, Y
     ea8:	0e 94 66 10 	call	0x20cc	; 0x20cc <UART_Init>
		
      BLUETOOTH_SetATMode(BLUETOOTH_0);
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	9e df       	rcall	.-196    	; 0xdec <BLUETOOTH_SetATMode>
		gu8_InitFlag = INIT;
     eb0:	81 e0       	ldi	r24, 0x01	; 1
     eb2:	80 93 12 06 	sts	0x0612, r24	; 0x800612 <gu8_InitFlag>
		u8_ErrorState=ERROR_OK;
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	05 c0       	rjmp	.+10     	; 0xec4 <BLUETOOTH_Init+0x4e>
	} 
	/*if bluetooth is initialized*/
	else if (INIT == gu8_InitFlag) 
     eba:	81 30       	cpi	r24, 0x01	; 1
     ebc:	11 f0       	breq	.+4      	; 0xec2 <BLUETOOTH_Init+0x4c>
	return u8_ErrorState ; 	 
 }

ERROR_STATE_t BLUETOOTH_Init(void)
{
	uint8_t u8_ErrorState=ERROR_OK;
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	01 c0       	rjmp	.+2      	; 0xec4 <BLUETOOTH_Init+0x4e>
		u8_ErrorState=ERROR_OK;
	} 
	/*if bluetooth is initialized*/
	else if (INIT == gu8_InitFlag) 
	{
		u8_ErrorState = ERROR_NOK; 
     ec2:	81 e0       	ldi	r24, 0x01	; 1
	else 
	{
		//Do Nothing
	}
	return u8_ErrorState ;
}
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	1f 91       	pop	r17
     eca:	0f 91       	pop	r16
     ecc:	08 95       	ret

00000ece <BLUETOOTH_SendData>:

ERROR_STATE_t BLUETOOTH_SendData(uint8_t BluetoothNumber,ptr_uint8_t Data)
{
     ece:	0f 93       	push	r16
     ed0:	1f 93       	push	r17
     ed2:	cf 93       	push	r28
     ed4:	df 93       	push	r29
     ed6:	d8 2f       	mov	r29, r24
     ed8:	8b 01       	movw	r16, r22
	uint8_t u8_ErrorState=ERROR_OK;
	static uint8_t u8_DataCounter=ZERO;
	if(ERROR_OK==UART_IsDataAvailableToWrite(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH))
     eda:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <gastr_BLUETOOTH_Config>
     ede:	8c 2f       	mov	r24, r28
     ee0:	0e 94 11 11 	call	0x2222	; 0x2222 <UART_IsDataAvailableToWrite>
     ee4:	81 11       	cpse	r24, r1
     ee6:	22 c0       	rjmp	.+68     	; 0xf2c <BLUETOOTH_SendData+0x5e>
	{
		if(NULL_PTR!=Data)
     ee8:	01 15       	cp	r16, r1
     eea:	11 05       	cpc	r17, r1
     eec:	09 f1       	breq	.+66     	; 0xf30 <BLUETOOTH_SendData+0x62>
		{
			if(BLUETOOTH_MODE_DATA==gu8_BluetoothMode)
     eee:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <gu8_BluetoothMode>
     ef2:	82 30       	cpi	r24, 0x02	; 2
     ef4:	f9 f4       	brne	.+62     	; 0xf34 <BLUETOOTH_SendData+0x66>
			{
				switch(BluetoothNumber)
     ef6:	d1 11       	cpse	r29, r1
     ef8:	1f c0       	rjmp	.+62     	; 0xf38 <BLUETOOTH_SendData+0x6a>
				{
				  case BLUETOOTH_0:
					if(NULL_TERMINATOR==Data[u8_DataCounter])
     efa:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <u8_DataCounter.1726>
     efe:	f8 01       	movw	r30, r16
     f00:	e8 0f       	add	r30, r24
     f02:	f1 1d       	adc	r31, r1
     f04:	60 81       	ld	r22, Z
     f06:	61 11       	cpse	r22, r1
     f08:	07 c0       	rjmp	.+14     	; 0xf18 <BLUETOOTH_SendData+0x4a>
					{
						UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , Data[u8_DataCounter]);
     f0a:	8c 2f       	mov	r24, r28
     f0c:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
						u8_ErrorState=ERROR_OK;
						u8_DataCounter=ZERO;
     f10:	10 92 10 06 	sts	0x0610, r1	; 0x800610 <u8_DataCounter.1726>
				{
				  case BLUETOOTH_0:
					if(NULL_TERMINATOR==Data[u8_DataCounter])
					{
						UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , Data[u8_DataCounter]);
						u8_ErrorState=ERROR_OK;
     f14:	80 e0       	ldi	r24, 0x00	; 0
     f16:	11 c0       	rjmp	.+34     	; 0xf3a <BLUETOOTH_SendData+0x6c>
						u8_DataCounter=ZERO;
					}
					else
					{
						UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , Data[u8_DataCounter]);
     f18:	8c 2f       	mov	r24, r28
     f1a:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
						u8_DataCounter++;
     f1e:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <u8_DataCounter.1726>
     f22:	8f 5f       	subi	r24, 0xFF	; 255
     f24:	80 93 10 06 	sts	0x0610, r24	; 0x800610 <u8_DataCounter.1726>
						u8_ErrorState=ERROR_NOK;
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	07 c0       	rjmp	.+14     	; 0xf3a <BLUETOOTH_SendData+0x6c>
	return u8_ErrorState ;
}

ERROR_STATE_t BLUETOOTH_SendData(uint8_t BluetoothNumber,ptr_uint8_t Data)
{
	uint8_t u8_ErrorState=ERROR_OK;
     f2c:	80 e0       	ldi	r24, 0x00	; 0
     f2e:	05 c0       	rjmp	.+10     	; 0xf3a <BLUETOOTH_SendData+0x6c>
				}	
			}
		}
		else
		{
			u8_ErrorState=ERROR_NULL_PTR;
     f30:	82 e0       	ldi	r24, 0x02	; 2
     f32:	03 c0       	rjmp	.+6      	; 0xf3a <BLUETOOTH_SendData+0x6c>
	return u8_ErrorState ;
}

ERROR_STATE_t BLUETOOTH_SendData(uint8_t BluetoothNumber,ptr_uint8_t Data)
{
	uint8_t u8_ErrorState=ERROR_OK;
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	01 c0       	rjmp	.+2      	; 0xf3a <BLUETOOTH_SendData+0x6c>
						u8_DataCounter++;
						u8_ErrorState=ERROR_NOK;
					}
					break;
				  default:
					u8_ErrorState=ERROR_UNSUPPORTED_CH;
     f38:	83 e0       	ldi	r24, 0x03	; 3
		{
			u8_ErrorState=ERROR_NULL_PTR;
		}
	}
	return u8_ErrorState ;	
}
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	08 95       	ret

00000f44 <BLUETOOTH_ReceiveData>:

ERROR_STATE_t BLUETOOTH_ReceiveData(uint8_t BluetoothNumber,ptr_uint8_t RxData)
{
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
	uint8_t u8_ErrorState=ERROR_NOK;
	static uint8_t u8_DataCounter=ZERO;
	if(NULL_PTR!=RxData)
     f48:	61 15       	cp	r22, r1
     f4a:	71 05       	cpc	r23, r1
     f4c:	41 f1       	breq	.+80     	; 0xf9e <BLUETOOTH_ReceiveData+0x5a>
	{
		switch(BluetoothNumber)
     f4e:	81 11       	cpse	r24, r1
     f50:	28 c0       	rjmp	.+80     	; 0xfa2 <BLUETOOTH_ReceiveData+0x5e>
     f52:	eb 01       	movw	r28, r22
		{
		  case BLUETOOTH_0:
			UART_GetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH,(RxData+u8_DataCounter));
     f54:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <u8_DataCounter.1735>
     f58:	68 0f       	add	r22, r24
     f5a:	71 1d       	adc	r23, r1
     f5c:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <gastr_BLUETOOTH_Config>
     f60:	0e 94 c7 10 	call	0x218e	; 0x218e <UART_GetData>
			if((NULL_TERMINATOR==RxData[u8_DataCounter]))
     f64:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <u8_DataCounter.1735>
     f68:	fe 01       	movw	r30, r28
     f6a:	e8 0f       	add	r30, r24
     f6c:	f1 1d       	adc	r31, r1
     f6e:	90 81       	ld	r25, Z
     f70:	91 11       	cpse	r25, r1
     f72:	05 c0       	rjmp	.+10     	; 0xf7e <BLUETOOTH_ReceiveData+0x3a>
			{
				RxData[u8_DataCounter]=NULL_TERMINATOR;
     f74:	10 82       	st	Z, r1
				u8_ErrorState=ERROR_OK;
				u8_DataCounter=ZERO;
     f76:	10 92 0f 06 	sts	0x060F, r1	; 0x80060f <u8_DataCounter.1735>
		  case BLUETOOTH_0:
			UART_GetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH,(RxData+u8_DataCounter));
			if((NULL_TERMINATOR==RxData[u8_DataCounter]))
			{
				RxData[u8_DataCounter]=NULL_TERMINATOR;
				u8_ErrorState=ERROR_OK;
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	13 c0       	rjmp	.+38     	; 0xfa4 <BLUETOOTH_ReceiveData+0x60>
				u8_DataCounter=ZERO;
			}
			else if ('\n'==RxData[u8_DataCounter])
     f7e:	9a 30       	cpi	r25, 0x0A	; 10
     f80:	49 f4       	brne	.+18     	; 0xf94 <BLUETOOTH_ReceiveData+0x50>
			{
				RxData[u8_DataCounter]='\n';
     f82:	90 83       	st	Z, r25
				u8_DataCounter++;
     f84:	8f 5f       	subi	r24, 0xFF	; 255
				RxData[u8_DataCounter]=NULL_TERMINATOR;
     f86:	c8 0f       	add	r28, r24
     f88:	d1 1d       	adc	r29, r1
     f8a:	18 82       	st	Y, r1
				u8_ErrorState=ERROR_OK;
				u8_DataCounter=ZERO;
     f8c:	10 92 0f 06 	sts	0x060F, r1	; 0x80060f <u8_DataCounter.1735>
			else if ('\n'==RxData[u8_DataCounter])
			{
				RxData[u8_DataCounter]='\n';
				u8_DataCounter++;
				RxData[u8_DataCounter]=NULL_TERMINATOR;
				u8_ErrorState=ERROR_OK;
     f90:	80 e0       	ldi	r24, 0x00	; 0
     f92:	08 c0       	rjmp	.+16     	; 0xfa4 <BLUETOOTH_ReceiveData+0x60>
				u8_DataCounter=ZERO;
			}
			else
			{
				u8_DataCounter++;
     f94:	8f 5f       	subi	r24, 0xFF	; 255
     f96:	80 93 0f 06 	sts	0x060F, r24	; 0x80060f <u8_DataCounter.1735>
	return u8_ErrorState ;	
}

ERROR_STATE_t BLUETOOTH_ReceiveData(uint8_t BluetoothNumber,ptr_uint8_t RxData)
{
	uint8_t u8_ErrorState=ERROR_NOK;
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	03 c0       	rjmp	.+6      	; 0xfa4 <BLUETOOTH_ReceiveData+0x60>
			break;
		}		
	}
	else
	{
		u8_ErrorState=ERROR_NULL_PTR;
     f9e:	82 e0       	ldi	r24, 0x02	; 2
     fa0:	01 c0       	rjmp	.+2      	; 0xfa4 <BLUETOOTH_ReceiveData+0x60>
				u8_DataCounter++;
			}
			
			break;
		  default:
			u8_ErrorState=ERROR_UNSUPPORTED_CH;
     fa2:	83 e0       	ldi	r24, 0x03	; 3
	{
		u8_ErrorState=ERROR_NULL_PTR;
	}

	return u8_ErrorState ;	
}
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	08 95       	ret

00000faa <BLUETOOTH_ATModeGetCommand>:

ERROR_STATE_t BLUETOOTH_ATModeGetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD)
{
     faa:	0f 93       	push	r16
     fac:	1f 93       	push	r17
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	d8 2f       	mov	r29, r24
     fb4:	8b 01       	movw	r16, r22
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
	static uint8_t u8_CMDCounter=ZERO;
	if(ERROR_OK==UART_IsDataAvailableToWrite(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH))
     fb6:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <gastr_BLUETOOTH_Config>
     fba:	8c 2f       	mov	r24, r28
     fbc:	0e 94 11 11 	call	0x2222	; 0x2222 <UART_IsDataAvailableToWrite>
     fc0:	81 11       	cpse	r24, r1
     fc2:	46 c0       	rjmp	.+140    	; 0x1050 <BLUETOOTH_ATModeGetCommand+0xa6>
	{
		if(NULL_PTR!=CMD)
     fc4:	01 15       	cp	r16, r1
     fc6:	11 05       	cpc	r17, r1
     fc8:	09 f4       	brne	.+2      	; 0xfcc <BLUETOOTH_ATModeGetCommand+0x22>
     fca:	44 c0       	rjmp	.+136    	; 0x1054 <BLUETOOTH_ATModeGetCommand+0xaa>
		{
			if(BLUETOOTH_MODE_AT!=gu8_BluetoothMode)
     fcc:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <gu8_BluetoothMode>
     fd0:	81 30       	cpi	r24, 0x01	; 1
     fd2:	11 f0       	breq	.+4      	; 0xfd8 <BLUETOOTH_ATModeGetCommand+0x2e>
			{
				/*AT Mode Sequance*/
				BLUETOOTH_SetATMode(BluetoothNumber);
     fd4:	8d 2f       	mov	r24, r29
     fd6:	0a df       	rcall	.-492    	; 0xdec <BLUETOOTH_SetATMode>
			}
			else
			{
				/*Do Nothing*/
			}
			if(BLUETOOTH_MODE_AT==gu8_BluetoothMode)
     fd8:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <gu8_BluetoothMode>
     fdc:	81 30       	cpi	r24, 0x01	; 1
     fde:	e1 f5       	brne	.+120    	; 0x1058 <BLUETOOTH_ATModeGetCommand+0xae>
			{
				switch(BluetoothNumber)
     fe0:	d1 11       	cpse	r29, r1
     fe2:	3c c0       	rjmp	.+120    	; 0x105c <BLUETOOTH_ATModeGetCommand+0xb2>
				{
				  case BLUETOOTH_0:
					if(BLUETOOTH_STATE_CMD==u8_CMDState)
     fe4:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <u8_CMDState.1743>
     fe8:	81 11       	cpse	r24, r1
     fea:	16 c0       	rjmp	.+44     	; 0x1018 <BLUETOOTH_ATModeGetCommand+0x6e>
					{
						if(NULL_TERMINATOR!=CMD[u8_CMDCounter])
     fec:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <u8_CMDCounter.1745>
     ff0:	f8 01       	movw	r30, r16
     ff2:	e8 0f       	add	r30, r24
     ff4:	f1 1d       	adc	r31, r1
     ff6:	60 81       	ld	r22, Z
     ff8:	66 23       	and	r22, r22
     ffa:	49 f0       	breq	.+18     	; 0x100e <BLUETOOTH_ATModeGetCommand+0x64>
						{
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , CMD[u8_CMDCounter]);
     ffc:	8c 2f       	mov	r24, r28
     ffe:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
							u8_CMDCounter++;
    1002:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <u8_CMDCounter.1745>
    1006:	8f 5f       	subi	r24, 0xFF	; 255
    1008:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <u8_CMDCounter.1745>
    100c:	05 c0       	rjmp	.+10     	; 0x1018 <BLUETOOTH_ATModeGetCommand+0x6e>
						}
						else
						{
							u8_CMDState=BLUETOOTH_STATE_EOS;
    100e:	82 e0       	ldi	r24, 0x02	; 2
    1010:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <u8_CMDState.1743>
							u8_CMDCounter=ZERO;
    1014:	10 92 0d 06 	sts	0x060D, r1	; 0x80060d <u8_CMDCounter.1745>
					}
					else
					{
						/*Do Nothing*/
					}				
					if(BLUETOOTH_STATE_EOS==u8_CMDState)
    1018:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <u8_CMDState.1743>
    101c:	82 30       	cpi	r24, 0x02	; 2
    101e:	01 f5       	brne	.+64     	; 0x1060 <BLUETOOTH_ATModeGetCommand+0xb6>
					{
						if(NULL_TERMINATOR!=gu8_BluetoothEOS[u8_CMDCounter])
    1020:	e0 91 0d 06 	lds	r30, 0x060D	; 0x80060d <u8_CMDCounter.1745>
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	e8 5f       	subi	r30, 0xF8	; 248
    1028:	fe 4f       	sbci	r31, 0xFE	; 254
    102a:	60 81       	ld	r22, Z
    102c:	66 23       	and	r22, r22
    102e:	51 f0       	breq	.+20     	; 0x1044 <BLUETOOTH_ATModeGetCommand+0x9a>
						{
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , gu8_BluetoothEOS[u8_CMDCounter]);
    1030:	8c 2f       	mov	r24, r28
    1032:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
							u8_CMDCounter++;
    1036:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <u8_CMDCounter.1745>
    103a:	8f 5f       	subi	r24, 0xFF	; 255
    103c:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <u8_CMDCounter.1745>
}

ERROR_STATE_t BLUETOOTH_ATModeGetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	0f c0       	rjmp	.+30     	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
							u8_CMDCounter++;

						}
						else
						{
							u8_CMDState=BLUETOOTH_STATE_CMD;
    1044:	10 92 0e 06 	sts	0x060E, r1	; 0x80060e <u8_CMDState.1743>
							u8_CMDCounter=ZERO;
    1048:	10 92 0d 06 	sts	0x060D, r1	; 0x80060d <u8_CMDCounter.1745>
}

ERROR_STATE_t BLUETOOTH_ATModeGetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	09 c0       	rjmp	.+18     	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	07 c0       	rjmp	.+14     	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	05 c0       	rjmp	.+10     	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	03 c0       	rjmp	.+6      	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
					{
						/*Do Nothing*/
					}
					break;
				  default:
					u8_ErrorState=ERROR_UNSUPPORTED_CH;
    105c:	83 e0       	ldi	r24, 0x03	; 3
    105e:	01 c0       	rjmp	.+2      	; 0x1062 <BLUETOOTH_ATModeGetCommand+0xb8>
}

ERROR_STATE_t BLUETOOTH_ATModeGetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    1060:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}
	return u8_ErrorState;
}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	1f 91       	pop	r17
    1068:	0f 91       	pop	r16
    106a:	08 95       	ret

0000106c <BLUETOOTH_ATModeSetCommand>:

ERROR_STATE_t BLUETOOTH_ATModeSetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD,ptr_uint8_t Param)
{
    106c:	ef 92       	push	r14
    106e:	ff 92       	push	r15
    1070:	0f 93       	push	r16
    1072:	1f 93       	push	r17
    1074:	cf 93       	push	r28
    1076:	df 93       	push	r29
    1078:	d8 2f       	mov	r29, r24
    107a:	8b 01       	movw	r16, r22
    107c:	7a 01       	movw	r14, r20
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
	static uint8_t u8_CMDCounter=ZERO;
	if(ERROR_OK==UART_IsDataAvailableToWrite(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH))
    107e:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <gastr_BLUETOOTH_Config>
    1082:	8c 2f       	mov	r24, r28
    1084:	0e 94 11 11 	call	0x2222	; 0x2222 <UART_IsDataAvailableToWrite>
    1088:	81 11       	cpse	r24, r1
    108a:	61 c0       	rjmp	.+194    	; 0x114e <BLUETOOTH_ATModeSetCommand+0xe2>
	{
		if(NULL_PTR!=CMD)
    108c:	01 15       	cp	r16, r1
    108e:	11 05       	cpc	r17, r1
    1090:	09 f4       	brne	.+2      	; 0x1094 <BLUETOOTH_ATModeSetCommand+0x28>
    1092:	5f c0       	rjmp	.+190    	; 0x1152 <BLUETOOTH_ATModeSetCommand+0xe6>
		{
			if(BLUETOOTH_MODE_AT!=gu8_BluetoothMode)
    1094:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <gu8_BluetoothMode>
    1098:	81 30       	cpi	r24, 0x01	; 1
    109a:	11 f0       	breq	.+4      	; 0x10a0 <BLUETOOTH_ATModeSetCommand+0x34>
			{
				/*AT Mode Sequance*/
				BLUETOOTH_SetATMode(BluetoothNumber);
    109c:	8d 2f       	mov	r24, r29
    109e:	a6 de       	rcall	.-692    	; 0xdec <BLUETOOTH_SetATMode>
			}
			else
			{
				/*Do Nothing*/
			}
			if(BLUETOOTH_MODE_AT==gu8_BluetoothMode)
    10a0:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <gu8_BluetoothMode>
    10a4:	81 30       	cpi	r24, 0x01	; 1
    10a6:	09 f0       	breq	.+2      	; 0x10aa <BLUETOOTH_ATModeSetCommand+0x3e>
    10a8:	56 c0       	rjmp	.+172    	; 0x1156 <BLUETOOTH_ATModeSetCommand+0xea>
			{
				switch(BluetoothNumber)
    10aa:	d1 11       	cpse	r29, r1
    10ac:	56 c0       	rjmp	.+172    	; 0x115a <BLUETOOTH_ATModeSetCommand+0xee>
				{
				  case BLUETOOTH_0:
					if(BLUETOOTH_STATE_CMD==u8_CMDState)
    10ae:	80 91 0c 06 	lds	r24, 0x060C	; 0x80060c <u8_CMDState.1754>
    10b2:	81 11       	cpse	r24, r1
    10b4:	16 c0       	rjmp	.+44     	; 0x10e2 <BLUETOOTH_ATModeSetCommand+0x76>
					{
						if(NULL_TERMINATOR!=CMD[u8_CMDCounter])
    10b6:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    10ba:	f8 01       	movw	r30, r16
    10bc:	e8 0f       	add	r30, r24
    10be:	f1 1d       	adc	r31, r1
    10c0:	60 81       	ld	r22, Z
    10c2:	66 23       	and	r22, r22
    10c4:	49 f0       	breq	.+18     	; 0x10d8 <BLUETOOTH_ATModeSetCommand+0x6c>
						{
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , CMD[u8_CMDCounter]);
    10c6:	8c 2f       	mov	r24, r28
    10c8:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
							u8_CMDCounter++;
    10cc:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    10d0:	8f 5f       	subi	r24, 0xFF	; 255
    10d2:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <u8_CMDCounter.1756>
    10d6:	05 c0       	rjmp	.+10     	; 0x10e2 <BLUETOOTH_ATModeSetCommand+0x76>
						}
						else
						{
							u8_CMDState=BLUETOOTH_STATE_PARAM;
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	80 93 0c 06 	sts	0x060C, r24	; 0x80060c <u8_CMDState.1754>
							u8_CMDCounter=ZERO;
    10de:	10 92 0b 06 	sts	0x060B, r1	; 0x80060b <u8_CMDCounter.1756>
					}
					else
					{
						/*Do Nothing*/
					}				
					if(BLUETOOTH_STATE_PARAM==u8_CMDState)
    10e2:	80 91 0c 06 	lds	r24, 0x060C	; 0x80060c <u8_CMDState.1754>
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	b1 f4       	brne	.+44     	; 0x1116 <BLUETOOTH_ATModeSetCommand+0xaa>
					{
						if(NULL_TERMINATOR!=Param[u8_CMDCounter])
    10ea:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    10ee:	f7 01       	movw	r30, r14
    10f0:	e8 0f       	add	r30, r24
    10f2:	f1 1d       	adc	r31, r1
    10f4:	60 81       	ld	r22, Z
    10f6:	66 23       	and	r22, r22
    10f8:	49 f0       	breq	.+18     	; 0x110c <BLUETOOTH_ATModeSetCommand+0xa0>
						{
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , Param[u8_CMDCounter]);
    10fa:	8c 2f       	mov	r24, r28
    10fc:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
							u8_CMDCounter++;
    1100:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    1104:	8f 5f       	subi	r24, 0xFF	; 255
    1106:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <u8_CMDCounter.1756>
    110a:	05 c0       	rjmp	.+10     	; 0x1116 <BLUETOOTH_ATModeSetCommand+0xaa>
						}
						else
						{
							u8_CMDState=BLUETOOTH_STATE_EOS;
    110c:	82 e0       	ldi	r24, 0x02	; 2
    110e:	80 93 0c 06 	sts	0x060C, r24	; 0x80060c <u8_CMDState.1754>
							u8_CMDCounter=ZERO;
    1112:	10 92 0b 06 	sts	0x060B, r1	; 0x80060b <u8_CMDCounter.1756>
					}
					else
					{
						/*Do Nothing*/
					}				
					if(BLUETOOTH_STATE_EOS==u8_CMDState)
    1116:	80 91 0c 06 	lds	r24, 0x060C	; 0x80060c <u8_CMDState.1754>
    111a:	82 30       	cpi	r24, 0x02	; 2
    111c:	01 f5       	brne	.+64     	; 0x115e <BLUETOOTH_ATModeSetCommand+0xf2>
					{
						if(NULL_TERMINATOR!=gu8_BluetoothEOS[u8_CMDCounter])
    111e:	e0 91 0b 06 	lds	r30, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	e8 5f       	subi	r30, 0xF8	; 248
    1126:	fe 4f       	sbci	r31, 0xFE	; 254
    1128:	60 81       	ld	r22, Z
    112a:	66 23       	and	r22, r22
    112c:	51 f0       	breq	.+20     	; 0x1142 <BLUETOOTH_ATModeSetCommand+0xd6>
						{
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , gu8_BluetoothEOS[u8_CMDCounter]);
    112e:	8c 2f       	mov	r24, r28
    1130:	0e 94 c4 10 	call	0x2188	; 0x2188 <UART_SetData>
							u8_CMDCounter++;
    1134:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <u8_CMDCounter.1756>
    1138:	8f 5f       	subi	r24, 0xFF	; 255
    113a:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <u8_CMDCounter.1756>
}

ERROR_STATE_t BLUETOOTH_ATModeSetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD,ptr_uint8_t Param)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	0f c0       	rjmp	.+30     	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
							UART_SetData(gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH , gu8_BluetoothEOS[u8_CMDCounter]);
							u8_CMDCounter++;
						}
						else
						{
							u8_CMDState=BLUETOOTH_STATE_CMD;
    1142:	10 92 0c 06 	sts	0x060C, r1	; 0x80060c <u8_CMDState.1754>
							u8_CMDCounter=ZERO;
    1146:	10 92 0b 06 	sts	0x060B, r1	; 0x80060b <u8_CMDCounter.1756>
							u8_ErrorState=ERROR_OK;
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	09 c0       	rjmp	.+18     	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
}

ERROR_STATE_t BLUETOOTH_ATModeSetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD,ptr_uint8_t Param)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	07 c0       	rjmp	.+14     	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
    1152:	81 e0       	ldi	r24, 0x01	; 1
    1154:	05 c0       	rjmp	.+10     	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	03 c0       	rjmp	.+6      	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
					{
						/*Do Nothing*/
					}
					break;
				  default:
					u8_ErrorState=ERROR_UNSUPPORTED_CH;
    115a:	83 e0       	ldi	r24, 0x03	; 3
    115c:	01 c0       	rjmp	.+2      	; 0x1160 <BLUETOOTH_ATModeSetCommand+0xf4>
}

ERROR_STATE_t BLUETOOTH_ATModeSetCommand(uint8_t BluetoothNumber,ptr_uint8_t CMD,ptr_uint8_t Param)
{
	static uint8_t u8_CMDState=BLUETOOTH_STATE_CMD;
	ERROR_STATE_t u8_ErrorState=ERROR_NOK;
    115e:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}
	return u8_ErrorState;
}
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	ff 90       	pop	r15
    116a:	ef 90       	pop	r14
    116c:	08 95       	ret

0000116e <BLUETOOTH_Scan>:

ERROR_STATE_t BLUETOOTH_Scan(uint8_t BluetoothNumber)
{
	ERROR_STATE_t u8_ErrorState=ERROR_OK;
	BLUETOOTH_ATModeGetCommand(BluetoothNumber,(ptr_uint8_t)BLUETOOTH_CMD_GET_INQ);
    116e:	64 ea       	ldi	r22, 0xA4	; 164
    1170:	70 e0       	ldi	r23, 0x00	; 0
    1172:	1b df       	rcall	.-458    	; 0xfaa <BLUETOOTH_ATModeGetCommand>
	return u8_ErrorState;
}
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	08 95       	ret

00001178 <BLUETOOTH_Connect>:

ERROR_STATE_t BLUETOOTH_Connect(uint8_t BluetoothNumber,ptr_uint8_t DeviceMac)
{
    1178:	1f 93       	push	r17
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	18 2f       	mov	r17, r24
    1180:	eb 01       	movw	r28, r22
	ERROR_STATE_t u8_ErrorState=ERROR_OK;
	while(ERROR_OK!=BLUETOOTH_ATModeSetCommand(	BluetoothNumber,(ptr_uint8_t)BLUETOOTH_CMD_SET_LINK,DeviceMac));											
    1182:	ae 01       	movw	r20, r28
    1184:	6b ea       	ldi	r22, 0xAB	; 171
    1186:	70 e0       	ldi	r23, 0x00	; 0
    1188:	81 2f       	mov	r24, r17
    118a:	70 df       	rcall	.-288    	; 0x106c <BLUETOOTH_ATModeSetCommand>
    118c:	81 11       	cpse	r24, r1
    118e:	f9 cf       	rjmp	.-14     	; 0x1182 <BLUETOOTH_Connect+0xa>
	return u8_ErrorState;
}
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	1f 91       	pop	r17
    1196:	08 95       	ret

00001198 <BLUETOOTH_Disconnect>:

ERROR_STATE_t BLUETOOTH_Disconnect(uint8_t BluetoothNumber)
{
	ERROR_STATE_t u8_ErrorState=ERROR_OK;
	BLUETOOTH_SetATMode(BluetoothNumber);
    1198:	29 de       	rcall	.-942    	; 0xdec <BLUETOOTH_SetATMode>
	return u8_ErrorState;
    119a:	80 e0       	ldi	r24, 0x00	; 0
    119c:	08 95       	ret

0000119e <EEPROM_ProxySaveToMemory>:
 *  Author: Ahmed Adel
 */ 
#include "EEPROM_Proxy.h"

ERROR_STATE_t EEPROM_ProxySaveToMemory(uint8_t* CharArr, uint16_t Starting_position, uint16_t* EndingPosition)
{
    119e:	0f 93       	push	r16
    11a0:	1f 93       	push	r17
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	8c 01       	movw	r16, r24
    11a8:	c6 2f       	mov	r28, r22
	/*initialize iterator variable*/
	uint8_t iterator = 0;
	/*return value initializing*/
	uint8_t ErrRetVal = OperationStarted;
	/*calculate the checksum bytes*/
	CRC_16_Calc(CharArr);
    11aa:	7f d2       	rcall	.+1278   	; 0x16aa <CRC_16_Calc>
#include "EEPROM_Proxy.h"

ERROR_STATE_t EEPROM_ProxySaveToMemory(uint8_t* CharArr, uint16_t Starting_position, uint16_t* EndingPosition)
{
	/*initialize iterator variable*/
	uint8_t iterator = 0;
    11ac:	d0 e0       	ldi	r29, 0x00	; 0
	{
		/*check if Current position is in range (at that moment current position is equals to the starting position)*/
		if(CurrentPosition < 1024)
		{
			/*check if end of the array is reached*/
			if(CharArr[iterator] == NULL_TERMINATOR)
    11ae:	f8 01       	movw	r30, r16
    11b0:	ed 0f       	add	r30, r29
    11b2:	f1 1d       	adc	r31, r1
    11b4:	80 81       	ld	r24, Z
    11b6:	88 23       	and	r24, r24
    11b8:	31 f0       	breq	.+12     	; 0x11c6 <EEPROM_ProxySaveToMemory+0x28>
				break;
			}
			else
			{
				/*save byte to the EEPROM*/
				EEPROM_Write(CharArr[iterator], CurrentPosition);
    11ba:	6c 2f       	mov	r22, r28
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	fc d6       	rcall	.+3576   	; 0x1fb8 <EEPROM_Write>
				CurrentPosition++;
    11c0:	cf 5f       	subi	r28, 0xFF	; 255
				iterator++;
    11c2:	df 5f       	subi	r29, 0xFF	; 255
		else
		{
			ErrRetVal = OperationFail;
			break;
		}
	}
    11c4:	f4 cf       	rjmp	.-24     	; 0x11ae <EEPROM_ProxySaveToMemory+0x10>
		{
			/*check if end of the array is reached*/
			if(CharArr[iterator] == NULL_TERMINATOR)
			{
				/*save to EEPROM*/
				EEPROM_Write(CharArr[iterator],CurrentPosition);
    11c6:	6c 2f       	mov	r22, r28
    11c8:	70 e0       	ldi	r23, 0x00	; 0
    11ca:	f6 d6       	rcall	.+3564   	; 0x1fb8 <EEPROM_Write>
			ErrRetVal = OperationFail;
			break;
		}
	}
	return ErrRetVal;
}
    11cc:	8f ef       	ldi	r24, 0xFF	; 255
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	08 95       	ret

000011d8 <KP_Init>:
* @param [in]  KP_CH   -  Keypad channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t KP_Init(uint8_t KP_CH)
{
    11d8:	ff 92       	push	r15
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
    11e2:	81 11       	cpse	r24, r1
    11e4:	4a c0       	rjmp	.+148    	; 0x127a <KP_Init+0xa2>
    11e6:	08 2f       	mov	r16, r24
    11e8:	10 e0       	ldi	r17, 0x00	; 0
    11ea:	15 c0       	rjmp	.+42     	; 0x1216 <KP_Init+0x3e>
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
    11ec:	9e 01       	movw	r18, r28
    11ee:	22 0f       	add	r18, r18
    11f0:	33 1f       	adc	r19, r19
    11f2:	f9 01       	movw	r30, r18
    11f4:	ec 0f       	add	r30, r28
    11f6:	fd 1f       	adc	r31, r29
    11f8:	ee 0f       	add	r30, r30
    11fa:	ff 1f       	adc	r31, r31
    11fc:	e3 56       	subi	r30, 0x63	; 99
    11fe:	fe 4f       	sbci	r31, 0xFE	; 254
    1200:	f5 80       	ldd	r15, Z+5	; 0x05
    1202:	f1 0e       	add	r15, r17
    1204:	c4 81       	ldd	r28, Z+4	; 0x04
    1206:	40 e0       	ldi	r20, 0x00	; 0
    1208:	6f 2d       	mov	r22, r15
    120a:	8c 2f       	mov	r24, r28
    120c:	82 d5       	rcall	.+2820   	; 0x1d12 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
    120e:	6f 2d       	mov	r22, r15
    1210:	8c 2f       	mov	r24, r28
    1212:	94 d6       	rcall	.+3368   	; 0x1f3c <DIO_EnablePinPullup>
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
   }
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
    1214:	1f 5f       	subi	r17, 0xFF	; 255
    1216:	c0 2f       	mov	r28, r16
    1218:	d0 e0       	ldi	r29, 0x00	; 0
    121a:	fe 01       	movw	r30, r28
    121c:	ee 0f       	add	r30, r30
    121e:	ff 1f       	adc	r31, r31
    1220:	ec 0f       	add	r30, r28
    1222:	fd 1f       	adc	r31, r29
    1224:	ee 0f       	add	r30, r30
    1226:	ff 1f       	adc	r31, r31
    1228:	e3 56       	subi	r30, 0x63	; 99
    122a:	fe 4f       	sbci	r31, 0xFE	; 254
    122c:	83 81       	ldd	r24, Z+3	; 0x03
    122e:	18 17       	cp	r17, r24
    1230:	e8 f2       	brcs	.-70     	; 0x11ec <KP_Init+0x14>
    1232:	10 e0       	ldi	r17, 0x00	; 0
    1234:	14 c0       	rjmp	.+40     	; 0x125e <KP_Init+0x86>
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
    1236:	fe 01       	movw	r30, r28
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	ec 0f       	add	r30, r28
    123e:	fd 1f       	adc	r31, r29
    1240:	ee 0f       	add	r30, r30
    1242:	ff 1f       	adc	r31, r31
    1244:	e3 56       	subi	r30, 0x63	; 99
    1246:	fe 4f       	sbci	r31, 0xFE	; 254
    1248:	02 81       	ldd	r16, Z+2	; 0x02
    124a:	01 0f       	add	r16, r17
    124c:	f1 80       	ldd	r15, Z+1	; 0x01
    124e:	40 e0       	ldi	r20, 0x00	; 0
    1250:	60 2f       	mov	r22, r16
    1252:	8f 2d       	mov	r24, r15
    1254:	5e d5       	rcall	.+2748   	; 0x1d12 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
    1256:	60 2f       	mov	r22, r16
    1258:	8f 2d       	mov	r24, r15
    125a:	70 d6       	rcall	.+3296   	; 0x1f3c <DIO_EnablePinPullup>
    125c:	1f 5f       	subi	r17, 0xFF	; 255
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
    125e:	fe 01       	movw	r30, r28
    1260:	ee 0f       	add	r30, r30
    1262:	ff 1f       	adc	r31, r31
    1264:	ec 0f       	add	r30, r28
    1266:	fd 1f       	adc	r31, r29
    1268:	ee 0f       	add	r30, r30
    126a:	ff 1f       	adc	r31, r31
    126c:	e3 56       	subi	r30, 0x63	; 99
    126e:	fe 4f       	sbci	r31, 0xFE	; 254
    1270:	80 81       	ld	r24, Z
    1272:	18 17       	cp	r17, r24
    1274:	00 f3       	brcs	.-64     	; 0x1236 <KP_Init+0x5e>
    1276:	80 e0       	ldi	r24, 0x00	; 0
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
      }
      KP_ErrorState = ERROR_OK;
    1278:	01 c0       	rjmp	.+2      	; 0x127c <KP_Init+0xa4>
    127a:	82 ee       	ldi	r24, 0xE2	; 226
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    127c:	df 91       	pop	r29
      KP_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return KP_ErrorState;
}
    127e:	cf 91       	pop	r28
    1280:	1f 91       	pop	r17
    1282:	0f 91       	pop	r16
    1284:	ff 90       	pop	r15
    1286:	08 95       	ret

00001288 <KP_GetPressedValue>:
    1288:	5f 92       	push	r5
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t KP_GetPressedValue(uint8_t KP_CH, uint32_t * const Data)
{
    128a:	6f 92       	push	r6
    128c:	7f 92       	push	r7
    128e:	8f 92       	push	r8
    1290:	9f 92       	push	r9
    1292:	af 92       	push	r10
    1294:	bf 92       	push	r11
    1296:	cf 92       	push	r12
    1298:	df 92       	push	r13
    129a:	ef 92       	push	r14
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	1f 92       	push	r1
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
    12ac:	61 15       	cp	r22, r1
    12ae:	71 05       	cpc	r23, r1
    12b0:	09 f4       	brne	.+2      	; 0x12b4 <KP_GetPressedValue+0x2c>
    12b2:	82 c0       	rjmp	.+260    	; 0x13b8 <KP_GetPressedValue+0x130>
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
   }
   else if(KP_INVALID_CH <= KP_CH)
    12b4:	81 11       	cpse	r24, r1
    12b6:	82 c0       	rjmp	.+260    	; 0x13bc <KP_GetPressedValue+0x134>
    12b8:	6b 01       	movw	r12, r22
    12ba:	e8 2e       	mov	r14, r24
    12bc:	61 2c       	mov	r6, r1
    12be:	81 2c       	mov	r8, r1
    12c0:	91 2c       	mov	r9, r1
    12c2:	54 01       	movw	r10, r8
    12c4:	63 c0       	rjmp	.+198    	; 0x138c <KP_GetPressedValue+0x104>
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
      {
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
    12c6:	f8 01       	movw	r30, r16
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	e0 0f       	add	r30, r16
    12ce:	f1 1f       	adc	r31, r17
    12d0:	ee 0f       	add	r30, r30
    12d2:	ff 1f       	adc	r31, r31
    12d4:	e3 56       	subi	r30, 0x63	; 99
    12d6:	fe 4f       	sbci	r31, 0xFE	; 254
    12d8:	75 80       	ldd	r7, Z+5	; 0x05
    12da:	76 0c       	add	r7, r6
    12dc:	54 80       	ldd	r5, Z+4	; 0x04
    12de:	41 e0       	ldi	r20, 0x01	; 1
    12e0:	67 2d       	mov	r22, r7
    12e2:	85 2d       	mov	r24, r5
    12e4:	16 d5       	rcall	.+2604   	; 0x1d12 <DIO_SetPinDirection>
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
    12e6:	40 e0       	ldi	r20, 0x00	; 0
    12e8:	67 2d       	mov	r22, r7
    12ea:	85 2d       	mov	r24, r5
    12ec:	7b d5       	rcall	.+2806   	; 0x1de4 <DIO_WritePin>
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
    12ee:	f1 2c       	mov	r15, r1
    12f0:	38 c0       	rjmp	.+112    	; 0x1362 <KP_GetPressedValue+0xda>
         {
            /* read row value */
            DIO_ReadPin(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_RowCounter), &u8_KeyState);
    12f2:	f8 01       	movw	r30, r16
    12f4:	ee 0f       	add	r30, r30
    12f6:	ff 1f       	adc	r31, r31
    12f8:	e0 0f       	add	r30, r16
    12fa:	f1 1f       	adc	r31, r17
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	e3 56       	subi	r30, 0x63	; 99
    1302:	fe 4f       	sbci	r31, 0xFE	; 254
    1304:	62 81       	ldd	r22, Z+2	; 0x02
    1306:	6f 0d       	add	r22, r15
    1308:	ae 01       	movw	r20, r28
    130a:	4f 5f       	subi	r20, 0xFF	; 255
    130c:	5f 4f       	sbci	r21, 0xFF	; 255
    130e:	81 81       	ldd	r24, Z+1	; 0x01
    1310:	d2 d5       	rcall	.+2980   	; 0x1eb6 <DIO_ReadPin>
            /* check if row is pressed */
            if(u8_KeyState == PRESSED)
    1312:	89 81       	ldd	r24, Y+1	; 0x01
    1314:	81 11       	cpse	r24, r1
    1316:	24 c0       	rjmp	.+72     	; 0x1360 <KP_GetPressedValue+0xd8>
            {
               /* Check for multipressed buttons. */
               if(u32_NewState > 0)
    1318:	81 14       	cp	r8, r1
    131a:	91 04       	cpc	r9, r1
    131c:	a1 04       	cpc	r10, r1
    131e:	b1 04       	cpc	r11, r1
    1320:	11 f0       	breq	.+4      	; 0x1326 <KP_GetPressedValue+0x9e>
               {
                  u32_NewState |= 1;
    1322:	68 94       	set
    1324:	80 f8       	bld	r8, 0
               }
               switch(KP_CH)
    1326:	e1 10       	cpse	r14, r1
    1328:	1b c0       	rjmp	.+54     	; 0x1360 <KP_GetPressedValue+0xd8>
               {
                  #ifdef KP_CH_0
                  case KP_CH_0:
                     u32_NewState |= (1<<KP_Ch0Map[u8_RowCounter][u8_ColCounter]);
    132a:	8f 2d       	mov	r24, r15
    132c:	90 e0       	ldi	r25, 0x00	; 0
    132e:	fc 01       	movw	r30, r24
    1330:	ee 0f       	add	r30, r30
    1332:	ff 1f       	adc	r31, r31
    1334:	e8 0f       	add	r30, r24
    1336:	f9 1f       	adc	r31, r25
    1338:	ef 56       	subi	r30, 0x6F	; 111
    133a:	fe 4f       	sbci	r31, 0xFE	; 254
    133c:	e6 0d       	add	r30, r6
    133e:	f1 1d       	adc	r31, r1
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	00 80       	ld	r0, Z
    1346:	02 c0       	rjmp	.+4      	; 0x134c <KP_GetPressedValue+0xc4>
    1348:	88 0f       	add	r24, r24
    134a:	99 1f       	adc	r25, r25
    134c:	0a 94       	dec	r0
    134e:	e2 f7       	brpl	.-8      	; 0x1348 <KP_GetPressedValue+0xc0>
    1350:	09 2e       	mov	r0, r25
    1352:	00 0c       	add	r0, r0
    1354:	aa 0b       	sbc	r26, r26
    1356:	bb 0b       	sbc	r27, r27
    1358:	88 2a       	or	r8, r24
    135a:	99 2a       	or	r9, r25
    135c:	aa 2a       	or	r10, r26
    135e:	bb 2a       	or	r11, r27
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
    1360:	f3 94       	inc	r15
    1362:	f8 01       	movw	r30, r16
    1364:	ee 0f       	add	r30, r30
    1366:	ff 1f       	adc	r31, r31
    1368:	e0 0f       	add	r30, r16
    136a:	f1 1f       	adc	r31, r17
    136c:	ee 0f       	add	r30, r30
    136e:	ff 1f       	adc	r31, r31
    1370:	e3 56       	subi	r30, 0x63	; 99
    1372:	fe 4f       	sbci	r31, 0xFE	; 254
    1374:	80 81       	ld	r24, Z
    1376:	f8 16       	cp	r15, r24
    1378:	08 f4       	brcc	.+2      	; 0x137c <KP_GetPressedValue+0xf4>
    137a:	bb cf       	rjmp	.-138    	; 0x12f2 <KP_GetPressedValue+0x6a>
               }
            }
         }
         
         /* return column direction to input and resistor to pulled up. */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
    137c:	40 e0       	ldi	r20, 0x00	; 0
    137e:	67 2d       	mov	r22, r7
    1380:	85 2d       	mov	r24, r5
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
    1382:	c7 d4       	rcall	.+2446   	; 0x1d12 <DIO_SetPinDirection>
    1384:	67 2d       	mov	r22, r7
    1386:	85 2d       	mov	r24, r5
    1388:	d9 d5       	rcall	.+2994   	; 0x1f3c <DIO_EnablePinPullup>
   {
      uint32_t u32_NewState = 0x00;
      uint8_t u8_KeyState;
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
    138a:	63 94       	inc	r6
    138c:	0e 2d       	mov	r16, r14
    138e:	10 e0       	ldi	r17, 0x00	; 0
    1390:	f8 01       	movw	r30, r16
    1392:	ee 0f       	add	r30, r30
    1394:	ff 1f       	adc	r31, r31
    1396:	e0 0f       	add	r30, r16
    1398:	f1 1f       	adc	r31, r17
    139a:	ee 0f       	add	r30, r30
    139c:	ff 1f       	adc	r31, r31
    139e:	e3 56       	subi	r30, 0x63	; 99
    13a0:	fe 4f       	sbci	r31, 0xFE	; 254
    13a2:	83 81       	ldd	r24, Z+3	; 0x03
    13a4:	68 16       	cp	r6, r24
    13a6:	08 f4       	brcc	.+2      	; 0x13aa <KP_GetPressedValue+0x122>
    13a8:	8e cf       	rjmp	.-228    	; 0x12c6 <KP_GetPressedValue+0x3e>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
      }
      
      /* Return the keys data. */
      *Data = u32_NewState;
    13aa:	f6 01       	movw	r30, r12
    13ac:	80 82       	st	Z, r8
    13ae:	91 82       	std	Z+1, r9	; 0x01
    13b0:	a2 82       	std	Z+2, r10	; 0x02
    13b2:	b3 82       	std	Z+3, r11	; 0x03
      KP_ErrorState = ERROR_OK;
    13b4:	80 e0       	ldi	r24, 0x00	; 0
    13b6:	03 c0       	rjmp	.+6      	; 0x13be <KP_GetPressedValue+0x136>
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
    13b8:	81 ee       	ldi	r24, 0xE1	; 225
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <KP_GetPressedValue+0x136>
   }
   else if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    13bc:	82 ee       	ldi	r24, 0xE2	; 226
      
   }
   
   /* return Error state. */
   return KP_ErrorState;
    13be:	0f 90       	pop	r0
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	df 90       	pop	r13
    13ce:	cf 90       	pop	r12
    13d0:	bf 90       	pop	r11
    13d2:	af 90       	pop	r10
    13d4:	9f 90       	pop	r9
    13d6:	8f 90       	pop	r8
    13d8:	7f 90       	pop	r7
    13da:	6f 90       	pop	r6
    13dc:	5f 90       	pop	r5
    13de:	08 95       	ret

000013e0 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    13ec:	81 11       	cpse	r24, r1
    13ee:	49 c0       	rjmp	.+146    	; 0x1482 <LED_Init+0xa2>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    13f0:	c8 2f       	mov	r28, r24
    13f2:	d0 e0       	ldi	r29, 0x00	; 0
    13f4:	fe 01       	movw	r30, r28
    13f6:	ed 5e       	subi	r30, 0xED	; 237
    13f8:	f9 4f       	sbci	r31, 0xF9	; 249
    13fa:	80 81       	ld	r24, Z
    13fc:	81 30       	cpi	r24, 0x01	; 1
    13fe:	09 f4       	brne	.+2      	; 0x1402 <LED_Init+0x22>
    1400:	42 c0       	rjmp	.+132    	; 0x1486 <LED_Init+0xa6>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      /* Normal LED Config */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1402:	fe 01       	movw	r30, r28
    1404:	ee 0f       	add	r30, r30
    1406:	ff 1f       	adc	r31, r31
    1408:	ee 0f       	add	r30, r30
    140a:	ff 1f       	adc	r31, r31
    140c:	ed 55       	subi	r30, 0x5D	; 93
    140e:	fe 4f       	sbci	r31, 0xFE	; 254
    1410:	82 81       	ldd	r24, Z+2	; 0x02
    1412:	81 11       	cpse	r24, r1
    1414:	13 c0       	rjmp	.+38     	; 0x143c <LED_Init+0x5c>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1416:	fe 01       	movw	r30, r28
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	ee 0f       	add	r30, r30
    141e:	ff 1f       	adc	r31, r31
    1420:	ed 55       	subi	r30, 0x5D	; 93
    1422:	fe 4f       	sbci	r31, 0xFE	; 254
    1424:	61 81       	ldd	r22, Z+1	; 0x01
    1426:	41 e0       	ldi	r20, 0x01	; 1
    1428:	80 81       	ld	r24, Z
    142a:	73 d4       	rcall	.+2278   	; 0x1d12 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    142c:	81 11       	cpse	r24, r1
    142e:	2d c0       	rjmp	.+90     	; 0x148a <LED_Init+0xaa>
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    1430:	cd 5e       	subi	r28, 0xED	; 237
    1432:	d9 4f       	sbci	r29, 0xF9	; 249
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1438:	80 e0       	ldi	r24, 0x00	; 0
    143a:	2c c0       	rjmp	.+88     	; 0x1494 <LED_Init+0xb4>
         }
      }
      /* PWM LED Config */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    143c:	81 30       	cpi	r24, 0x01	; 1
    143e:	39 f5       	brne	.+78     	; 0x148e <LED_Init+0xae>
      {
         ERROR_STATE_t ErrorState;
         
         /* configure LED pin */
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    1440:	ce 01       	movw	r24, r28
    1442:	88 0f       	add	r24, r24
    1444:	99 1f       	adc	r25, r25
    1446:	88 0f       	add	r24, r24
    1448:	99 1f       	adc	r25, r25
    144a:	9c 01       	movw	r18, r24
    144c:	2d 55       	subi	r18, 0x5D	; 93
    144e:	3e 4f       	sbci	r19, 0xFE	; 254
    1450:	79 01       	movw	r14, r18
    1452:	f9 01       	movw	r30, r18
    1454:	03 81       	ldd	r16, Z+3	; 0x03
    1456:	80 2f       	mov	r24, r16
    1458:	c5 d5       	rcall	.+2954   	; 0x1fe4 <PWM_Init>
    145a:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    145c:	41 e0       	ldi	r20, 0x01	; 1
    145e:	f7 01       	movw	r30, r14
    1460:	61 81       	ldd	r22, Z+1	; 0x01
    1462:	80 81       	ld	r24, Z
    1464:	56 d4       	rcall	.+2220   	; 0x1d12 <DIO_SetPinDirection>
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    1466:	18 2b       	or	r17, r24
    1468:	80 2f       	mov	r24, r16
    146a:	ec d5       	rcall	.+3032   	; 0x2044 <PWM_Start>
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    146c:	18 2b       	or	r17, r24
    146e:	80 2f       	mov	r24, r16
    1470:	f5 d5       	rcall	.+3050   	; 0x205c <PWM_Connect>
    1472:	81 2b       	or	r24, r17
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
    1474:	71 f4       	brne	.+28     	; 0x1492 <LED_Init+0xb2>
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    1476:	cd 5e       	subi	r28, 0xED	; 237
    1478:	d9 4f       	sbci	r29, 0xF9	; 249
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    147e:	80 e0       	ldi	r24, 0x00	; 0
    1480:	09 c0       	rjmp	.+18     	; 0x1494 <LED_Init+0xb4>
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1482:	81 ec       	ldi	r24, 0xC1	; 193
    1484:	07 c0       	rjmp	.+14     	; 0x1494 <LED_Init+0xb4>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      /* Set init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    1486:	82 ec       	ldi	r24, 0xC2	; 194
    1488:	05 c0       	rjmp	.+10     	; 0x1494 <LED_Init+0xb4>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    148a:	81 e0       	ldi	r24, 0x01	; 1
    148c:	03 c0       	rjmp	.+6      	; 0x1494 <LED_Init+0xb4>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	01 c0       	rjmp	.+2      	; 0x1494 <LED_Init+0xb4>
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1492:	81 e0       	ldi	r24, 0x01	; 1
      }   
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1494:	df 91       	pop	r29
    1496:	cf 91       	pop	r28
    1498:	1f 91       	pop	r17
    149a:	0f 91       	pop	r16
    149c:	ff 90       	pop	r15
    149e:	ef 90       	pop	r14
    14a0:	08 95       	ret

000014a2 <LED_Off>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    14a2:	81 11       	cpse	r24, r1
    14a4:	30 c0       	rjmp	.+96     	; 0x1506 <LED_Off+0x64>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    14a6:	90 e0       	ldi	r25, 0x00	; 0
    14a8:	fc 01       	movw	r30, r24
    14aa:	ed 5e       	subi	r30, 0xED	; 237
    14ac:	f9 4f       	sbci	r31, 0xF9	; 249
    14ae:	20 81       	ld	r18, Z
    14b0:	21 30       	cpi	r18, 0x01	; 1
    14b2:	59 f5       	brne	.+86     	; 0x150a <LED_Off+0x68>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      /* Normal LED */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    14b4:	fc 01       	movw	r30, r24
    14b6:	ee 0f       	add	r30, r30
    14b8:	ff 1f       	adc	r31, r31
    14ba:	ee 0f       	add	r30, r30
    14bc:	ff 1f       	adc	r31, r31
    14be:	ed 55       	subi	r30, 0x5D	; 93
    14c0:	fe 4f       	sbci	r31, 0xFE	; 254
    14c2:	22 81       	ldd	r18, Z+2	; 0x02
    14c4:	21 11       	cpse	r18, r1
    14c6:	0f c0       	rjmp	.+30     	; 0x14e6 <LED_Off+0x44>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    14c8:	88 0f       	add	r24, r24
    14ca:	99 1f       	adc	r25, r25
    14cc:	88 0f       	add	r24, r24
    14ce:	99 1f       	adc	r25, r25
    14d0:	fc 01       	movw	r30, r24
    14d2:	ed 55       	subi	r30, 0x5D	; 93
    14d4:	fe 4f       	sbci	r31, 0xFE	; 254
    14d6:	61 81       	ldd	r22, Z+1	; 0x01
    14d8:	40 e0       	ldi	r20, 0x00	; 0
    14da:	80 81       	ld	r24, Z
    14dc:	83 d4       	rcall	.+2310   	; 0x1de4 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    14de:	88 23       	and	r24, r24
    14e0:	b1 f0       	breq	.+44     	; 0x150e <LED_Off+0x6c>
         {
            LED_ErrorState = ERROR_NOK;
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	08 95       	ret
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      /* PWM LED */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    14e6:	21 30       	cpi	r18, 0x01	; 1
    14e8:	a1 f4       	brne	.+40     	; 0x1512 <LED_Off+0x70>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to Minimum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MIN_DUTY);
    14ea:	88 0f       	add	r24, r24
    14ec:	99 1f       	adc	r25, r25
    14ee:	88 0f       	add	r24, r24
    14f0:	99 1f       	adc	r25, r25
    14f2:	fc 01       	movw	r30, r24
    14f4:	ed 55       	subi	r30, 0x5D	; 93
    14f6:	fe 4f       	sbci	r31, 0xFE	; 254
    14f8:	60 e0       	ldi	r22, 0x00	; 0
    14fa:	83 81       	ldd	r24, Z+3	; 0x03
    14fc:	c0 d5       	rcall	.+2944   	; 0x207e <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    14fe:	88 23       	and	r24, r24
    1500:	51 f0       	breq	.+20     	; 0x1516 <LED_Off+0x74>
         {
            LED_ErrorState = ERROR_NOK;
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1506:	81 ec       	ldi	r24, 0xC1	; 193
    1508:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    150a:	83 ec       	ldi	r24, 0xC3	; 195
    150c:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1516:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1518:	08 95       	ret

0000151a <LED_On>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    151a:	81 11       	cpse	r24, r1
    151c:	30 c0       	rjmp	.+96     	; 0x157e <LED_On+0x64>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	fc 01       	movw	r30, r24
    1522:	ed 5e       	subi	r30, 0xED	; 237
    1524:	f9 4f       	sbci	r31, 0xF9	; 249
    1526:	20 81       	ld	r18, Z
    1528:	21 30       	cpi	r18, 0x01	; 1
    152a:	59 f5       	brne	.+86     	; 0x1582 <LED_On+0x68>
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    152c:	fc 01       	movw	r30, r24
    152e:	ee 0f       	add	r30, r30
    1530:	ff 1f       	adc	r31, r31
    1532:	ee 0f       	add	r30, r30
    1534:	ff 1f       	adc	r31, r31
    1536:	ed 55       	subi	r30, 0x5D	; 93
    1538:	fe 4f       	sbci	r31, 0xFE	; 254
    153a:	22 81       	ldd	r18, Z+2	; 0x02
    153c:	21 11       	cpse	r18, r1
    153e:	0f c0       	rjmp	.+30     	; 0x155e <LED_On+0x44>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to high */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    1540:	88 0f       	add	r24, r24
    1542:	99 1f       	adc	r25, r25
    1544:	88 0f       	add	r24, r24
    1546:	99 1f       	adc	r25, r25
    1548:	fc 01       	movw	r30, r24
    154a:	ed 55       	subi	r30, 0x5D	; 93
    154c:	fe 4f       	sbci	r31, 0xFE	; 254
    154e:	61 81       	ldd	r22, Z+1	; 0x01
    1550:	41 e0       	ldi	r20, 0x01	; 1
    1552:	80 81       	ld	r24, Z
    1554:	47 d4       	rcall	.+2190   	; 0x1de4 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    1556:	88 23       	and	r24, r24
    1558:	b1 f0       	breq	.+44     	; 0x1586 <LED_On+0x6c>
         {
            LED_ErrorState = ERROR_NOK;
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    155e:	21 30       	cpi	r18, 0x01	; 1
    1560:	a1 f4       	brne	.+40     	; 0x158a <LED_On+0x70>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to maximum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MAX_DUTY);
    1562:	88 0f       	add	r24, r24
    1564:	99 1f       	adc	r25, r25
    1566:	88 0f       	add	r24, r24
    1568:	99 1f       	adc	r25, r25
    156a:	fc 01       	movw	r30, r24
    156c:	ed 55       	subi	r30, 0x5D	; 93
    156e:	fe 4f       	sbci	r31, 0xFE	; 254
    1570:	64 e6       	ldi	r22, 0x64	; 100
    1572:	83 81       	ldd	r24, Z+3	; 0x03
    1574:	84 d5       	rcall	.+2824   	; 0x207e <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    1576:	88 23       	and	r24, r24
    1578:	51 f0       	breq	.+20     	; 0x158e <LED_On+0x74>
         {
            LED_ErrorState = ERROR_NOK;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    157e:	81 ec       	ldi	r24, 0xC1	; 193
    1580:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1582:	83 ec       	ldi	r24, 0xC3	; 195
    1584:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1586:	80 e0       	ldi	r24, 0x00	; 0
    1588:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    158e:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1590:	08 95       	ret

00001592 <LED_Dim>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1592:	81 11       	cpse	r24, r1
    1594:	20 c0       	rjmp	.+64     	; 0x15d6 <LED_Dim+0x44>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	fc 01       	movw	r30, r24
    159a:	ed 5e       	subi	r30, 0xED	; 237
    159c:	f9 4f       	sbci	r31, 0xF9	; 249
    159e:	20 81       	ld	r18, Z
    15a0:	21 30       	cpi	r18, 0x01	; 1
    15a2:	d9 f4       	brne	.+54     	; 0x15da <LED_Dim+0x48>
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    15a4:	fc 01       	movw	r30, r24
    15a6:	ee 0f       	add	r30, r30
    15a8:	ff 1f       	adc	r31, r31
    15aa:	ee 0f       	add	r30, r30
    15ac:	ff 1f       	adc	r31, r31
    15ae:	ed 55       	subi	r30, 0x5D	; 93
    15b0:	fe 4f       	sbci	r31, 0xFE	; 254
    15b2:	22 81       	ldd	r18, Z+2	; 0x02
    15b4:	22 23       	and	r18, r18
    15b6:	99 f0       	breq	.+38     	; 0x15de <LED_Dim+0x4c>
   {
      LED_ErrorState = ERROR_NOK;
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
    15b8:	65 36       	cpi	r22, 0x65	; 101
    15ba:	98 f4       	brcc	.+38     	; 0x15e2 <LED_Dim+0x50>
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      /* set LED duty cycle */
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	fc 01       	movw	r30, r24
    15c6:	ed 55       	subi	r30, 0x5D	; 93
    15c8:	fe 4f       	sbci	r31, 0xFE	; 254
    15ca:	83 81       	ldd	r24, Z+3	; 0x03
    15cc:	58 d5       	rcall	.+2736   	; 0x207e <PWM_SetDuty>
        
      /* make sure PWM function was successful */ 
      if(ERROR_OK != PWM_ErrorState)
    15ce:	88 23       	and	r24, r24
    15d0:	51 f0       	breq	.+20     	; 0x15e6 <LED_Dim+0x54>
      {
         LED_ErrorState = ERROR_NOK;
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    15d6:	81 ec       	ldi	r24, 0xC1	; 193
    15d8:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    15da:	83 ec       	ldi	r24, 0xC3	; 195
    15dc:	08 95       	ret
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    15de:	81 e0       	ldi	r24, 0x01	; 1
    15e0:	08 95       	ret
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    15e6:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    15e8:	08 95       	ret

000015ea <StringCompare>:
	uint16_t u16_Counter=ZERO;
	for(u16_Counter=ZERO;source[u16_Counter]!=END_OF_STRING;u16_Counter++)
	{
		destination[u16_Counter]=source[u16_Counter];
	}
}
    15ea:	dc 01       	movw	r26, r24
    15ec:	40 e0       	ldi	r20, 0x00	; 0
    15ee:	0a c0       	rjmp	.+20     	; 0x1604 <StringCompare+0x1a>
    15f0:	fb 01       	movw	r30, r22
    15f2:	e2 0f       	add	r30, r18
    15f4:	f3 1f       	adc	r31, r19
    15f6:	20 81       	ld	r18, Z
    15f8:	92 17       	cp	r25, r18
    15fa:	19 f0       	breq	.+6      	; 0x1602 <StringCompare+0x18>
    15fc:	4f 5f       	subi	r20, 0xFF	; 255
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	0e c0       	rjmp	.+28     	; 0x161e <StringCompare+0x34>
    1602:	4f 5f       	subi	r20, 0xFF	; 255
    1604:	24 2f       	mov	r18, r20
    1606:	30 e0       	ldi	r19, 0x00	; 0
    1608:	fd 01       	movw	r30, r26
    160a:	e2 0f       	add	r30, r18
    160c:	f3 1f       	adc	r31, r19
    160e:	90 81       	ld	r25, Z
    1610:	99 23       	and	r25, r25
    1612:	21 f0       	breq	.+8      	; 0x161c <StringCompare+0x32>
    1614:	9d 30       	cpi	r25, 0x0D	; 13
    1616:	61 f7       	brne	.-40     	; 0x15f0 <StringCompare+0x6>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	01 c0       	rjmp	.+2      	; 0x161e <StringCompare+0x34>
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	fb 01       	movw	r30, r22
    1620:	e4 0f       	add	r30, r20
    1622:	f1 1d       	adc	r31, r1
    1624:	90 81       	ld	r25, Z
    1626:	91 11       	cpse	r25, r1
    1628:	80 e0       	ldi	r24, 0x00	; 0
    162a:	08 95       	ret

0000162c <STR_Length>:
    162c:	fc 01       	movw	r30, r24
    162e:	db 01       	movw	r26, r22
    1630:	11 96       	adiw	r26, 0x01	; 1
    1632:	1c 92       	st	X, r1
    1634:	1e 92       	st	-X, r1
    1636:	09 c0       	rjmp	.+18     	; 0x164a <STR_Length+0x1e>
    1638:	2d 91       	ld	r18, X+
    163a:	3c 91       	ld	r19, X
    163c:	11 97       	sbiw	r26, 0x01	; 1
    163e:	2f 5f       	subi	r18, 0xFF	; 255
    1640:	3f 4f       	sbci	r19, 0xFF	; 255
    1642:	11 96       	adiw	r26, 0x01	; 1
    1644:	3c 93       	st	X, r19
    1646:	2e 93       	st	-X, r18
    1648:	31 96       	adiw	r30, 0x01	; 1
    164a:	80 81       	ld	r24, Z
    164c:	81 11       	cpse	r24, r1
    164e:	f4 cf       	rjmp	.-24     	; 0x1638 <STR_Length+0xc>
    1650:	08 95       	ret

00001652 <STR_StringConcatenate>:
    1652:	ef 92       	push	r14
    1654:	ff 92       	push	r15
    1656:	0f 93       	push	r16
    1658:	1f 93       	push	r17
    165a:	cf 93       	push	r28
    165c:	df 93       	push	r29
    165e:	00 d0       	rcall	.+0      	; 0x1660 <STR_StringConcatenate+0xe>
    1660:	cd b7       	in	r28, 0x3d	; 61
    1662:	de b7       	in	r29, 0x3e	; 62
    1664:	8c 01       	movw	r16, r24
    1666:	7b 01       	movw	r14, r22
    1668:	1a 82       	std	Y+2, r1	; 0x02
    166a:	19 82       	std	Y+1, r1	; 0x01
    166c:	be 01       	movw	r22, r28
    166e:	6f 5f       	subi	r22, 0xFF	; 255
    1670:	7f 4f       	sbci	r23, 0xFF	; 255
    1672:	dc df       	rcall	.-72     	; 0x162c <STR_Length>
    1674:	20 e0       	ldi	r18, 0x00	; 0
    1676:	0a c0       	rjmp	.+20     	; 0x168c <STR_StringConcatenate+0x3a>
    1678:	89 81       	ldd	r24, Y+1	; 0x01
    167a:	9a 81       	ldd	r25, Y+2	; 0x02
    167c:	f8 01       	movw	r30, r16
    167e:	e8 0f       	add	r30, r24
    1680:	f9 1f       	adc	r31, r25
    1682:	30 83       	st	Z, r19
    1684:	2f 5f       	subi	r18, 0xFF	; 255
    1686:	01 96       	adiw	r24, 0x01	; 1
    1688:	9a 83       	std	Y+2, r25	; 0x02
    168a:	89 83       	std	Y+1, r24	; 0x01
    168c:	f7 01       	movw	r30, r14
    168e:	e2 0f       	add	r30, r18
    1690:	f1 1d       	adc	r31, r1
    1692:	30 81       	ld	r19, Z
    1694:	31 11       	cpse	r19, r1
    1696:	f0 cf       	rjmp	.-32     	; 0x1678 <STR_StringConcatenate+0x26>
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	1f 91       	pop	r17
    16a2:	0f 91       	pop	r16
    16a4:	ff 90       	pop	r15
    16a6:	ef 90       	pop	r14
    16a8:	08 95       	ret

000016aa <CRC_16_Calc>:
https://rndtool.info/CRC-step-by-step-calculator/
https://www.lammertbies.nl/comm/info/crc-calculation
https://www.youtube.com/watch?v=izG7qT0EpBw
*/
uint8_t CRC_16_Calc (ptr_uint8_t STRING)
{
    16aa:	cf 92       	push	r12
    16ac:	df 92       	push	r13
    16ae:	ef 92       	push	r14
    16b0:	ff 92       	push	r15
    16b2:	0f 93       	push	r16
    16b4:	1f 93       	push	r17
    16b6:	cf 93       	push	r28
    16b8:	df 93       	push	r29
    16ba:	cd b7       	in	r28, 0x3d	; 61
    16bc:	de b7       	in	r29, 0x3e	; 62
    16be:	c5 50       	subi	r28, 0x05	; 5
    16c0:	d1 40       	sbci	r29, 0x01	; 1
    16c2:	0f b6       	in	r0, 0x3f	; 63
    16c4:	f8 94       	cli
    16c6:	de bf       	out	0x3e, r29	; 62
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	cd bf       	out	0x3d, r28	; 61
    16cc:	8c 01       	movw	r16, r24
	/*change array of character to array of bits*/
	/*initialize the array of bits*/
uint8_t BitArr[255] = {0};
    16ce:	fe 01       	movw	r30, r28
    16d0:	31 96       	adiw	r30, 0x01	; 1
    16d2:	8f ef       	ldi	r24, 0xFF	; 255
    16d4:	df 01       	movw	r26, r30
    16d6:	1d 92       	st	X+, r1
    16d8:	8a 95       	dec	r24
    16da:	e9 f7       	brne	.-6      	; 0x16d6 <CRC_16_Calc+0x2c>
/*the value of the used polynomial for CRC_16*/
const uint32_t polynomial = 0b00000000000000011000000000000101;
/*variable that holds the value to be XORED and SHIFTED*/
uint32_t volatile Window_16_Element =0;
    16dc:	c0 50       	subi	r28, 0x00	; 0
    16de:	df 4f       	sbci	r29, 0xFF	; 255
    16e0:	18 82       	st	Y, r1
    16e2:	19 82       	std	Y+1, r1	; 0x01
    16e4:	1a 82       	std	Y+2, r1	; 0x02
    16e6:	1b 82       	std	Y+3, r1	; 0x03
    16e8:	c0 50       	subi	r28, 0x00	; 0
    16ea:	d1 40       	sbci	r29, 0x01	; 1
/*initialize the variable that holds the number of characters to which CRC is calculated*/
/*number of characters in the inserted string*/
uint16_t StrLength =0;
    16ec:	cc 5f       	subi	r28, 0xFC	; 252
    16ee:	de 4f       	sbci	r29, 0xFE	; 254
    16f0:	19 82       	std	Y+1, r1	; 0x01
    16f2:	18 82       	st	Y, r1
    16f4:	c4 50       	subi	r28, 0x04	; 4
    16f6:	d1 40       	sbci	r29, 0x01	; 1
/*initialize the variable that holds the number of bits in the inserted string*/
uint8_t BitArr_Size = 0;
/*using STR_Length() function to calculate Number of characters in the inserted String*/
STR_Length(STRING, &StrLength);
    16f8:	be 01       	movw	r22, r28
    16fa:	6c 5f       	subi	r22, 0xFC	; 252
    16fc:	7e 4f       	sbci	r23, 0xFE	; 254
    16fe:	c8 01       	movw	r24, r16
    1700:	95 df       	rcall	.-214    	; 0x162c <STR_Length>
uint8_t iterator_of_BitArr = 0;
/*initializing the iterator for the array of the inserted Characters in the string*/
uint8_t iterator_of_characters = 0;
/*assigning the bits of the character in the passed string to the array of bits*/
/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1702:	90 e0       	ldi	r25, 0x00	; 0
/*initialize the variable that holds the number of bits in the inserted string*/
uint8_t BitArr_Size = 0;
/*using STR_Length() function to calculate Number of characters in the inserted String*/
STR_Length(STRING, &StrLength);
/*initializing the iterator for the array of bits of the inserted Character string*/
uint8_t iterator_of_BitArr = 0;
    1704:	50 e0       	ldi	r21, 0x00	; 0
/*initializing the iterator for the array of the inserted Characters in the string*/
uint8_t iterator_of_characters = 0;
/*assigning the bits of the character in the passed string to the array of bits*/
/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1706:	89 c0       	rjmp	.+274    	; 0x181a <CRC_16_Calc+0x170>
{
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_7);
    1708:	f8 01       	movw	r30, r16
    170a:	e6 0f       	add	r30, r22
    170c:	f7 1f       	adc	r31, r23
    170e:	80 81       	ld	r24, Z
    1710:	28 2f       	mov	r18, r24
    1712:	22 1f       	adc	r18, r18
    1714:	22 27       	eor	r18, r18
    1716:	22 1f       	adc	r18, r18
    1718:	e1 e0       	ldi	r30, 0x01	; 1
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	ec 0f       	add	r30, r28
    171e:	fd 1f       	adc	r31, r29
    1720:	e5 0f       	add	r30, r21
    1722:	f1 1d       	adc	r31, r1
    1724:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    1726:	41 e0       	ldi	r20, 0x01	; 1
    1728:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_6);
    172a:	28 2f       	mov	r18, r24
    172c:	20 74       	andi	r18, 0x40	; 64
    172e:	30 e0       	ldi	r19, 0x00	; 0
    1730:	02 2e       	mov	r0, r18
    1732:	23 2f       	mov	r18, r19
    1734:	00 0c       	add	r0, r0
    1736:	22 1f       	adc	r18, r18
    1738:	33 0b       	sbc	r19, r19
    173a:	00 0c       	add	r0, r0
    173c:	22 1f       	adc	r18, r18
    173e:	33 1f       	adc	r19, r19
    1740:	e1 e0       	ldi	r30, 0x01	; 1
    1742:	f0 e0       	ldi	r31, 0x00	; 0
    1744:	ec 0f       	add	r30, r28
    1746:	fd 1f       	adc	r31, r29
    1748:	e4 0f       	add	r30, r20
    174a:	f1 1d       	adc	r31, r1
    174c:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    174e:	42 e0       	ldi	r20, 0x02	; 2
    1750:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_5);
    1752:	28 2f       	mov	r18, r24
    1754:	20 72       	andi	r18, 0x20	; 32
    1756:	30 e0       	ldi	r19, 0x00	; 0
    1758:	35 95       	asr	r19
    175a:	27 95       	ror	r18
    175c:	35 95       	asr	r19
    175e:	27 95       	ror	r18
    1760:	35 95       	asr	r19
    1762:	27 95       	ror	r18
    1764:	35 95       	asr	r19
    1766:	27 95       	ror	r18
    1768:	35 95       	asr	r19
    176a:	27 95       	ror	r18
    176c:	e1 e0       	ldi	r30, 0x01	; 1
    176e:	f0 e0       	ldi	r31, 0x00	; 0
    1770:	ec 0f       	add	r30, r28
    1772:	fd 1f       	adc	r31, r29
    1774:	e4 0f       	add	r30, r20
    1776:	f1 1d       	adc	r31, r1
    1778:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    177a:	43 e0       	ldi	r20, 0x03	; 3
    177c:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_4);
    177e:	28 2f       	mov	r18, r24
    1780:	20 71       	andi	r18, 0x10	; 16
    1782:	30 e0       	ldi	r19, 0x00	; 0
    1784:	35 95       	asr	r19
    1786:	27 95       	ror	r18
    1788:	35 95       	asr	r19
    178a:	27 95       	ror	r18
    178c:	35 95       	asr	r19
    178e:	27 95       	ror	r18
    1790:	35 95       	asr	r19
    1792:	27 95       	ror	r18
    1794:	e1 e0       	ldi	r30, 0x01	; 1
    1796:	f0 e0       	ldi	r31, 0x00	; 0
    1798:	ec 0f       	add	r30, r28
    179a:	fd 1f       	adc	r31, r29
    179c:	e4 0f       	add	r30, r20
    179e:	f1 1d       	adc	r31, r1
    17a0:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    17a2:	44 e0       	ldi	r20, 0x04	; 4
    17a4:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_3);
    17a6:	28 2f       	mov	r18, r24
    17a8:	28 70       	andi	r18, 0x08	; 8
    17aa:	30 e0       	ldi	r19, 0x00	; 0
    17ac:	35 95       	asr	r19
    17ae:	27 95       	ror	r18
    17b0:	35 95       	asr	r19
    17b2:	27 95       	ror	r18
    17b4:	35 95       	asr	r19
    17b6:	27 95       	ror	r18
    17b8:	e1 e0       	ldi	r30, 0x01	; 1
    17ba:	f0 e0       	ldi	r31, 0x00	; 0
    17bc:	ec 0f       	add	r30, r28
    17be:	fd 1f       	adc	r31, r29
    17c0:	e4 0f       	add	r30, r20
    17c2:	f1 1d       	adc	r31, r1
    17c4:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    17c6:	45 e0       	ldi	r20, 0x05	; 5
    17c8:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_2);
    17ca:	28 2f       	mov	r18, r24
    17cc:	24 70       	andi	r18, 0x04	; 4
    17ce:	30 e0       	ldi	r19, 0x00	; 0
    17d0:	35 95       	asr	r19
    17d2:	27 95       	ror	r18
    17d4:	35 95       	asr	r19
    17d6:	27 95       	ror	r18
    17d8:	e1 e0       	ldi	r30, 0x01	; 1
    17da:	f0 e0       	ldi	r31, 0x00	; 0
    17dc:	ec 0f       	add	r30, r28
    17de:	fd 1f       	adc	r31, r29
    17e0:	e4 0f       	add	r30, r20
    17e2:	f1 1d       	adc	r31, r1
    17e4:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    17e6:	46 e0       	ldi	r20, 0x06	; 6
    17e8:	45 0f       	add	r20, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_1);
    17ea:	28 2f       	mov	r18, r24
    17ec:	22 70       	andi	r18, 0x02	; 2
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	35 95       	asr	r19
    17f2:	27 95       	ror	r18
    17f4:	e1 e0       	ldi	r30, 0x01	; 1
    17f6:	f0 e0       	ldi	r31, 0x00	; 0
    17f8:	ec 0f       	add	r30, r28
    17fa:	fd 1f       	adc	r31, r29
    17fc:	e4 0f       	add	r30, r20
    17fe:	f1 1d       	adc	r31, r1
    1800:	20 83       	st	Z, r18
	iterator_of_BitArr++;
    1802:	27 e0       	ldi	r18, 0x07	; 7
    1804:	25 0f       	add	r18, r21
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_0);
    1806:	e1 e0       	ldi	r30, 0x01	; 1
    1808:	f0 e0       	ldi	r31, 0x00	; 0
    180a:	ec 0f       	add	r30, r28
    180c:	fd 1f       	adc	r31, r29
    180e:	e2 0f       	add	r30, r18
    1810:	f1 1d       	adc	r31, r1
    1812:	81 70       	andi	r24, 0x01	; 1
    1814:	80 83       	st	Z, r24
	iterator_of_BitArr++;
    1816:	58 5f       	subi	r21, 0xF8	; 248
uint8_t iterator_of_BitArr = 0;
/*initializing the iterator for the array of the inserted Characters in the string*/
uint8_t iterator_of_characters = 0;
/*assigning the bits of the character in the passed string to the array of bits*/
/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1818:	9f 5f       	subi	r25, 0xFF	; 255
    181a:	69 2f       	mov	r22, r25
    181c:	70 e0       	ldi	r23, 0x00	; 0
    181e:	cc 5f       	subi	r28, 0xFC	; 252
    1820:	de 4f       	sbci	r29, 0xFE	; 254
    1822:	28 81       	ld	r18, Y
    1824:	39 81       	ldd	r19, Y+1	; 0x01
    1826:	c4 50       	subi	r28, 0x04	; 4
    1828:	d1 40       	sbci	r29, 0x01	; 1
    182a:	62 17       	cp	r22, r18
    182c:	73 07       	cpc	r23, r19
    182e:	08 f4       	brcc	.+2      	; 0x1832 <CRC_16_Calc+0x188>
    1830:	6b cf       	rjmp	.-298    	; 0x1708 <CRC_16_Calc+0x5e>
	iterator_of_BitArr++;
	BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_0);
	iterator_of_BitArr++;
}
/*calculating the size of the array of bits taking into consideration the size of the 16 bits of CRC_16*/
BitArr_Size = iterator_of_BitArr + 15;
    1832:	51 5f       	subi	r21, 0xF1	; 241
/*reset the iterator of the Bits Array to zero to iterate through the array*/
iterator_of_BitArr = 0;
    1834:	40 e0       	ldi	r20, 0x00	; 0
/*Moving to the first occurance of high bit to start our CRC calculation*/
while(BitArr[iterator_of_BitArr]!=1)
    1836:	01 c0       	rjmp	.+2      	; 0x183a <CRC_16_Calc+0x190>
{
	/*increment the iterator to the first occurance of High bit*/
	iterator_of_BitArr++;
    1838:	4f 5f       	subi	r20, 0xFF	; 255
/*calculating the size of the array of bits taking into consideration the size of the 16 bits of CRC_16*/
BitArr_Size = iterator_of_BitArr + 15;
/*reset the iterator of the Bits Array to zero to iterate through the array*/
iterator_of_BitArr = 0;
/*Moving to the first occurance of high bit to start our CRC calculation*/
while(BitArr[iterator_of_BitArr]!=1)
    183a:	64 2f       	mov	r22, r20
    183c:	70 e0       	ldi	r23, 0x00	; 0
    183e:	e1 e0       	ldi	r30, 0x01	; 1
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	ec 0f       	add	r30, r28
    1844:	fd 1f       	adc	r31, r29
    1846:	e6 0f       	add	r30, r22
    1848:	f7 1f       	adc	r31, r23
    184a:	80 81       	ld	r24, Z
    184c:	81 30       	cpi	r24, 0x01	; 1
    184e:	a1 f7       	brne	.-24     	; 0x1838 <CRC_16_Calc+0x18e>
    1850:	e0 e0       	ldi	r30, 0x00	; 0
    1852:	31 c0       	rjmp	.+98     	; 0x18b6 <CRC_16_Calc+0x20c>
	/*increment the iterator to the first occurance of High bit*/
	iterator_of_BitArr++;
}
for (uint8_t i = 0; i<=16; i++)
{
	Window_16_Element |= ((uint32_t)BitArr[iterator_of_BitArr+i]<<(16-i));
    1854:	ce 2e       	mov	r12, r30
    1856:	d1 2c       	mov	r13, r1
    1858:	db 01       	movw	r26, r22
    185a:	ac 0d       	add	r26, r12
    185c:	bd 1d       	adc	r27, r13
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	8c 0f       	add	r24, r28
    1864:	9d 1f       	adc	r25, r29
    1866:	a8 0f       	add	r26, r24
    1868:	b9 1f       	adc	r27, r25
    186a:	8c 91       	ld	r24, X
    186c:	90 e0       	ldi	r25, 0x00	; 0
    186e:	a0 e0       	ldi	r26, 0x00	; 0
    1870:	b0 e0       	ldi	r27, 0x00	; 0
    1872:	68 94       	set
    1874:	ee 24       	eor	r14, r14
    1876:	e4 f8       	bld	r14, 4
    1878:	f1 2c       	mov	r15, r1
    187a:	ec 18       	sub	r14, r12
    187c:	fd 08       	sbc	r15, r13
    187e:	04 c0       	rjmp	.+8      	; 0x1888 <CRC_16_Calc+0x1de>
    1880:	88 0f       	add	r24, r24
    1882:	99 1f       	adc	r25, r25
    1884:	aa 1f       	adc	r26, r26
    1886:	bb 1f       	adc	r27, r27
    1888:	ea 94       	dec	r14
    188a:	d2 f7       	brpl	.-12     	; 0x1880 <CRC_16_Calc+0x1d6>
    188c:	c0 50       	subi	r28, 0x00	; 0
    188e:	df 4f       	sbci	r29, 0xFF	; 255
    1890:	c8 80       	ld	r12, Y
    1892:	d9 80       	ldd	r13, Y+1	; 0x01
    1894:	ea 80       	ldd	r14, Y+2	; 0x02
    1896:	fb 80       	ldd	r15, Y+3	; 0x03
    1898:	c0 50       	subi	r28, 0x00	; 0
    189a:	d1 40       	sbci	r29, 0x01	; 1
    189c:	8c 29       	or	r24, r12
    189e:	9d 29       	or	r25, r13
    18a0:	ae 29       	or	r26, r14
    18a2:	bf 29       	or	r27, r15
    18a4:	c0 50       	subi	r28, 0x00	; 0
    18a6:	df 4f       	sbci	r29, 0xFF	; 255
    18a8:	88 83       	st	Y, r24
    18aa:	99 83       	std	Y+1, r25	; 0x01
    18ac:	aa 83       	std	Y+2, r26	; 0x02
    18ae:	bb 83       	std	Y+3, r27	; 0x03
    18b0:	c0 50       	subi	r28, 0x00	; 0
    18b2:	d1 40       	sbci	r29, 0x01	; 1
while(BitArr[iterator_of_BitArr]!=1)
{
	/*increment the iterator to the first occurance of High bit*/
	iterator_of_BitArr++;
}
for (uint8_t i = 0; i<=16; i++)
    18b4:	ef 5f       	subi	r30, 0xFF	; 255
    18b6:	e1 31       	cpi	r30, 0x11	; 17
    18b8:	68 f2       	brcs	.-102    	; 0x1854 <CRC_16_Calc+0x1aa>
    18ba:	63 c0       	rjmp	.+198    	; 0x1982 <CRC_16_Calc+0x2d8>
}
/*Start the modulo Operation continues until the polynomial doesn't fit into the reminder*/
while(iterator_of_BitArr < BitArr_Size-15)
{
	/*Xoring operation between the Window and the polynomial*/
	Window_16_Element ^= polynomial;
    18bc:	c0 50       	subi	r28, 0x00	; 0
    18be:	df 4f       	sbci	r29, 0xFF	; 255
    18c0:	c8 80       	ld	r12, Y
    18c2:	d9 80       	ldd	r13, Y+1	; 0x01
    18c4:	ea 80       	ldd	r14, Y+2	; 0x02
    18c6:	fb 80       	ldd	r15, Y+3	; 0x03
    18c8:	c0 50       	subi	r28, 0x00	; 0
    18ca:	d1 40       	sbci	r29, 0x01	; 1
    18cc:	a5 e0       	ldi	r26, 0x05	; 5
    18ce:	ca 26       	eor	r12, r26
    18d0:	a0 e8       	ldi	r26, 0x80	; 128
    18d2:	da 26       	eor	r13, r26
    18d4:	a1 e0       	ldi	r26, 0x01	; 1
    18d6:	ea 26       	eor	r14, r26
    18d8:	c0 50       	subi	r28, 0x00	; 0
    18da:	df 4f       	sbci	r29, 0xFF	; 255
    18dc:	c8 82       	st	Y, r12
    18de:	d9 82       	std	Y+1, r13	; 0x01
    18e0:	ea 82       	std	Y+2, r14	; 0x02
    18e2:	fb 82       	std	Y+3, r15	; 0x03
    18e4:	c0 50       	subi	r28, 0x00	; 0
    18e6:	d1 40       	sbci	r29, 0x01	; 1
	if(!Window_16_Element)
    18e8:	c0 50       	subi	r28, 0x00	; 0
    18ea:	df 4f       	sbci	r29, 0xFF	; 255
    18ec:	c8 80       	ld	r12, Y
    18ee:	d9 80       	ldd	r13, Y+1	; 0x01
    18f0:	ea 80       	ldd	r14, Y+2	; 0x02
    18f2:	fb 80       	ldd	r15, Y+3	; 0x03
    18f4:	c0 50       	subi	r28, 0x00	; 0
    18f6:	d1 40       	sbci	r29, 0x01	; 1
    18f8:	cd 28       	or	r12, r13
    18fa:	ce 28       	or	r12, r14
    18fc:	cf 28       	or	r12, r15
    18fe:	09 f4       	brne	.+2      	; 0x1902 <CRC_16_Calc+0x258>
    1900:	4a c0       	rjmp	.+148    	; 0x1996 <CRC_16_Calc+0x2ec>
	break;
	if(iterator_of_BitArr < BitArr_Size-16)
    1902:	40 97       	sbiw	r24, 0x10	; 16
    1904:	68 17       	cp	r22, r24
    1906:	79 07       	cpc	r23, r25
    1908:	dc f5       	brge	.+118    	; 0x1980 <CRC_16_Calc+0x2d6>
	{
		do
		{
			Window_16_Element <<= 1;
    190a:	c0 50       	subi	r28, 0x00	; 0
    190c:	df 4f       	sbci	r29, 0xFF	; 255
    190e:	88 81       	ld	r24, Y
    1910:	99 81       	ldd	r25, Y+1	; 0x01
    1912:	aa 81       	ldd	r26, Y+2	; 0x02
    1914:	bb 81       	ldd	r27, Y+3	; 0x03
    1916:	c0 50       	subi	r28, 0x00	; 0
    1918:	d1 40       	sbci	r29, 0x01	; 1
    191a:	88 0f       	add	r24, r24
    191c:	99 1f       	adc	r25, r25
    191e:	aa 1f       	adc	r26, r26
    1920:	bb 1f       	adc	r27, r27
    1922:	c0 50       	subi	r28, 0x00	; 0
    1924:	df 4f       	sbci	r29, 0xFF	; 255
    1926:	88 83       	st	Y, r24
    1928:	99 83       	std	Y+1, r25	; 0x01
    192a:	aa 83       	std	Y+2, r26	; 0x02
    192c:	bb 83       	std	Y+3, r27	; 0x03
    192e:	c0 50       	subi	r28, 0x00	; 0
    1930:	d1 40       	sbci	r29, 0x01	; 1
			iterator_of_BitArr++;
    1932:	4f 5f       	subi	r20, 0xFF	; 255
			/*Adding new element from the array of bits to the window*/
			Window_16_Element |= (uint16_t)BitArr[iterator_of_BitArr+16];
    1934:	e4 2f       	mov	r30, r20
    1936:	f0 e0       	ldi	r31, 0x00	; 0
    1938:	70 96       	adiw	r30, 0x10	; 16
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	8c 0f       	add	r24, r28
    1940:	9d 1f       	adc	r25, r29
    1942:	e8 0f       	add	r30, r24
    1944:	f9 1f       	adc	r31, r25
    1946:	60 81       	ld	r22, Z
    1948:	c0 50       	subi	r28, 0x00	; 0
    194a:	df 4f       	sbci	r29, 0xFF	; 255
    194c:	88 81       	ld	r24, Y
    194e:	99 81       	ldd	r25, Y+1	; 0x01
    1950:	aa 81       	ldd	r26, Y+2	; 0x02
    1952:	bb 81       	ldd	r27, Y+3	; 0x03
    1954:	c0 50       	subi	r28, 0x00	; 0
    1956:	d1 40       	sbci	r29, 0x01	; 1
    1958:	86 2b       	or	r24, r22
    195a:	c0 50       	subi	r28, 0x00	; 0
    195c:	df 4f       	sbci	r29, 0xFF	; 255
    195e:	88 83       	st	Y, r24
    1960:	99 83       	std	Y+1, r25	; 0x01
    1962:	aa 83       	std	Y+2, r26	; 0x02
    1964:	bb 83       	std	Y+3, r27	; 0x03
    1966:	c0 50       	subi	r28, 0x00	; 0
    1968:	d1 40       	sbci	r29, 0x01	; 1
		} while ((GET_BIT(Window_16_Element,16) == 0));
    196a:	c0 50       	subi	r28, 0x00	; 0
    196c:	df 4f       	sbci	r29, 0xFF	; 255
    196e:	88 81       	ld	r24, Y
    1970:	99 81       	ldd	r25, Y+1	; 0x01
    1972:	aa 81       	ldd	r26, Y+2	; 0x02
    1974:	bb 81       	ldd	r27, Y+3	; 0x03
    1976:	c0 50       	subi	r28, 0x00	; 0
    1978:	d1 40       	sbci	r29, 0x01	; 1
    197a:	a0 ff       	sbrs	r26, 0
    197c:	c6 cf       	rjmp	.-116    	; 0x190a <CRC_16_Calc+0x260>
    197e:	01 c0       	rjmp	.+2      	; 0x1982 <CRC_16_Calc+0x2d8>
	}
	else
	{
		iterator_of_BitArr++;
    1980:	4f 5f       	subi	r20, 0xFF	; 255
for (uint8_t i = 0; i<=16; i++)
{
	Window_16_Element |= ((uint32_t)BitArr[iterator_of_BitArr+i]<<(16-i));
}
/*Start the modulo Operation continues until the polynomial doesn't fit into the reminder*/
while(iterator_of_BitArr < BitArr_Size-15)
    1982:	64 2f       	mov	r22, r20
    1984:	70 e0       	ldi	r23, 0x00	; 0
    1986:	85 2f       	mov	r24, r21
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	fc 01       	movw	r30, r24
    198c:	3f 97       	sbiw	r30, 0x0f	; 15
    198e:	6e 17       	cp	r22, r30
    1990:	7f 07       	cpc	r23, r31
    1992:	0c f4       	brge	.+2      	; 0x1996 <CRC_16_Calc+0x2ec>
    1994:	93 cf       	rjmp	.-218    	; 0x18bc <CRC_16_Calc+0x212>
	{
		iterator_of_BitArr++;
	}
}
/*Add the calculated CRC to the End of the Passed String*/
STRING[StrLength] = (uint8_t)(Window_16_Element>>8);
    1996:	f8 01       	movw	r30, r16
    1998:	e2 0f       	add	r30, r18
    199a:	f3 1f       	adc	r31, r19
    199c:	c0 50       	subi	r28, 0x00	; 0
    199e:	df 4f       	sbci	r29, 0xFF	; 255
    19a0:	88 81       	ld	r24, Y
    19a2:	99 81       	ldd	r25, Y+1	; 0x01
    19a4:	aa 81       	ldd	r26, Y+2	; 0x02
    19a6:	bb 81       	ldd	r27, Y+3	; 0x03
    19a8:	c0 50       	subi	r28, 0x00	; 0
    19aa:	d1 40       	sbci	r29, 0x01	; 1
    19ac:	90 83       	st	Z, r25
STRING[StrLength+1] = (uint8_t)(Window_16_Element&0x000000FF);
    19ae:	cc 5f       	subi	r28, 0xFC	; 252
    19b0:	de 4f       	sbci	r29, 0xFE	; 254
    19b2:	88 81       	ld	r24, Y
    19b4:	99 81       	ldd	r25, Y+1	; 0x01
    19b6:	c4 50       	subi	r28, 0x04	; 4
    19b8:	d1 40       	sbci	r29, 0x01	; 1
    19ba:	fc 01       	movw	r30, r24
    19bc:	31 96       	adiw	r30, 0x01	; 1
    19be:	e0 0f       	add	r30, r16
    19c0:	f1 1f       	adc	r31, r17
    19c2:	c0 50       	subi	r28, 0x00	; 0
    19c4:	df 4f       	sbci	r29, 0xFF	; 255
    19c6:	48 81       	ld	r20, Y
    19c8:	59 81       	ldd	r21, Y+1	; 0x01
    19ca:	6a 81       	ldd	r22, Y+2	; 0x02
    19cc:	7b 81       	ldd	r23, Y+3	; 0x03
    19ce:	c0 50       	subi	r28, 0x00	; 0
    19d0:	d1 40       	sbci	r29, 0x01	; 1
    19d2:	40 83       	st	Z, r20
STRING[StrLength+2] = NULL_TERMINATOR;
    19d4:	02 96       	adiw	r24, 0x02	; 2
    19d6:	f8 01       	movw	r30, r16
    19d8:	e8 0f       	add	r30, r24
    19da:	f9 1f       	adc	r31, r25
    19dc:	10 82       	st	Z, r1
/*return zero*/
return ERROR_OK;
}
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	cb 5f       	subi	r28, 0xFB	; 251
    19e2:	de 4f       	sbci	r29, 0xFE	; 254
    19e4:	0f b6       	in	r0, 0x3f	; 63
    19e6:	f8 94       	cli
    19e8:	de bf       	out	0x3e, r29	; 62
    19ea:	0f be       	out	0x3f, r0	; 63
    19ec:	cd bf       	out	0x3d, r28	; 61
    19ee:	df 91       	pop	r29
    19f0:	cf 91       	pop	r28
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	ff 90       	pop	r15
    19f8:	ef 90       	pop	r14
    19fa:	df 90       	pop	r13
    19fc:	cf 90       	pop	r12
    19fe:	08 95       	ret

00001a00 <CRC_16_Chk>:

uint8_t CRC_16_Chk (ptr_uint8_t STRING)
{
    1a00:	cf 92       	push	r12
    1a02:	df 92       	push	r13
    1a04:	ef 92       	push	r14
    1a06:	ff 92       	push	r15
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
    1a10:	c5 50       	subi	r28, 0x05	; 5
    1a12:	d1 40       	sbci	r29, 0x01	; 1
    1a14:	0f b6       	in	r0, 0x3f	; 63
    1a16:	f8 94       	cli
    1a18:	de bf       	out	0x3e, r29	; 62
    1a1a:	0f be       	out	0x3f, r0	; 63
    1a1c:	cd bf       	out	0x3d, r28	; 61
    1a1e:	7c 01       	movw	r14, r24
	/*change array of character to array of bits*/
	/*initialize the array of bits*/
	uint8_t BitArr[255] = {0};
    1a20:	fe 01       	movw	r30, r28
    1a22:	31 96       	adiw	r30, 0x01	; 1
    1a24:	8f ef       	ldi	r24, 0xFF	; 255
    1a26:	df 01       	movw	r26, r30
    1a28:	1d 92       	st	X+, r1
    1a2a:	8a 95       	dec	r24
    1a2c:	e9 f7       	brne	.-6      	; 0x1a28 <CRC_16_Chk+0x28>
	/*Error Return value*/
	uint8_t ErrRetVal = ERROR_OK;
	/*the value of the used polynomial for CRC_16*/
	const uint32_t polynomial = 0b00000000000000011000000000000101;
	/*variable that holds the value to be XORED and SHIFTED*/
	uint32_t volatile Window_16_Element =0;
    1a2e:	c0 50       	subi	r28, 0x00	; 0
    1a30:	df 4f       	sbci	r29, 0xFF	; 255
    1a32:	18 82       	st	Y, r1
    1a34:	19 82       	std	Y+1, r1	; 0x01
    1a36:	1a 82       	std	Y+2, r1	; 0x02
    1a38:	1b 82       	std	Y+3, r1	; 0x03
    1a3a:	c0 50       	subi	r28, 0x00	; 0
    1a3c:	d1 40       	sbci	r29, 0x01	; 1
	/*initialize the variable that holds the number of characters to which CRC is calculated*/
	/*number of characters in the inserted string*/
	uint16_t StrLength =0;
    1a3e:	cc 5f       	subi	r28, 0xFC	; 252
    1a40:	de 4f       	sbci	r29, 0xFE	; 254
    1a42:	19 82       	std	Y+1, r1	; 0x01
    1a44:	18 82       	st	Y, r1
    1a46:	c4 50       	subi	r28, 0x04	; 4
    1a48:	d1 40       	sbci	r29, 0x01	; 1
	/*initialize the variable that holds the number of bits in the inserted string*/
	uint8_t BitArr_Size = 0;
	/*using STR_Length() function to calculate Number of characters in the inserted String*/
	STR_Length(STRING, &StrLength);
    1a4a:	be 01       	movw	r22, r28
    1a4c:	6c 5f       	subi	r22, 0xFC	; 252
    1a4e:	7e 4f       	sbci	r23, 0xFE	; 254
    1a50:	c7 01       	movw	r24, r14
    1a52:	ec dd       	rcall	.-1064   	; 0x162c <STR_Length>
	uint8_t iterator_of_BitArr = 0;
	/*initializing the iterator for the array of the inserted Characters in the string*/
	uint8_t iterator_of_characters = 0;
	/*assigning the bits of the character in the passed string to the array of bits*/
	/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
	for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1a54:	40 e0       	ldi	r20, 0x00	; 0
	/*initialize the variable that holds the number of bits in the inserted string*/
	uint8_t BitArr_Size = 0;
	/*using STR_Length() function to calculate Number of characters in the inserted String*/
	STR_Length(STRING, &StrLength);
	/*initializing the iterator for the array of bits of the inserted Character string*/
	uint8_t iterator_of_BitArr = 0;
    1a56:	90 e0       	ldi	r25, 0x00	; 0
	/*initializing the iterator for the array of the inserted Characters in the string*/
	uint8_t iterator_of_characters = 0;
	/*assigning the bits of the character in the passed string to the array of bits*/
	/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
	for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1a58:	89 c0       	rjmp	.+274    	; 0x1b6c <CRC_16_Chk+0x16c>
	{
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_7);
    1a5a:	f7 01       	movw	r30, r14
    1a5c:	e2 0f       	add	r30, r18
    1a5e:	f3 1f       	adc	r31, r19
    1a60:	80 81       	ld	r24, Z
    1a62:	28 2f       	mov	r18, r24
    1a64:	22 1f       	adc	r18, r18
    1a66:	22 27       	eor	r18, r18
    1a68:	22 1f       	adc	r18, r18
    1a6a:	e1 e0       	ldi	r30, 0x01	; 1
    1a6c:	f0 e0       	ldi	r31, 0x00	; 0
    1a6e:	ec 0f       	add	r30, r28
    1a70:	fd 1f       	adc	r31, r29
    1a72:	e9 0f       	add	r30, r25
    1a74:	f1 1d       	adc	r31, r1
    1a76:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1a78:	51 e0       	ldi	r21, 0x01	; 1
    1a7a:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_6);
    1a7c:	28 2f       	mov	r18, r24
    1a7e:	20 74       	andi	r18, 0x40	; 64
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	02 2e       	mov	r0, r18
    1a84:	23 2f       	mov	r18, r19
    1a86:	00 0c       	add	r0, r0
    1a88:	22 1f       	adc	r18, r18
    1a8a:	33 0b       	sbc	r19, r19
    1a8c:	00 0c       	add	r0, r0
    1a8e:	22 1f       	adc	r18, r18
    1a90:	33 1f       	adc	r19, r19
    1a92:	e1 e0       	ldi	r30, 0x01	; 1
    1a94:	f0 e0       	ldi	r31, 0x00	; 0
    1a96:	ec 0f       	add	r30, r28
    1a98:	fd 1f       	adc	r31, r29
    1a9a:	e5 0f       	add	r30, r21
    1a9c:	f1 1d       	adc	r31, r1
    1a9e:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1aa0:	52 e0       	ldi	r21, 0x02	; 2
    1aa2:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_5);
    1aa4:	28 2f       	mov	r18, r24
    1aa6:	20 72       	andi	r18, 0x20	; 32
    1aa8:	30 e0       	ldi	r19, 0x00	; 0
    1aaa:	35 95       	asr	r19
    1aac:	27 95       	ror	r18
    1aae:	35 95       	asr	r19
    1ab0:	27 95       	ror	r18
    1ab2:	35 95       	asr	r19
    1ab4:	27 95       	ror	r18
    1ab6:	35 95       	asr	r19
    1ab8:	27 95       	ror	r18
    1aba:	35 95       	asr	r19
    1abc:	27 95       	ror	r18
    1abe:	e1 e0       	ldi	r30, 0x01	; 1
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	ec 0f       	add	r30, r28
    1ac4:	fd 1f       	adc	r31, r29
    1ac6:	e5 0f       	add	r30, r21
    1ac8:	f1 1d       	adc	r31, r1
    1aca:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1acc:	53 e0       	ldi	r21, 0x03	; 3
    1ace:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_4);
    1ad0:	28 2f       	mov	r18, r24
    1ad2:	20 71       	andi	r18, 0x10	; 16
    1ad4:	30 e0       	ldi	r19, 0x00	; 0
    1ad6:	35 95       	asr	r19
    1ad8:	27 95       	ror	r18
    1ada:	35 95       	asr	r19
    1adc:	27 95       	ror	r18
    1ade:	35 95       	asr	r19
    1ae0:	27 95       	ror	r18
    1ae2:	35 95       	asr	r19
    1ae4:	27 95       	ror	r18
    1ae6:	e1 e0       	ldi	r30, 0x01	; 1
    1ae8:	f0 e0       	ldi	r31, 0x00	; 0
    1aea:	ec 0f       	add	r30, r28
    1aec:	fd 1f       	adc	r31, r29
    1aee:	e5 0f       	add	r30, r21
    1af0:	f1 1d       	adc	r31, r1
    1af2:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1af4:	54 e0       	ldi	r21, 0x04	; 4
    1af6:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_3);
    1af8:	28 2f       	mov	r18, r24
    1afa:	28 70       	andi	r18, 0x08	; 8
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	35 95       	asr	r19
    1b00:	27 95       	ror	r18
    1b02:	35 95       	asr	r19
    1b04:	27 95       	ror	r18
    1b06:	35 95       	asr	r19
    1b08:	27 95       	ror	r18
    1b0a:	e1 e0       	ldi	r30, 0x01	; 1
    1b0c:	f0 e0       	ldi	r31, 0x00	; 0
    1b0e:	ec 0f       	add	r30, r28
    1b10:	fd 1f       	adc	r31, r29
    1b12:	e5 0f       	add	r30, r21
    1b14:	f1 1d       	adc	r31, r1
    1b16:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1b18:	55 e0       	ldi	r21, 0x05	; 5
    1b1a:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_2);
    1b1c:	28 2f       	mov	r18, r24
    1b1e:	24 70       	andi	r18, 0x04	; 4
    1b20:	30 e0       	ldi	r19, 0x00	; 0
    1b22:	35 95       	asr	r19
    1b24:	27 95       	ror	r18
    1b26:	35 95       	asr	r19
    1b28:	27 95       	ror	r18
    1b2a:	e1 e0       	ldi	r30, 0x01	; 1
    1b2c:	f0 e0       	ldi	r31, 0x00	; 0
    1b2e:	ec 0f       	add	r30, r28
    1b30:	fd 1f       	adc	r31, r29
    1b32:	e5 0f       	add	r30, r21
    1b34:	f1 1d       	adc	r31, r1
    1b36:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1b38:	56 e0       	ldi	r21, 0x06	; 6
    1b3a:	59 0f       	add	r21, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_1);
    1b3c:	28 2f       	mov	r18, r24
    1b3e:	22 70       	andi	r18, 0x02	; 2
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	35 95       	asr	r19
    1b44:	27 95       	ror	r18
    1b46:	e1 e0       	ldi	r30, 0x01	; 1
    1b48:	f0 e0       	ldi	r31, 0x00	; 0
    1b4a:	ec 0f       	add	r30, r28
    1b4c:	fd 1f       	adc	r31, r29
    1b4e:	e5 0f       	add	r30, r21
    1b50:	f1 1d       	adc	r31, r1
    1b52:	20 83       	st	Z, r18
		iterator_of_BitArr++;
    1b54:	27 e0       	ldi	r18, 0x07	; 7
    1b56:	29 0f       	add	r18, r25
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_0);
    1b58:	e1 e0       	ldi	r30, 0x01	; 1
    1b5a:	f0 e0       	ldi	r31, 0x00	; 0
    1b5c:	ec 0f       	add	r30, r28
    1b5e:	fd 1f       	adc	r31, r29
    1b60:	e2 0f       	add	r30, r18
    1b62:	f1 1d       	adc	r31, r1
    1b64:	81 70       	andi	r24, 0x01	; 1
    1b66:	80 83       	st	Z, r24
		iterator_of_BitArr++;
    1b68:	98 5f       	subi	r25, 0xF8	; 248
	uint8_t iterator_of_BitArr = 0;
	/*initializing the iterator for the array of the inserted Characters in the string*/
	uint8_t iterator_of_characters = 0;
	/*assigning the bits of the character in the passed string to the array of bits*/
	/*bits are arranged in the array the form of an extra long number"Index 0:MSB,..,..,..,. . .,Index N:LSB"*/
	for(iterator_of_characters = 0; iterator_of_characters < StrLength; iterator_of_characters++)
    1b6a:	4f 5f       	subi	r20, 0xFF	; 255
    1b6c:	24 2f       	mov	r18, r20
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	cc 5f       	subi	r28, 0xFC	; 252
    1b72:	de 4f       	sbci	r29, 0xFE	; 254
    1b74:	68 81       	ld	r22, Y
    1b76:	79 81       	ldd	r23, Y+1	; 0x01
    1b78:	c4 50       	subi	r28, 0x04	; 4
    1b7a:	d1 40       	sbci	r29, 0x01	; 1
    1b7c:	26 17       	cp	r18, r22
    1b7e:	37 07       	cpc	r19, r23
    1b80:	08 f4       	brcc	.+2      	; 0x1b84 <CRC_16_Chk+0x184>
    1b82:	6b cf       	rjmp	.-298    	; 0x1a5a <CRC_16_Chk+0x5a>
		iterator_of_BitArr++;
		BitArr[iterator_of_BitArr] = READ_BIT(STRING[iterator_of_characters],BIT_0);
		iterator_of_BitArr++;
	}
	/*calculating the size of the array of bits taking into consideration the size of the 16 bits of CRC_16*/
	BitArr_Size = iterator_of_BitArr + 15;
    1b84:	91 5f       	subi	r25, 0xF1	; 241
	/*reset the iterator of the Bits Array to zero to iterate through the array*/
	iterator_of_BitArr = 0;
    1b86:	a0 e0       	ldi	r26, 0x00	; 0
	/*Moving to the first occurance of high bit to start our CRC calculation*/
	while(BitArr[iterator_of_BitArr]!=1)
    1b88:	01 c0       	rjmp	.+2      	; 0x1b8c <CRC_16_Chk+0x18c>
	{
		/*increment the iterator to the first occurance of High bit*/
		iterator_of_BitArr++;
    1b8a:	af 5f       	subi	r26, 0xFF	; 255
	/*calculating the size of the array of bits taking into consideration the size of the 16 bits of CRC_16*/
	BitArr_Size = iterator_of_BitArr + 15;
	/*reset the iterator of the Bits Array to zero to iterate through the array*/
	iterator_of_BitArr = 0;
	/*Moving to the first occurance of high bit to start our CRC calculation*/
	while(BitArr[iterator_of_BitArr]!=1)
    1b8c:	2a 2f       	mov	r18, r26
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	e1 e0       	ldi	r30, 0x01	; 1
    1b92:	f0 e0       	ldi	r31, 0x00	; 0
    1b94:	ec 0f       	add	r30, r28
    1b96:	fd 1f       	adc	r31, r29
    1b98:	e2 0f       	add	r30, r18
    1b9a:	f3 1f       	adc	r31, r19
    1b9c:	80 81       	ld	r24, Z
    1b9e:	81 30       	cpi	r24, 0x01	; 1
    1ba0:	a1 f7       	brne	.-24     	; 0x1b8a <CRC_16_Chk+0x18a>
    1ba2:	80 e0       	ldi	r24, 0x00	; 0
    1ba4:	2f c0       	rjmp	.+94     	; 0x1c04 <CRC_16_Chk+0x204>
		/*increment the iterator to the first occurance of High bit*/
		iterator_of_BitArr++;
	}
	for (uint8_t i = 0; i<=16; i++)
	{
		Window_16_Element |= ((uint32_t)BitArr[iterator_of_BitArr+i]<<(16-i));
    1ba6:	e8 2e       	mov	r14, r24
    1ba8:	f1 2c       	mov	r15, r1
    1baa:	f9 01       	movw	r30, r18
    1bac:	ee 0d       	add	r30, r14
    1bae:	ff 1d       	adc	r31, r15
    1bb0:	41 e0       	ldi	r20, 0x01	; 1
    1bb2:	50 e0       	ldi	r21, 0x00	; 0
    1bb4:	4c 0f       	add	r20, r28
    1bb6:	5d 1f       	adc	r21, r29
    1bb8:	e4 0f       	add	r30, r20
    1bba:	f5 1f       	adc	r31, r21
    1bbc:	40 81       	ld	r20, Z
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	60 e0       	ldi	r22, 0x00	; 0
    1bc2:	70 e0       	ldi	r23, 0x00	; 0
    1bc4:	e0 e1       	ldi	r30, 0x10	; 16
    1bc6:	f0 e0       	ldi	r31, 0x00	; 0
    1bc8:	ee 19       	sub	r30, r14
    1bca:	ff 09       	sbc	r31, r15
    1bcc:	04 c0       	rjmp	.+8      	; 0x1bd6 <CRC_16_Chk+0x1d6>
    1bce:	44 0f       	add	r20, r20
    1bd0:	55 1f       	adc	r21, r21
    1bd2:	66 1f       	adc	r22, r22
    1bd4:	77 1f       	adc	r23, r23
    1bd6:	ea 95       	dec	r30
    1bd8:	d2 f7       	brpl	.-12     	; 0x1bce <CRC_16_Chk+0x1ce>
    1bda:	c0 50       	subi	r28, 0x00	; 0
    1bdc:	df 4f       	sbci	r29, 0xFF	; 255
    1bde:	c8 80       	ld	r12, Y
    1be0:	d9 80       	ldd	r13, Y+1	; 0x01
    1be2:	ea 80       	ldd	r14, Y+2	; 0x02
    1be4:	fb 80       	ldd	r15, Y+3	; 0x03
    1be6:	c0 50       	subi	r28, 0x00	; 0
    1be8:	d1 40       	sbci	r29, 0x01	; 1
    1bea:	4c 29       	or	r20, r12
    1bec:	5d 29       	or	r21, r13
    1bee:	6e 29       	or	r22, r14
    1bf0:	7f 29       	or	r23, r15
    1bf2:	c0 50       	subi	r28, 0x00	; 0
    1bf4:	df 4f       	sbci	r29, 0xFF	; 255
    1bf6:	48 83       	st	Y, r20
    1bf8:	59 83       	std	Y+1, r21	; 0x01
    1bfa:	6a 83       	std	Y+2, r22	; 0x02
    1bfc:	7b 83       	std	Y+3, r23	; 0x03
    1bfe:	c0 50       	subi	r28, 0x00	; 0
    1c00:	d1 40       	sbci	r29, 0x01	; 1
	while(BitArr[iterator_of_BitArr]!=1)
	{
		/*increment the iterator to the first occurance of High bit*/
		iterator_of_BitArr++;
	}
	for (uint8_t i = 0; i<=16; i++)
    1c02:	8f 5f       	subi	r24, 0xFF	; 255
    1c04:	81 31       	cpi	r24, 0x11	; 17
    1c06:	78 f2       	brcs	.-98     	; 0x1ba6 <CRC_16_Chk+0x1a6>
    1c08:	5f c0       	rjmp	.+190    	; 0x1cc8 <CRC_16_Chk+0x2c8>
	}
	/*Start the modulo Operation continues until the polynomial doesn't fit into the reminder*/
	while(iterator_of_BitArr < BitArr_Size-16)
	{
		/*Xoring operation between the Window and the polynomial*/
		Window_16_Element ^= polynomial;
    1c0a:	c0 50       	subi	r28, 0x00	; 0
    1c0c:	df 4f       	sbci	r29, 0xFF	; 255
    1c0e:	48 81       	ld	r20, Y
    1c10:	59 81       	ldd	r21, Y+1	; 0x01
    1c12:	6a 81       	ldd	r22, Y+2	; 0x02
    1c14:	7b 81       	ldd	r23, Y+3	; 0x03
    1c16:	c0 50       	subi	r28, 0x00	; 0
    1c18:	d1 40       	sbci	r29, 0x01	; 1
    1c1a:	85 e0       	ldi	r24, 0x05	; 5
    1c1c:	48 27       	eor	r20, r24
    1c1e:	50 58       	subi	r21, 0x80	; 128
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	68 27       	eor	r22, r24
    1c24:	c0 50       	subi	r28, 0x00	; 0
    1c26:	df 4f       	sbci	r29, 0xFF	; 255
    1c28:	48 83       	st	Y, r20
    1c2a:	59 83       	std	Y+1, r21	; 0x01
    1c2c:	6a 83       	std	Y+2, r22	; 0x02
    1c2e:	7b 83       	std	Y+3, r23	; 0x03
    1c30:	c0 50       	subi	r28, 0x00	; 0
    1c32:	d1 40       	sbci	r29, 0x01	; 1
		if(!Window_16_Element)
    1c34:	c0 50       	subi	r28, 0x00	; 0
    1c36:	df 4f       	sbci	r29, 0xFF	; 255
    1c38:	48 81       	ld	r20, Y
    1c3a:	59 81       	ldd	r21, Y+1	; 0x01
    1c3c:	6a 81       	ldd	r22, Y+2	; 0x02
    1c3e:	7b 81       	ldd	r23, Y+3	; 0x03
    1c40:	c0 50       	subi	r28, 0x00	; 0
    1c42:	d1 40       	sbci	r29, 0x01	; 1
    1c44:	45 2b       	or	r20, r21
    1c46:	46 2b       	or	r20, r22
    1c48:	47 2b       	or	r20, r23
    1c4a:	09 f4       	brne	.+2      	; 0x1c4e <CRC_16_Chk+0x24e>
    1c4c:	47 c0       	rjmp	.+142    	; 0x1cdc <CRC_16_Chk+0x2dc>
			break;
		if((iterator_of_BitArr < BitArr_Size-16))
    1c4e:	e2 17       	cp	r30, r18
    1c50:	f3 07       	cpc	r31, r19
    1c52:	d4 f5       	brge	.+116    	; 0x1cc8 <CRC_16_Chk+0x2c8>
		{
			do
			{
				Window_16_Element <<= 1;
    1c54:	c0 50       	subi	r28, 0x00	; 0
    1c56:	df 4f       	sbci	r29, 0xFF	; 255
    1c58:	48 81       	ld	r20, Y
    1c5a:	59 81       	ldd	r21, Y+1	; 0x01
    1c5c:	6a 81       	ldd	r22, Y+2	; 0x02
    1c5e:	7b 81       	ldd	r23, Y+3	; 0x03
    1c60:	c0 50       	subi	r28, 0x00	; 0
    1c62:	d1 40       	sbci	r29, 0x01	; 1
    1c64:	44 0f       	add	r20, r20
    1c66:	55 1f       	adc	r21, r21
    1c68:	66 1f       	adc	r22, r22
    1c6a:	77 1f       	adc	r23, r23
    1c6c:	c0 50       	subi	r28, 0x00	; 0
    1c6e:	df 4f       	sbci	r29, 0xFF	; 255
    1c70:	48 83       	st	Y, r20
    1c72:	59 83       	std	Y+1, r21	; 0x01
    1c74:	6a 83       	std	Y+2, r22	; 0x02
    1c76:	7b 83       	std	Y+3, r23	; 0x03
    1c78:	c0 50       	subi	r28, 0x00	; 0
    1c7a:	d1 40       	sbci	r29, 0x01	; 1
				iterator_of_BitArr++;
    1c7c:	af 5f       	subi	r26, 0xFF	; 255
				/*Adding new element from the array of bits to the window*/
				Window_16_Element |= (uint16_t)BitArr[iterator_of_BitArr+16];
    1c7e:	ea 2f       	mov	r30, r26
    1c80:	f0 e0       	ldi	r31, 0x00	; 0
    1c82:	70 96       	adiw	r30, 0x10	; 16
    1c84:	21 e0       	ldi	r18, 0x01	; 1
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	2c 0f       	add	r18, r28
    1c8a:	3d 1f       	adc	r19, r29
    1c8c:	e2 0f       	add	r30, r18
    1c8e:	f3 1f       	adc	r31, r19
    1c90:	80 81       	ld	r24, Z
    1c92:	c0 50       	subi	r28, 0x00	; 0
    1c94:	df 4f       	sbci	r29, 0xFF	; 255
    1c96:	48 81       	ld	r20, Y
    1c98:	59 81       	ldd	r21, Y+1	; 0x01
    1c9a:	6a 81       	ldd	r22, Y+2	; 0x02
    1c9c:	7b 81       	ldd	r23, Y+3	; 0x03
    1c9e:	c0 50       	subi	r28, 0x00	; 0
    1ca0:	d1 40       	sbci	r29, 0x01	; 1
    1ca2:	48 2b       	or	r20, r24
    1ca4:	c0 50       	subi	r28, 0x00	; 0
    1ca6:	df 4f       	sbci	r29, 0xFF	; 255
    1ca8:	48 83       	st	Y, r20
    1caa:	59 83       	std	Y+1, r21	; 0x01
    1cac:	6a 83       	std	Y+2, r22	; 0x02
    1cae:	7b 83       	std	Y+3, r23	; 0x03
    1cb0:	c0 50       	subi	r28, 0x00	; 0
    1cb2:	d1 40       	sbci	r29, 0x01	; 1
			} while ((GET_BIT(Window_16_Element,16) == 0));
    1cb4:	c0 50       	subi	r28, 0x00	; 0
    1cb6:	df 4f       	sbci	r29, 0xFF	; 255
    1cb8:	48 81       	ld	r20, Y
    1cba:	59 81       	ldd	r21, Y+1	; 0x01
    1cbc:	6a 81       	ldd	r22, Y+2	; 0x02
    1cbe:	7b 81       	ldd	r23, Y+3	; 0x03
    1cc0:	c0 50       	subi	r28, 0x00	; 0
    1cc2:	d1 40       	sbci	r29, 0x01	; 1
    1cc4:	60 ff       	sbrs	r22, 0
    1cc6:	c6 cf       	rjmp	.-116    	; 0x1c54 <CRC_16_Chk+0x254>
	for (uint8_t i = 0; i<=16; i++)
	{
		Window_16_Element |= ((uint32_t)BitArr[iterator_of_BitArr+i]<<(16-i));
	}
	/*Start the modulo Operation continues until the polynomial doesn't fit into the reminder*/
	while(iterator_of_BitArr < BitArr_Size-16)
    1cc8:	ea 2f       	mov	r30, r26
    1cca:	f0 e0       	ldi	r31, 0x00	; 0
    1ccc:	29 2f       	mov	r18, r25
    1cce:	30 e0       	ldi	r19, 0x00	; 0
    1cd0:	20 51       	subi	r18, 0x10	; 16
    1cd2:	31 09       	sbc	r19, r1
    1cd4:	e2 17       	cp	r30, r18
    1cd6:	f3 07       	cpc	r31, r19
    1cd8:	0c f4       	brge	.+2      	; 0x1cdc <CRC_16_Chk+0x2dc>
    1cda:	97 cf       	rjmp	.-210    	; 0x1c0a <CRC_16_Chk+0x20a>
				/*Adding new element from the array of bits to the window*/
				Window_16_Element |= (uint16_t)BitArr[iterator_of_BitArr+16];
			} while ((GET_BIT(Window_16_Element,16) == 0));
		}
	}
	if((uint16_t)Window_16_Element != 0)
    1cdc:	c0 50       	subi	r28, 0x00	; 0
    1cde:	df 4f       	sbci	r29, 0xFF	; 255
    1ce0:	88 81       	ld	r24, Y
    1ce2:	99 81       	ldd	r25, Y+1	; 0x01
    1ce4:	aa 81       	ldd	r26, Y+2	; 0x02
    1ce6:	bb 81       	ldd	r27, Y+3	; 0x03
    1ce8:	c0 50       	subi	r28, 0x00	; 0
    1cea:	d1 40       	sbci	r29, 0x01	; 1
    1cec:	89 2b       	or	r24, r25
    1cee:	11 f0       	breq	.+4      	; 0x1cf4 <CRC_16_Chk+0x2f4>
		ErrRetVal = ERROR_NOK;
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	01 c0       	rjmp	.+2      	; 0x1cf6 <CRC_16_Chk+0x2f6>
	else
		ErrRetVal = ERROR_OK;
    1cf4:	80 e0       	ldi	r24, 0x00	; 0
	return ErrRetVal;
    1cf6:	cb 5f       	subi	r28, 0xFB	; 251
    1cf8:	de 4f       	sbci	r29, 0xFE	; 254
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	de bf       	out	0x3e, r29	; 62
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	df 91       	pop	r29
    1d06:	cf 91       	pop	r28
    1d08:	ff 90       	pop	r15
    1d0a:	ef 90       	pop	r14
    1d0c:	df 90       	pop	r13
    1d0e:	cf 90       	pop	r12
    1d10:	08 95       	ret

00001d12 <DIO_SetPinDirection>:
				u8_ErrorState=ERROR_NOK;
				break;	
		}	
	}	
	return u8_ErrorState;
}
    1d12:	42 30       	cpi	r20, 0x02	; 2
    1d14:	08 f0       	brcs	.+2      	; 0x1d18 <DIO_SetPinDirection+0x6>
    1d16:	60 c0       	rjmp	.+192    	; 0x1dd8 <DIO_SetPinDirection+0xc6>
    1d18:	68 30       	cpi	r22, 0x08	; 8
    1d1a:	08 f0       	brcs	.+2      	; 0x1d1e <DIO_SetPinDirection+0xc>
    1d1c:	5f c0       	rjmp	.+190    	; 0x1ddc <DIO_SetPinDirection+0xca>
    1d1e:	81 30       	cpi	r24, 0x01	; 1
    1d20:	e1 f0       	breq	.+56     	; 0x1d5a <DIO_SetPinDirection+0x48>
    1d22:	30 f0       	brcs	.+12     	; 0x1d30 <DIO_SetPinDirection+0x1e>
    1d24:	82 30       	cpi	r24, 0x02	; 2
    1d26:	71 f1       	breq	.+92     	; 0x1d84 <DIO_SetPinDirection+0x72>
    1d28:	83 30       	cpi	r24, 0x03	; 3
    1d2a:	09 f4       	brne	.+2      	; 0x1d2e <DIO_SetPinDirection+0x1c>
    1d2c:	40 c0       	rjmp	.+128    	; 0x1dae <DIO_SetPinDirection+0x9c>
    1d2e:	58 c0       	rjmp	.+176    	; 0x1de0 <DIO_SetPinDirection+0xce>
    1d30:	2a b3       	in	r18, 0x1a	; 26
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	06 2e       	mov	r0, r22
    1d38:	02 c0       	rjmp	.+4      	; 0x1d3e <DIO_SetPinDirection+0x2c>
    1d3a:	88 0f       	add	r24, r24
    1d3c:	99 1f       	adc	r25, r25
    1d3e:	0a 94       	dec	r0
    1d40:	e2 f7       	brpl	.-8      	; 0x1d3a <DIO_SetPinDirection+0x28>
    1d42:	50 e0       	ldi	r21, 0x00	; 0
    1d44:	02 c0       	rjmp	.+4      	; 0x1d4a <DIO_SetPinDirection+0x38>
    1d46:	44 0f       	add	r20, r20
    1d48:	55 1f       	adc	r21, r21
    1d4a:	6a 95       	dec	r22
    1d4c:	e2 f7       	brpl	.-8      	; 0x1d46 <DIO_SetPinDirection+0x34>
    1d4e:	80 95       	com	r24
    1d50:	82 23       	and	r24, r18
    1d52:	48 2b       	or	r20, r24
    1d54:	4a bb       	out	0x1a, r20	; 26
    1d56:	80 e0       	ldi	r24, 0x00	; 0
    1d58:	08 95       	ret
    1d5a:	27 b3       	in	r18, 0x17	; 23
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	06 2e       	mov	r0, r22
    1d62:	02 c0       	rjmp	.+4      	; 0x1d68 <DIO_SetPinDirection+0x56>
    1d64:	88 0f       	add	r24, r24
    1d66:	99 1f       	adc	r25, r25
    1d68:	0a 94       	dec	r0
    1d6a:	e2 f7       	brpl	.-8      	; 0x1d64 <DIO_SetPinDirection+0x52>
    1d6c:	50 e0       	ldi	r21, 0x00	; 0
    1d6e:	02 c0       	rjmp	.+4      	; 0x1d74 <DIO_SetPinDirection+0x62>
    1d70:	44 0f       	add	r20, r20
    1d72:	55 1f       	adc	r21, r21
    1d74:	6a 95       	dec	r22
    1d76:	e2 f7       	brpl	.-8      	; 0x1d70 <DIO_SetPinDirection+0x5e>
    1d78:	80 95       	com	r24
    1d7a:	82 23       	and	r24, r18
    1d7c:	48 2b       	or	r20, r24
    1d7e:	47 bb       	out	0x17, r20	; 23
    1d80:	80 e0       	ldi	r24, 0x00	; 0
    1d82:	08 95       	ret
    1d84:	24 b3       	in	r18, 0x14	; 20
    1d86:	81 e0       	ldi	r24, 0x01	; 1
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	06 2e       	mov	r0, r22
    1d8c:	02 c0       	rjmp	.+4      	; 0x1d92 <DIO_SetPinDirection+0x80>
    1d8e:	88 0f       	add	r24, r24
    1d90:	99 1f       	adc	r25, r25
    1d92:	0a 94       	dec	r0
    1d94:	e2 f7       	brpl	.-8      	; 0x1d8e <DIO_SetPinDirection+0x7c>
    1d96:	50 e0       	ldi	r21, 0x00	; 0
    1d98:	02 c0       	rjmp	.+4      	; 0x1d9e <DIO_SetPinDirection+0x8c>
    1d9a:	44 0f       	add	r20, r20
    1d9c:	55 1f       	adc	r21, r21
    1d9e:	6a 95       	dec	r22
    1da0:	e2 f7       	brpl	.-8      	; 0x1d9a <DIO_SetPinDirection+0x88>
    1da2:	80 95       	com	r24
    1da4:	82 23       	and	r24, r18
    1da6:	48 2b       	or	r20, r24
    1da8:	44 bb       	out	0x14, r20	; 20
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	08 95       	ret
    1dae:	21 b3       	in	r18, 0x11	; 17
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	06 2e       	mov	r0, r22
    1db6:	02 c0       	rjmp	.+4      	; 0x1dbc <DIO_SetPinDirection+0xaa>
    1db8:	88 0f       	add	r24, r24
    1dba:	99 1f       	adc	r25, r25
    1dbc:	0a 94       	dec	r0
    1dbe:	e2 f7       	brpl	.-8      	; 0x1db8 <DIO_SetPinDirection+0xa6>
    1dc0:	50 e0       	ldi	r21, 0x00	; 0
    1dc2:	02 c0       	rjmp	.+4      	; 0x1dc8 <DIO_SetPinDirection+0xb6>
    1dc4:	44 0f       	add	r20, r20
    1dc6:	55 1f       	adc	r21, r21
    1dc8:	6a 95       	dec	r22
    1dca:	e2 f7       	brpl	.-8      	; 0x1dc4 <DIO_SetPinDirection+0xb2>
    1dcc:	80 95       	com	r24
    1dce:	82 23       	and	r24, r18
    1dd0:	48 2b       	or	r20, r24
    1dd2:	41 bb       	out	0x11, r20	; 17
    1dd4:	80 e0       	ldi	r24, 0x00	; 0
    1dd6:	08 95       	ret
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	08 95       	ret
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	08 95       	ret
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	08 95       	ret

00001de4 <DIO_WritePin>:
    1de4:	42 30       	cpi	r20, 0x02	; 2
    1de6:	08 f0       	brcs	.+2      	; 0x1dea <DIO_WritePin+0x6>
    1de8:	60 c0       	rjmp	.+192    	; 0x1eaa <DIO_WritePin+0xc6>
    1dea:	68 30       	cpi	r22, 0x08	; 8
    1dec:	08 f0       	brcs	.+2      	; 0x1df0 <DIO_WritePin+0xc>
    1dee:	5f c0       	rjmp	.+190    	; 0x1eae <DIO_WritePin+0xca>
    1df0:	81 30       	cpi	r24, 0x01	; 1
    1df2:	e1 f0       	breq	.+56     	; 0x1e2c <DIO_WritePin+0x48>
    1df4:	30 f0       	brcs	.+12     	; 0x1e02 <DIO_WritePin+0x1e>
    1df6:	82 30       	cpi	r24, 0x02	; 2
    1df8:	71 f1       	breq	.+92     	; 0x1e56 <DIO_WritePin+0x72>
    1dfa:	83 30       	cpi	r24, 0x03	; 3
    1dfc:	09 f4       	brne	.+2      	; 0x1e00 <DIO_WritePin+0x1c>
    1dfe:	40 c0       	rjmp	.+128    	; 0x1e80 <DIO_WritePin+0x9c>
    1e00:	58 c0       	rjmp	.+176    	; 0x1eb2 <DIO_WritePin+0xce>
    1e02:	2b b3       	in	r18, 0x1b	; 27
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	06 2e       	mov	r0, r22
    1e0a:	02 c0       	rjmp	.+4      	; 0x1e10 <DIO_WritePin+0x2c>
    1e0c:	88 0f       	add	r24, r24
    1e0e:	99 1f       	adc	r25, r25
    1e10:	0a 94       	dec	r0
    1e12:	e2 f7       	brpl	.-8      	; 0x1e0c <DIO_WritePin+0x28>
    1e14:	50 e0       	ldi	r21, 0x00	; 0
    1e16:	02 c0       	rjmp	.+4      	; 0x1e1c <DIO_WritePin+0x38>
    1e18:	44 0f       	add	r20, r20
    1e1a:	55 1f       	adc	r21, r21
    1e1c:	6a 95       	dec	r22
    1e1e:	e2 f7       	brpl	.-8      	; 0x1e18 <DIO_WritePin+0x34>
    1e20:	80 95       	com	r24
    1e22:	82 23       	and	r24, r18
    1e24:	48 2b       	or	r20, r24
    1e26:	4b bb       	out	0x1b, r20	; 27
    1e28:	80 e0       	ldi	r24, 0x00	; 0
    1e2a:	08 95       	ret
    1e2c:	28 b3       	in	r18, 0x18	; 24
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	06 2e       	mov	r0, r22
    1e34:	02 c0       	rjmp	.+4      	; 0x1e3a <DIO_WritePin+0x56>
    1e36:	88 0f       	add	r24, r24
    1e38:	99 1f       	adc	r25, r25
    1e3a:	0a 94       	dec	r0
    1e3c:	e2 f7       	brpl	.-8      	; 0x1e36 <DIO_WritePin+0x52>
    1e3e:	50 e0       	ldi	r21, 0x00	; 0
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <DIO_WritePin+0x62>
    1e42:	44 0f       	add	r20, r20
    1e44:	55 1f       	adc	r21, r21
    1e46:	6a 95       	dec	r22
    1e48:	e2 f7       	brpl	.-8      	; 0x1e42 <DIO_WritePin+0x5e>
    1e4a:	80 95       	com	r24
    1e4c:	82 23       	and	r24, r18
    1e4e:	48 2b       	or	r20, r24
    1e50:	48 bb       	out	0x18, r20	; 24
    1e52:	80 e0       	ldi	r24, 0x00	; 0
    1e54:	08 95       	ret
    1e56:	25 b3       	in	r18, 0x15	; 21
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	06 2e       	mov	r0, r22
    1e5e:	02 c0       	rjmp	.+4      	; 0x1e64 <DIO_WritePin+0x80>
    1e60:	88 0f       	add	r24, r24
    1e62:	99 1f       	adc	r25, r25
    1e64:	0a 94       	dec	r0
    1e66:	e2 f7       	brpl	.-8      	; 0x1e60 <DIO_WritePin+0x7c>
    1e68:	50 e0       	ldi	r21, 0x00	; 0
    1e6a:	02 c0       	rjmp	.+4      	; 0x1e70 <DIO_WritePin+0x8c>
    1e6c:	44 0f       	add	r20, r20
    1e6e:	55 1f       	adc	r21, r21
    1e70:	6a 95       	dec	r22
    1e72:	e2 f7       	brpl	.-8      	; 0x1e6c <DIO_WritePin+0x88>
    1e74:	80 95       	com	r24
    1e76:	82 23       	and	r24, r18
    1e78:	48 2b       	or	r20, r24
    1e7a:	45 bb       	out	0x15, r20	; 21
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	08 95       	ret
    1e80:	22 b3       	in	r18, 0x12	; 18
    1e82:	81 e0       	ldi	r24, 0x01	; 1
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	06 2e       	mov	r0, r22
    1e88:	02 c0       	rjmp	.+4      	; 0x1e8e <DIO_WritePin+0xaa>
    1e8a:	88 0f       	add	r24, r24
    1e8c:	99 1f       	adc	r25, r25
    1e8e:	0a 94       	dec	r0
    1e90:	e2 f7       	brpl	.-8      	; 0x1e8a <DIO_WritePin+0xa6>
    1e92:	50 e0       	ldi	r21, 0x00	; 0
    1e94:	02 c0       	rjmp	.+4      	; 0x1e9a <DIO_WritePin+0xb6>
    1e96:	44 0f       	add	r20, r20
    1e98:	55 1f       	adc	r21, r21
    1e9a:	6a 95       	dec	r22
    1e9c:	e2 f7       	brpl	.-8      	; 0x1e96 <DIO_WritePin+0xb2>
    1e9e:	80 95       	com	r24
    1ea0:	82 23       	and	r24, r18
    1ea2:	48 2b       	or	r20, r24
    1ea4:	42 bb       	out	0x12, r20	; 18
    1ea6:	80 e0       	ldi	r24, 0x00	; 0
    1ea8:	08 95       	ret
    1eaa:	81 e0       	ldi	r24, 0x01	; 1
    1eac:	08 95       	ret
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	08 95       	ret
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	08 95       	ret

00001eb6 <DIO_ReadPin>:
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1eb6:	68 30       	cpi	r22, 0x08	; 8
    1eb8:	d8 f5       	brcc	.+118    	; 0x1f30 <DIO_ReadPin+0x7a>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(NULL_PTR==PinData)
    1eba:	41 15       	cp	r20, r1
    1ebc:	51 05       	cpc	r21, r1
    1ebe:	d1 f1       	breq	.+116    	; 0x1f34 <DIO_ReadPin+0x7e>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    1ec0:	81 30       	cpi	r24, 0x01	; 1
    1ec2:	91 f0       	breq	.+36     	; 0x1ee8 <DIO_ReadPin+0x32>
    1ec4:	28 f0       	brcs	.+10     	; 0x1ed0 <DIO_ReadPin+0x1a>
    1ec6:	82 30       	cpi	r24, 0x02	; 2
    1ec8:	d9 f0       	breq	.+54     	; 0x1f00 <DIO_ReadPin+0x4a>
    1eca:	83 30       	cpi	r24, 0x03	; 3
    1ecc:	29 f1       	breq	.+74     	; 0x1f18 <DIO_ReadPin+0x62>
    1ece:	34 c0       	rjmp	.+104    	; 0x1f38 <DIO_ReadPin+0x82>
		{
			case PORT_A:
				* PinData=BIT_GET(PINA,PinNo);
    1ed0:	89 b3       	in	r24, 0x19	; 25
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	02 c0       	rjmp	.+4      	; 0x1eda <DIO_ReadPin+0x24>
    1ed6:	95 95       	asr	r25
    1ed8:	87 95       	ror	r24
    1eda:	6a 95       	dec	r22
    1edc:	e2 f7       	brpl	.-8      	; 0x1ed6 <DIO_ReadPin+0x20>
    1ede:	81 70       	andi	r24, 0x01	; 1
    1ee0:	fa 01       	movw	r30, r20
    1ee2:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1ee4:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1ee6:	08 95       	ret
			case PORT_B:
				* PinData=BIT_GET(PINB,PinNo);
    1ee8:	86 b3       	in	r24, 0x16	; 22
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	02 c0       	rjmp	.+4      	; 0x1ef2 <DIO_ReadPin+0x3c>
    1eee:	95 95       	asr	r25
    1ef0:	87 95       	ror	r24
    1ef2:	6a 95       	dec	r22
    1ef4:	e2 f7       	brpl	.-8      	; 0x1eee <DIO_ReadPin+0x38>
    1ef6:	81 70       	andi	r24, 0x01	; 1
    1ef8:	fa 01       	movw	r30, r20
    1efa:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1efc:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1efe:	08 95       	ret
			case PORT_C:
				* PinData=BIT_GET(PINC,PinNo);
    1f00:	83 b3       	in	r24, 0x13	; 19
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	02 c0       	rjmp	.+4      	; 0x1f0a <DIO_ReadPin+0x54>
    1f06:	95 95       	asr	r25
    1f08:	87 95       	ror	r24
    1f0a:	6a 95       	dec	r22
    1f0c:	e2 f7       	brpl	.-8      	; 0x1f06 <DIO_ReadPin+0x50>
    1f0e:	81 70       	andi	r24, 0x01	; 1
    1f10:	fa 01       	movw	r30, r20
    1f12:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1f14:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1f16:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
    1f18:	80 b3       	in	r24, 0x10	; 16
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	02 c0       	rjmp	.+4      	; 0x1f22 <DIO_ReadPin+0x6c>
    1f1e:	95 95       	asr	r25
    1f20:	87 95       	ror	r24
    1f22:	6a 95       	dec	r22
    1f24:	e2 f7       	brpl	.-8      	; 0x1f1e <DIO_ReadPin+0x68>
    1f26:	81 70       	andi	r24, 0x01	; 1
    1f28:	fa 01       	movw	r30, r20
    1f2a:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1f2c:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1f2e:	08 95       	ret
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	08 95       	ret
	}
	else if(NULL_PTR==PinData)
	{
		u8_ErrorState=ERROR_NOK;
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1f38:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    1f3a:	08 95       	ret

00001f3c <DIO_EnablePinPullup>:


ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1f3c:	68 30       	cpi	r22, 0x08	; 8
    1f3e:	c0 f5       	brcc	.+112    	; 0x1fb0 <DIO_EnablePinPullup+0x74>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{	
		switch(PortName)
    1f40:	81 30       	cpi	r24, 0x01	; 1
    1f42:	91 f0       	breq	.+36     	; 0x1f68 <DIO_EnablePinPullup+0x2c>
    1f44:	28 f0       	brcs	.+10     	; 0x1f50 <DIO_EnablePinPullup+0x14>
    1f46:	82 30       	cpi	r24, 0x02	; 2
    1f48:	d9 f0       	breq	.+54     	; 0x1f80 <DIO_EnablePinPullup+0x44>
    1f4a:	83 30       	cpi	r24, 0x03	; 3
    1f4c:	29 f1       	breq	.+74     	; 0x1f98 <DIO_EnablePinPullup+0x5c>
    1f4e:	32 c0       	rjmp	.+100    	; 0x1fb4 <DIO_EnablePinPullup+0x78>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PIN_HIGH);
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	90 e0       	ldi	r25, 0x00	; 0
    1f54:	02 c0       	rjmp	.+4      	; 0x1f5a <DIO_EnablePinPullup+0x1e>
    1f56:	88 0f       	add	r24, r24
    1f58:	99 1f       	adc	r25, r25
    1f5a:	6a 95       	dec	r22
    1f5c:	e2 f7       	brpl	.-8      	; 0x1f56 <DIO_EnablePinPullup+0x1a>
    1f5e:	9b b3       	in	r25, 0x1b	; 27
    1f60:	89 2b       	or	r24, r25
    1f62:	8b bb       	out	0x1b, r24	; 27
				u8_ErrorState=ERROR_OK;
    1f64:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1f66:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PIN_HIGH);
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	02 c0       	rjmp	.+4      	; 0x1f72 <DIO_EnablePinPullup+0x36>
    1f6e:	88 0f       	add	r24, r24
    1f70:	99 1f       	adc	r25, r25
    1f72:	6a 95       	dec	r22
    1f74:	e2 f7       	brpl	.-8      	; 0x1f6e <DIO_EnablePinPullup+0x32>
    1f76:	98 b3       	in	r25, 0x18	; 24
    1f78:	89 2b       	or	r24, r25
    1f7a:	88 bb       	out	0x18, r24	; 24
				u8_ErrorState=ERROR_OK;
    1f7c:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    1f7e:	08 95       	ret
			case PORT_C:                          
				BIT_WRITE(PORTC,PinNo,PIN_HIGH);
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	90 e0       	ldi	r25, 0x00	; 0
    1f84:	02 c0       	rjmp	.+4      	; 0x1f8a <DIO_EnablePinPullup+0x4e>
    1f86:	88 0f       	add	r24, r24
    1f88:	99 1f       	adc	r25, r25
    1f8a:	6a 95       	dec	r22
    1f8c:	e2 f7       	brpl	.-8      	; 0x1f86 <DIO_EnablePinPullup+0x4a>
    1f8e:	95 b3       	in	r25, 0x15	; 21
    1f90:	89 2b       	or	r24, r25
    1f92:	85 bb       	out	0x15, r24	; 21
				u8_ErrorState=ERROR_OK;
    1f94:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    1f96:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	02 c0       	rjmp	.+4      	; 0x1fa2 <DIO_EnablePinPullup+0x66>
    1f9e:	88 0f       	add	r24, r24
    1fa0:	99 1f       	adc	r25, r25
    1fa2:	6a 95       	dec	r22
    1fa4:	e2 f7       	brpl	.-8      	; 0x1f9e <DIO_EnablePinPullup+0x62>
    1fa6:	92 b3       	in	r25, 0x12	; 18
    1fa8:	89 2b       	or	r24, r25
    1faa:	82 bb       	out	0x12, r24	; 18
				u8_ErrorState=ERROR_OK;
    1fac:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1fae:	08 95       	ret
ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}	
	}	
	return u8_ErrorState;
    1fb6:	08 95       	ret

00001fb8 <EEPROM_Write>:
{
	uint8_t ErrRetVal = OperationStarted;
	uint8_t StatusRegVal = 0;
	/*1. Wait until EEWE becomes zero.*/
	/*2. Wait until SPMEN in SPMCR becomes zero.*/
	while(READ_BIT(EECR, EEWE));
    1fb8:	e1 99       	sbic	0x1c, 1	; 28
    1fba:	fe cf       	rjmp	.-4      	; 0x1fb8 <EEPROM_Write>
	/*3. Write new EEPROM address to EEAR (optional).*/
	WRITE_REG(EEAR, Address);
    1fbc:	7f bb       	out	0x1f, r23	; 31
    1fbe:	6e bb       	out	0x1e, r22	; 30
	/*4. Write new EEPROM data to EEDR (optional).*/
	WRITE_REG(EEDR, Data);
    1fc0:	8d bb       	out	0x1d, r24	; 29
	/*5. Disable the Global Interrupt*/
	StatusRegVal = READ_REG(SREG);
    1fc2:	9f b7       	in	r25, 0x3f	; 63
	CLEAR_BIT(SREG, I);
    1fc4:	89 2f       	mov	r24, r25
    1fc6:	8f 77       	andi	r24, 0x7F	; 127
    1fc8:	8f bf       	out	0x3f, r24	; 63
	/*6. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR.*/
	SET_BIT(EECR, EEMWE);
    1fca:	8c b3       	in	r24, 0x1c	; 28
    1fcc:	84 60       	ori	r24, 0x04	; 4
    1fce:	8c bb       	out	0x1c, r24	; 28
	/*7. Within four clock cycles after setting EEMWE, write a logical one to EEWE.*/
	SET_BIT(EECR, EEWE);
    1fd0:	8c b3       	in	r24, 0x1c	; 28
    1fd2:	82 60       	ori	r24, 0x02	; 2
    1fd4:	8c bb       	out	0x1c, r24	; 28
	/*8. Return the state of status register*/
	WRITE_REG(SREG, StatusRegVal);
    1fd6:	9f bf       	out	0x3f, r25	; 63
	/*9. Set function's return*/
	ErrRetVal = OperationSuccess;			
	return ErrRetVal;
}
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	08 95       	ret

00001fdc <GLOBALINTTERUPTS_Enable>:
/**
* @brief: This function enables global interrupts.
*/
void GLOBALINTTERUPTS_Enable(void)
{
   SET_BIT(SREG, I);
    1fdc:	8f b7       	in	r24, 0x3f	; 63
    1fde:	80 68       	ori	r24, 0x80	; 128
    1fe0:	8f bf       	out	0x3f, r24	; 63
    1fe2:	08 95       	ret

00001fe4 <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    1fe4:	83 30       	cpi	r24, 0x03	; 3
    1fe6:	61 f5       	brne	.+88     	; 0x2040 <PWM_Init+0x5c>
    1fe8:	85 b5       	in	r24, 0x25	; 37
    1fea:	e3 e9       	ldi	r30, 0x93	; 147
    1fec:	f0 e0       	ldi	r31, 0x00	; 0
    1fee:	92 85       	ldd	r25, Z+10	; 0x0a
    1ff0:	49 2f       	mov	r20, r25
    1ff2:	41 70       	andi	r20, 0x01	; 1
    1ff4:	50 e0       	ldi	r21, 0x00	; 0
    1ff6:	00 24       	eor	r0, r0
    1ff8:	56 95       	lsr	r21
    1ffa:	47 95       	ror	r20
    1ffc:	07 94       	ror	r0
    1ffe:	56 95       	lsr	r21
    2000:	47 95       	ror	r20
    2002:	07 94       	ror	r0
    2004:	54 2f       	mov	r21, r20
    2006:	40 2d       	mov	r20, r0
    2008:	8f 7b       	andi	r24, 0xBF	; 191
    200a:	48 2b       	or	r20, r24
    200c:	91 fb       	bst	r25, 1
    200e:	22 27       	eor	r18, r18
    2010:	20 f9       	bld	r18, 0
    2012:	30 e0       	ldi	r19, 0x00	; 0
    2014:	22 0f       	add	r18, r18
    2016:	33 1f       	adc	r19, r19
    2018:	22 0f       	add	r18, r18
    201a:	33 1f       	adc	r19, r19
    201c:	22 0f       	add	r18, r18
    201e:	33 1f       	adc	r19, r19
    2020:	47 7f       	andi	r20, 0xF7	; 247
    2022:	24 2b       	or	r18, r20
    2024:	83 85       	ldd	r24, Z+11	; 0x0b
    2026:	30 e1       	ldi	r19, 0x10	; 16
    2028:	83 9f       	mul	r24, r19
    202a:	c0 01       	movw	r24, r0
    202c:	11 24       	eor	r1, r1
    202e:	2f 7c       	andi	r18, 0xCF	; 207
    2030:	28 2b       	or	r18, r24
    2032:	25 bd       	out	0x25, r18	; 37
    2034:	41 e0       	ldi	r20, 0x01	; 1
    2036:	67 e0       	ldi	r22, 0x07	; 7
    2038:	83 e0       	ldi	r24, 0x03	; 3
    203a:	6b de       	rcall	.-810    	; 0x1d12 <DIO_SetPinDirection>
    203c:	80 e0       	ldi	r24, 0x00	; 0
    203e:	08 95       	ret
    2040:	81 e0       	ldi	r24, 0x01	; 1
    2042:	08 95       	ret

00002044 <PWM_Start>:
    2044:	83 30       	cpi	r24, 0x03	; 3
    2046:	41 f4       	brne	.+16     	; 0x2058 <PWM_Start+0x14>
    2048:	85 b5       	in	r24, 0x25	; 37
    204a:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <gastr_PWMConfig+0x9>
    204e:	88 7f       	andi	r24, 0xF8	; 248
    2050:	89 2b       	or	r24, r25
    2052:	85 bd       	out	0x25, r24	; 37
    2054:	80 e0       	ldi	r24, 0x00	; 0
    2056:	08 95       	ret
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	08 95       	ret

0000205c <PWM_Connect>:
    205c:	83 30       	cpi	r24, 0x03	; 3
    205e:	69 f4       	brne	.+26     	; 0x207a <PWM_Connect+0x1e>
    2060:	25 b5       	in	r18, 0x25	; 37
    2062:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <gastr_PWMConfig+0xb>
    2066:	30 e1       	ldi	r19, 0x10	; 16
    2068:	93 9f       	mul	r25, r19
    206a:	c0 01       	movw	r24, r0
    206c:	11 24       	eor	r1, r1
    206e:	92 2f       	mov	r25, r18
    2070:	9f 7c       	andi	r25, 0xCF	; 207
    2072:	89 2b       	or	r24, r25
    2074:	85 bd       	out	0x25, r24	; 37
    2076:	80 e0       	ldi	r24, 0x00	; 0
    2078:	08 95       	ret
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	08 95       	ret

0000207e <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    207e:	9f ef       	ldi	r25, 0xFF	; 255
    2080:	96 0f       	add	r25, r22
    2082:	94 36       	cpi	r25, 0x64	; 100
    2084:	e8 f4       	brcc	.+58     	; 0x20c0 <PWM_SetDuty+0x42>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    2086:	83 30       	cpi	r24, 0x03	; 3
    2088:	e9 f4       	brne	.+58     	; 0x20c4 <PWM_SetDuty+0x46>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    208a:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <gastr_PWMConfig+0xb>
    208e:	82 30       	cpi	r24, 0x02	; 2
    2090:	d9 f4       	brne	.+54     	; 0x20c8 <PWM_SetDuty+0x4a>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    2092:	70 e0       	ldi	r23, 0x00	; 0
    2094:	80 e0       	ldi	r24, 0x00	; 0
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	d4 d6       	rcall	.+3496   	; 0x2e42 <__floatsisf>
    209a:	20 e0       	ldi	r18, 0x00	; 0
    209c:	30 e0       	ldi	r19, 0x00	; 0
    209e:	48 ec       	ldi	r20, 0xC8	; 200
    20a0:	52 e4       	ldi	r21, 0x42	; 66
    20a2:	39 d6       	rcall	.+3186   	; 0x2d16 <__divsf3>
    20a4:	20 e0       	ldi	r18, 0x00	; 0
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	40 e8       	ldi	r20, 0x80	; 128
    20aa:	53 e4       	ldi	r21, 0x43	; 67
    20ac:	56 d7       	rcall	.+3756   	; 0x2f5a <__mulsf3>
    20ae:	20 e0       	ldi	r18, 0x00	; 0
    20b0:	30 e0       	ldi	r19, 0x00	; 0
    20b2:	40 e8       	ldi	r20, 0x80	; 128
    20b4:	5f e3       	ldi	r21, 0x3F	; 63
    20b6:	ca d5       	rcall	.+2964   	; 0x2c4c <__subsf3>
    20b8:	96 d6       	rcall	.+3372   	; 0x2de6 <__fixunssfsi>
    20ba:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    20bc:	80 e0       	ldi	r24, 0x00	; 0
							break;
    20be:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    20c4:	81 e0       	ldi	r24, 0x01	; 1
    20c6:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    20c8:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    20ca:	08 95       	ret

000020cc <UART_Init>:
		default:
			u8_ErrorState=ERROR_UNSUPPORTED_CH;
			break;
	}
	return u8_ErrorState;	
}
    20cc:	81 11       	cpse	r24, r1
    20ce:	1c c0       	rjmp	.+56     	; 0x2108 <UART_Init+0x3c>
    20d0:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <UART_CH_0_BaudRate>
    20d4:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <UART_CH_0_BaudRate+0x1>
    20d8:	8f 3f       	cpi	r24, 0xFF	; 255
    20da:	91 05       	cpc	r25, r1
    20dc:	09 f0       	breq	.+2      	; 0x20e0 <UART_Init+0x14>
    20de:	b0 f4       	brcc	.+44     	; 0x210c <UART_Init+0x40>
    20e0:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <UART_CH_0_CONTROL>
    20e4:	8a b9       	out	0x0a, r24	; 10
    20e6:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <UART_CH_0_CONTROL_2>
    20ea:	80 bd       	out	0x20, r24	; 32
    20ec:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <UART_CH_0_BaudRate>
    20f0:	89 b9       	out	0x09, r24	; 9
    20f2:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <UART_CH_0_BaudRate>
    20f6:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <UART_CH_0_BaudRate+0x1>
    20fa:	8f 3f       	cpi	r24, 0xFF	; 255
    20fc:	91 05       	cpc	r25, r1
    20fe:	41 f0       	breq	.+16     	; 0x2110 <UART_Init+0x44>
    2100:	38 f0       	brcs	.+14     	; 0x2110 <UART_Init+0x44>
    2102:	90 bd       	out	0x20, r25	; 32
    2104:	80 e0       	ldi	r24, 0x00	; 0
    2106:	08 95       	ret
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	08 95       	ret
    210c:	81 e0       	ldi	r24, 0x01	; 1
    210e:	08 95       	ret
    2110:	80 e0       	ldi	r24, 0x00	; 0
    2112:	08 95       	ret

00002114 <UART_EnableInterrupt>:
    2114:	60 38       	cpi	r22, 0x80	; 128
    2116:	11 f0       	breq	.+4      	; 0x211c <UART_EnableInterrupt+0x8>
    2118:	60 34       	cpi	r22, 0x40	; 64
    211a:	39 f4       	brne	.+14     	; 0x212a <UART_EnableInterrupt+0x16>
    211c:	81 11       	cpse	r24, r1
    211e:	07 c0       	rjmp	.+14     	; 0x212e <UART_EnableInterrupt+0x1a>
    2120:	8a b1       	in	r24, 0x0a	; 10
    2122:	68 2b       	or	r22, r24
    2124:	6a b9       	out	0x0a, r22	; 10
    2126:	80 e0       	ldi	r24, 0x00	; 0
    2128:	08 95       	ret
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	08 95       	ret
    212e:	83 e0       	ldi	r24, 0x03	; 3
    2130:	08 95       	ret

00002132 <UART_SetCallback>:
    2132:	cf 93       	push	r28
    2134:	df 93       	push	r29
    2136:	1f 92       	push	r1
    2138:	cd b7       	in	r28, 0x3d	; 61
    213a:	de b7       	in	r29, 0x3e	; 62
    213c:	41 15       	cp	r20, r1
    213e:	51 05       	cpc	r21, r1
    2140:	c1 f0       	breq	.+48     	; 0x2172 <UART_SetCallback+0x40>
    2142:	60 38       	cpi	r22, 0x80	; 128
    2144:	11 f0       	breq	.+4      	; 0x214a <UART_SetCallback+0x18>
    2146:	60 34       	cpi	r22, 0x40	; 64
    2148:	b1 f4       	brne	.+44     	; 0x2176 <UART_SetCallback+0x44>
    214a:	81 11       	cpse	r24, r1
    214c:	16 c0       	rjmp	.+44     	; 0x217a <UART_SetCallback+0x48>
    214e:	19 82       	std	Y+1, r1	; 0x01
    2150:	60 34       	cpi	r22, 0x40	; 64
    2152:	19 f4       	brne	.+6      	; 0x215a <UART_SetCallback+0x28>
    2154:	89 81       	ldd	r24, Y+1	; 0x01
    2156:	80 e0       	ldi	r24, 0x00	; 0
    2158:	13 c0       	rjmp	.+38     	; 0x2180 <UART_SetCallback+0x4e>
    215a:	60 38       	cpi	r22, 0x80	; 128
    215c:	81 f4       	brne	.+32     	; 0x217e <UART_SetCallback+0x4c>
    215e:	e9 81       	ldd	r30, Y+1	; 0x01
    2160:	f0 e0       	ldi	r31, 0x00	; 0
    2162:	ee 0f       	add	r30, r30
    2164:	ff 1f       	adc	r31, r31
    2166:	ec 5e       	subi	r30, 0xEC	; 236
    2168:	f9 4f       	sbci	r31, 0xF9	; 249
    216a:	51 83       	std	Z+1, r21	; 0x01
    216c:	40 83       	st	Z, r20
    216e:	80 e0       	ldi	r24, 0x00	; 0
    2170:	07 c0       	rjmp	.+14     	; 0x2180 <UART_SetCallback+0x4e>
    2172:	82 e0       	ldi	r24, 0x02	; 2
    2174:	05 c0       	rjmp	.+10     	; 0x2180 <UART_SetCallback+0x4e>
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	03 c0       	rjmp	.+6      	; 0x2180 <UART_SetCallback+0x4e>
    217a:	83 e0       	ldi	r24, 0x03	; 3
    217c:	01 c0       	rjmp	.+2      	; 0x2180 <UART_SetCallback+0x4e>
    217e:	81 e0       	ldi	r24, 0x01	; 1
    2180:	0f 90       	pop	r0
    2182:	df 91       	pop	r29
    2184:	cf 91       	pop	r28
    2186:	08 95       	ret

00002188 <UART_SetData>:
    2188:	6c b9       	out	0x0c, r22	; 12
    218a:	80 e0       	ldi	r24, 0x00	; 0
    218c:	08 95       	ret

0000218e <UART_GetData>:
    218e:	8c b1       	in	r24, 0x0c	; 12
    2190:	fb 01       	movw	r30, r22
    2192:	80 83       	st	Z, r24
    2194:	80 e0       	ldi	r24, 0x00	; 0
    2196:	08 95       	ret

00002198 <UART_SetBaudRate>:
    2198:	81 11       	cpse	r24, r1
    219a:	3f c0       	rjmp	.+126    	; 0x221a <UART_SetBaudRate+0x82>
    219c:	41 15       	cp	r20, r1
    219e:	86 e9       	ldi	r24, 0x96	; 150
    21a0:	58 07       	cpc	r21, r24
    21a2:	61 05       	cpc	r22, r1
    21a4:	71 05       	cpc	r23, r1
    21a6:	49 f1       	breq	.+82     	; 0x21fa <UART_SetBaudRate+0x62>
    21a8:	60 f4       	brcc	.+24     	; 0x21c2 <UART_SetBaudRate+0x2a>
    21aa:	40 38       	cpi	r20, 0x80	; 128
    21ac:	85 e2       	ldi	r24, 0x25	; 37
    21ae:	58 07       	cpc	r21, r24
    21b0:	61 05       	cpc	r22, r1
    21b2:	71 05       	cpc	r23, r1
    21b4:	d1 f0       	breq	.+52     	; 0x21ea <UART_SetBaudRate+0x52>
    21b6:	41 15       	cp	r20, r1
    21b8:	5b 44       	sbci	r21, 0x4B	; 75
    21ba:	61 05       	cpc	r22, r1
    21bc:	71 05       	cpc	r23, r1
    21be:	c9 f0       	breq	.+50     	; 0x21f2 <UART_SetBaudRate+0x5a>
    21c0:	2e c0       	rjmp	.+92     	; 0x221e <UART_SetBaudRate+0x86>
    21c2:	41 15       	cp	r20, r1
    21c4:	82 ec       	ldi	r24, 0xC2	; 194
    21c6:	58 07       	cpc	r21, r24
    21c8:	81 e0       	ldi	r24, 0x01	; 1
    21ca:	68 07       	cpc	r22, r24
    21cc:	71 05       	cpc	r23, r1
    21ce:	e9 f0       	breq	.+58     	; 0x220a <UART_SetBaudRate+0x72>
    21d0:	41 15       	cp	r20, r1
    21d2:	84 e8       	ldi	r24, 0x84	; 132
    21d4:	58 07       	cpc	r21, r24
    21d6:	83 e0       	ldi	r24, 0x03	; 3
    21d8:	68 07       	cpc	r22, r24
    21da:	71 05       	cpc	r23, r1
    21dc:	d1 f0       	breq	.+52     	; 0x2212 <UART_SetBaudRate+0x7a>
    21de:	41 15       	cp	r20, r1
    21e0:	51 4e       	sbci	r21, 0xE1	; 225
    21e2:	61 05       	cpc	r22, r1
    21e4:	71 05       	cpc	r23, r1
    21e6:	d9 f4       	brne	.+54     	; 0x221e <UART_SetBaudRate+0x86>
    21e8:	0c c0       	rjmp	.+24     	; 0x2202 <UART_SetBaudRate+0x6a>
    21ea:	87 e6       	ldi	r24, 0x67	; 103
    21ec:	89 b9       	out	0x09, r24	; 9
    21ee:	80 e0       	ldi	r24, 0x00	; 0
    21f0:	08 95       	ret
    21f2:	83 e3       	ldi	r24, 0x33	; 51
    21f4:	89 b9       	out	0x09, r24	; 9
    21f6:	80 e0       	ldi	r24, 0x00	; 0
    21f8:	08 95       	ret
    21fa:	89 e1       	ldi	r24, 0x19	; 25
    21fc:	89 b9       	out	0x09, r24	; 9
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	08 95       	ret
    2202:	80 e1       	ldi	r24, 0x10	; 16
    2204:	89 b9       	out	0x09, r24	; 9
    2206:	80 e0       	ldi	r24, 0x00	; 0
    2208:	08 95       	ret
    220a:	88 e0       	ldi	r24, 0x08	; 8
    220c:	89 b9       	out	0x09, r24	; 9
    220e:	80 e0       	ldi	r24, 0x00	; 0
    2210:	08 95       	ret
    2212:	83 e0       	ldi	r24, 0x03	; 3
    2214:	89 b9       	out	0x09, r24	; 9
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	08 95       	ret
    221a:	83 e0       	ldi	r24, 0x03	; 3
    221c:	08 95       	ret
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	08 95       	ret

00002222 <UART_IsDataAvailableToWrite>:
ERROR_STATE_t UART_IsDataAvailableToWrite(uint8_t UARTNumber)
{
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	switch (UARTNumber)
    2222:	81 11       	cpse	r24, r1
    2224:	03 c0       	rjmp	.+6      	; 0x222c <UART_IsDataAvailableToWrite+0xa>
	{
		case UART_CH_0:
			if(BIT_GET(UCSRA,UDRE))
    2226:	5d 9b       	sbis	0x0b, 5	; 11
    2228:	03 c0       	rjmp	.+6      	; 0x2230 <UART_IsDataAvailableToWrite+0xe>
    222a:	08 95       	ret
			{
				u8_ErrorState= ERROR_NOK;
			}
			break;			
		default:
			u8_ErrorState=ERROR_UNSUPPORTED_CH;
    222c:	83 e0       	ldi	r24, 0x03	; 3
    222e:	08 95       	ret
			{
				u8_ErrorState= ERROR_OK;
			}
			else
			{
				u8_ErrorState= ERROR_NOK;
    2230:	81 e0       	ldi	r24, 0x01	; 1
		default:
			u8_ErrorState=ERROR_UNSUPPORTED_CH;
			break;
	}
	return u8_ErrorState;		
}
    2232:	08 95       	ret

00002234 <__vector_13>:

void __vector_13 (void) __attribute__ ((signal));
void __vector_13 (void)
{
    2234:	1f 92       	push	r1
    2236:	0f 92       	push	r0
    2238:	0f b6       	in	r0, 0x3f	; 63
    223a:	0f 92       	push	r0
    223c:	11 24       	eor	r1, r1
    223e:	2f 93       	push	r18
    2240:	3f 93       	push	r19
    2242:	4f 93       	push	r20
    2244:	5f 93       	push	r21
    2246:	6f 93       	push	r22
    2248:	7f 93       	push	r23
    224a:	8f 93       	push	r24
    224c:	9f 93       	push	r25
    224e:	af 93       	push	r26
    2250:	bf 93       	push	r27
    2252:	ef 93       	push	r30
    2254:	ff 93       	push	r31
	g_RxCallback[UART_CH_0]();
    2256:	e0 91 14 06 	lds	r30, 0x0614	; 0x800614 <g_RxCallback>
    225a:	f0 91 15 06 	lds	r31, 0x0615	; 0x800615 <g_RxCallback+0x1>
    225e:	09 95       	icall
    2260:	ff 91       	pop	r31
    2262:	ef 91       	pop	r30
    2264:	bf 91       	pop	r27
    2266:	af 91       	pop	r26
    2268:	9f 91       	pop	r25
    226a:	8f 91       	pop	r24
    226c:	7f 91       	pop	r23
    226e:	6f 91       	pop	r22
    2270:	5f 91       	pop	r21
    2272:	4f 91       	pop	r20
    2274:	3f 91       	pop	r19
    2276:	2f 91       	pop	r18
    2278:	0f 90       	pop	r0
    227a:	0f be       	out	0x3f, r0	; 63
    227c:	0f 90       	pop	r0
    227e:	1f 90       	pop	r1
    2280:	18 95       	reti

00002282 <BT_Mng_InsertMAC>:
* @brief: This function Extract MAC from scaned data.
*/
/******************************************************************************/
static void BT_Mng_InsertMAC(uint8_t StartIndex,ptr_uint8_t DeviceDataPacket,ptr_uint8_t ExtractedMac)
{
		uint8_t u8_ExtractedMAC_counter=ZERO;
    2282:	20 e0       	ldi	r18, 0x00	; 0
		uint8_t u8_DeviceDataCounter=StartIndex;

		while(END_OF_STRING!=ExtractedMac[u8_ExtractedMAC_counter])
    2284:	0a c0       	rjmp	.+20     	; 0x229a <BT_Mng_InsertMAC+0x18>
		{
			if(COMMA==ExtractedMac[u8_ExtractedMAC_counter])
    2286:	9c 32       	cpi	r25, 0x2C	; 44
    2288:	11 f4       	brne	.+4      	; 0x228e <BT_Mng_InsertMAC+0xc>
			{
				u8_ExtractedMAC_counter++;
    228a:	2f 5f       	subi	r18, 0xFF	; 255
    228c:	06 c0       	rjmp	.+12     	; 0x229a <BT_Mng_InsertMAC+0x18>
			}
			else
			{
				DeviceDataPacket[u8_DeviceDataCounter]=ExtractedMac[u8_ExtractedMAC_counter];
    228e:	fb 01       	movw	r30, r22
    2290:	e8 0f       	add	r30, r24
    2292:	f1 1d       	adc	r31, r1
    2294:	90 83       	st	Z, r25
				u8_ExtractedMAC_counter++;
    2296:	2f 5f       	subi	r18, 0xFF	; 255
				u8_DeviceDataCounter++;
    2298:	8f 5f       	subi	r24, 0xFF	; 255
static void BT_Mng_InsertMAC(uint8_t StartIndex,ptr_uint8_t DeviceDataPacket,ptr_uint8_t ExtractedMac)
{
		uint8_t u8_ExtractedMAC_counter=ZERO;
		uint8_t u8_DeviceDataCounter=StartIndex;

		while(END_OF_STRING!=ExtractedMac[u8_ExtractedMAC_counter])
    229a:	fa 01       	movw	r30, r20
    229c:	e2 0f       	add	r30, r18
    229e:	f1 1d       	adc	r31, r1
    22a0:	90 81       	ld	r25, Z
    22a2:	91 11       	cpse	r25, r1
    22a4:	f0 cf       	rjmp	.-32     	; 0x2286 <BT_Mng_InsertMAC+0x4>
				u8_ExtractedMAC_counter++;
				u8_DeviceDataCounter++;

			}
		}
		DeviceDataPacket[u8_DeviceDataCounter]=END_OF_STRING;
    22a6:	fb 01       	movw	r30, r22
    22a8:	e8 0f       	add	r30, r24
    22aa:	f1 1d       	adc	r31, r1
    22ac:	10 82       	st	Z, r1
    22ae:	08 95       	ret

000022b0 <BT_Mng_ExtractMAC>:
}
static ERROR_STATE_t BT_Mng_ExtractMAC(ptr_uint8_t ScanedMAC,ptr_uint8_t MACBuffer)
{
    22b0:	ac 01       	movw	r20, r24
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	uint8_t u8_ScanedMAC_counter=BLUETOOTH_START_OF_MAC;
    uint8_t u8_BufferCounter=ZERO;
    22b2:	30 e0       	ldi	r19, 0x00	; 0
		DeviceDataPacket[u8_DeviceDataCounter]=END_OF_STRING;
}
static ERROR_STATE_t BT_Mng_ExtractMAC(ptr_uint8_t ScanedMAC,ptr_uint8_t MACBuffer)
{
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	uint8_t u8_ScanedMAC_counter=BLUETOOTH_START_OF_MAC;
    22b4:	25 e0       	ldi	r18, 0x05	; 5
    uint8_t u8_BufferCounter=ZERO;

    while(COMMA!=ScanedMAC[u8_ScanedMAC_counter])
    22b6:	0e c0       	rjmp	.+28     	; 0x22d4 <BT_Mng_ExtractMAC+0x24>
    {
        if(COLON!=ScanedMAC[u8_ScanedMAC_counter])
    22b8:	9a 33       	cpi	r25, 0x3A	; 58
    22ba:	29 f0       	breq	.+10     	; 0x22c6 <BT_Mng_ExtractMAC+0x16>
        {
            MACBuffer[u8_BufferCounter]=ScanedMAC[u8_ScanedMAC_counter];
    22bc:	fb 01       	movw	r30, r22
    22be:	e3 0f       	add	r30, r19
    22c0:	f1 1d       	adc	r31, r1
    22c2:	90 83       	st	Z, r25
    22c4:	05 c0       	rjmp	.+10     	; 0x22d0 <BT_Mng_ExtractMAC+0x20>

        }
        else
        {
             MACBuffer[u8_BufferCounter]=COMMA;
    22c6:	8c e2       	ldi	r24, 0x2C	; 44
    22c8:	fb 01       	movw	r30, r22
    22ca:	e3 0f       	add	r30, r19
    22cc:	f1 1d       	adc	r31, r1
    22ce:	80 83       	st	Z, r24

        }
        u8_ScanedMAC_counter++;
    22d0:	2f 5f       	subi	r18, 0xFF	; 255
        u8_BufferCounter++;
    22d2:	3f 5f       	subi	r19, 0xFF	; 255
{
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	uint8_t u8_ScanedMAC_counter=BLUETOOTH_START_OF_MAC;
    uint8_t u8_BufferCounter=ZERO;

    while(COMMA!=ScanedMAC[u8_ScanedMAC_counter])
    22d4:	fa 01       	movw	r30, r20
    22d6:	e2 0f       	add	r30, r18
    22d8:	f1 1d       	adc	r31, r1
    22da:	90 81       	ld	r25, Z
    22dc:	9c 32       	cpi	r25, 0x2C	; 44
    22de:	61 f7       	brne	.-40     	; 0x22b8 <BT_Mng_ExtractMAC+0x8>

        }
        u8_ScanedMAC_counter++;
        u8_BufferCounter++;
    }
    MACBuffer[u8_BufferCounter]=END_OF_STRING;
    22e0:	fb 01       	movw	r30, r22
    22e2:	e3 0f       	add	r30, r19
    22e4:	f1 1d       	adc	r31, r1
    22e6:	10 82       	st	Z, r1
	return u8_ErrorState;
}
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	08 95       	ret

000022ec <BT_Mng_SendHandShake>:
}
/**
* @brief: This function Send handshake packet
*/
static ERROR_STATE_t BT_Mng_SendHandShake(void)
{
    22ec:	cf 93       	push	r28
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
	uint8_t u8_RetiresCounter  = ZERO;
	for(u8_RetiresCounter=ZERO;u8_RetiresCounter<BLUETOOTH_MNG_MAX_RETIRES;u8_RetiresCounter++)
    22ee:	c0 e0       	ldi	r28, 0x00	; 0
    22f0:	3c c0       	rjmp	.+120    	; 0x236a <BT_Mng_SendHandShake+0x7e>
	{
		/*Send handshake pattern*/
		while(ERROR_NOK==BLUETOOTH_SendData(BLUETOOTH_0,gu8_BLUETOOTH_HandShakePacket));/*Send and wait for the transmission complete */
    22f2:	67 e8       	ldi	r22, 0x87	; 135
    22f4:	70 e0       	ldi	r23, 0x00	; 0
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	0e 94 67 07 	call	0xece	; 0xece <BLUETOOTH_SendData>
    22fc:	81 30       	cpi	r24, 0x01	; 1
    22fe:	c9 f3       	breq	.-14     	; 0x22f2 <BT_Mng_SendHandShake+0x6>
		/*(TIMEOUT 200 ms) WITH RTOS*/
		if(BLUETOOTH_RX_COMPLETE==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)))
    2300:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	21 50       	subi	r18, 0x01	; 1
    2308:	31 09       	sbc	r19, r1
    230a:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	02 c0       	rjmp	.+4      	; 0x2316 <BT_Mng_SendHandShake+0x2a>
    2312:	95 95       	asr	r25
    2314:	87 95       	ror	r24
    2316:	2a 95       	dec	r18
    2318:	e2 f7       	brpl	.-8      	; 0x2312 <BT_Mng_SendHandShake+0x26>
    231a:	80 ff       	sbrs	r24, 0
    231c:	25 c0       	rjmp	.+74     	; 0x2368 <BT_Mng_SendHandShake+0x7c>
		{
			if(TRUE==StringCompare(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],gu8_BLUETOOTH_HandShakePacket))
    231e:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2322:	30 e0       	ldi	r19, 0x00	; 0
    2324:	21 50       	subi	r18, 0x01	; 1
    2326:	31 09       	sbc	r19, r1
    2328:	42 e3       	ldi	r20, 0x32	; 50
    232a:	42 9f       	mul	r20, r18
    232c:	c0 01       	movw	r24, r0
    232e:	43 9f       	mul	r20, r19
    2330:	90 0d       	add	r25, r0
    2332:	11 24       	eor	r1, r1
    2334:	67 e8       	ldi	r22, 0x87	; 135
    2336:	70 e0       	ldi	r23, 0x00	; 0
    2338:	8f 5c       	subi	r24, 0xCF	; 207
    233a:	99 4f       	sbci	r25, 0xF9	; 249
    233c:	56 d9       	rcall	.-3412   	; 0x15ea <StringCompare>
    233e:	81 30       	cpi	r24, 0x01	; 1
    2340:	c1 f0       	breq	.+48     	; 0x2372 <BT_Mng_SendHandShake+0x86>
			}
			else
			{
				/*Do nothing*/
			}		
			CLR_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE));			
    2342:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2346:	30 e0       	ldi	r19, 0x00	; 0
    2348:	21 50       	subi	r18, 0x01	; 1
    234a:	31 09       	sbc	r19, r1
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	90 e0       	ldi	r25, 0x00	; 0
    2350:	02 c0       	rjmp	.+4      	; 0x2356 <BT_Mng_SendHandShake+0x6a>
    2352:	88 0f       	add	r24, r24
    2354:	99 1f       	adc	r25, r25
    2356:	2a 95       	dec	r18
    2358:	e2 f7       	brpl	.-8      	; 0x2352 <BT_Mng_SendHandShake+0x66>
    235a:	80 95       	com	r24
    235c:	90 95       	com	r25
    235e:	90 91 1c 06 	lds	r25, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    2362:	89 23       	and	r24, r25
    2364:	80 93 1c 06 	sts	0x061C, r24	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
*/
static ERROR_STATE_t BT_Mng_SendHandShake(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
	uint8_t u8_RetiresCounter  = ZERO;
	for(u8_RetiresCounter=ZERO;u8_RetiresCounter<BLUETOOTH_MNG_MAX_RETIRES;u8_RetiresCounter++)
    2368:	cf 5f       	subi	r28, 0xFF	; 255
    236a:	c5 30       	cpi	r28, 0x05	; 5
    236c:	10 f2       	brcs	.-124    	; 0x22f2 <BT_Mng_SendHandShake+0x6>
/**
* @brief: This function Send handshake packet
*/
static ERROR_STATE_t BT_Mng_SendHandShake(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	01 c0       	rjmp	.+2      	; 0x2374 <BT_Mng_SendHandShake+0x88>
		/*(TIMEOUT 200 ms) WITH RTOS*/
		if(BLUETOOTH_RX_COMPLETE==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)))
		{
			if(TRUE==StringCompare(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],gu8_BLUETOOTH_HandShakePacket))
			{
				u8_ErrorState = ERROR_OK;
    2372:	80 e0       	ldi	r24, 0x00	; 0
				/*Do nothing*/
		}
				
	}
	return u8_ErrorState;	
}
    2374:	cf 91       	pop	r28
    2376:	08 95       	ret

00002378 <BLUETOOTH_Mng_RxCallback>:
/**
* @brief: This function make a selftest.
*/
static void BLUETOOTH_Mng_RxCallback(void)
{
	if(BLUETOOTH_RX_ARRAY_SIZE==gu8_RX_Buffer_Counter)
    2378:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    237c:	88 30       	cpi	r24, 0x08	; 8
    237e:	29 f4       	brne	.+10     	; 0x238a <BLUETOOTH_Mng_RxCallback+0x12>
	{
		gu8_RX_Buffer_Counter=BLUETOOTH_INQ_DEVICES_NUMBERS;
    2380:	82 e0       	ldi	r24, 0x02	; 2
    2382:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <gu8_RX_Buffer_Counter>
		gu8_BLUETOOTH_RXCOM_FLAG=ZERO;
    2386:	10 92 1c 06 	sts	0x061C, r1	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
	}
	/*check if the receive has been done*/
	if(ERROR_OK==BLUETOOTH_ReceiveData(BLUETOOTH_0,gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter]))
    238a:	60 91 90 00 	lds	r22, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    238e:	82 e3       	ldi	r24, 0x32	; 50
    2390:	68 9f       	mul	r22, r24
    2392:	b0 01       	movw	r22, r0
    2394:	11 24       	eor	r1, r1
    2396:	6f 5c       	subi	r22, 0xCF	; 207
    2398:	79 4f       	sbci	r23, 0xF9	; 249
    239a:	80 e0       	ldi	r24, 0x00	; 0
    239c:	0e 94 a2 07 	call	0xf44	; 0xf44 <BLUETOOTH_ReceiveData>
    23a0:	81 11       	cpse	r24, r1
    23a2:	13 c0       	rjmp	.+38     	; 0x23ca <BLUETOOTH_Mng_RxCallback+0x52>
	{
		/*Set the flag for the current buffer*/
		SET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,gu8_RX_Buffer_Counter);
    23a4:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	02 c0       	rjmp	.+4      	; 0x23b2 <BLUETOOTH_Mng_RxCallback+0x3a>
    23ae:	88 0f       	add	r24, r24
    23b0:	99 1f       	adc	r25, r25
    23b2:	2a 95       	dec	r18
    23b4:	e2 f7       	brpl	.-8      	; 0x23ae <BLUETOOTH_Mng_RxCallback+0x36>
    23b6:	90 91 1c 06 	lds	r25, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    23ba:	89 2b       	or	r24, r25
    23bc:	80 93 1c 06 	sts	0x061C, r24	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
		/*increament the counter*/
		gu8_RX_Buffer_Counter++;
    23c0:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    23c4:	8f 5f       	subi	r24, 0xFF	; 255
    23c6:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <gu8_RX_Buffer_Counter>
    23ca:	08 95       	ret

000023cc <BT_Mng_SelfTest>:
static ERROR_STATE_t BT_Mng_SelfTest(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	ERROR_STATE_t u8_BaudCounter = ZERO;
	/*First check if the bluetooth is already configured to the desired*/
	UART_SetBaudRate((gastr_BLUETOOTH_Config[BLUETOOTH_0].u8_BLUETOOTH_UART_CH),
    23cc:	40 91 18 01 	lds	r20, 0x0118	; 0x800118 <gastr_BLUETOOTH_Mng_Config+0xb>
    23d0:	50 91 19 01 	lds	r21, 0x0119	; 0x800119 <gastr_BLUETOOTH_Mng_Config+0xc>
    23d4:	60 91 1a 01 	lds	r22, 0x011A	; 0x80011a <gastr_BLUETOOTH_Mng_Config+0xd>
    23d8:	70 91 1b 01 	lds	r23, 0x011B	; 0x80011b <gastr_BLUETOOTH_Mng_Config+0xe>
    23dc:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <gastr_BLUETOOTH_Config>
    23e0:	db de       	rcall	.-586    	; 0x2198 <UART_SetBaudRate>
					(gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].STR_BLUETOOTH_Mng_BAUDRATE_Cng.u32_UART_BUADRATE));
	/*Send AT to bluetooth*/					
	BLUETOOTH_ATModeGetCommand(BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_AT);
    23e2:	64 eb       	ldi	r22, 0xB4	; 180
    23e4:	70 e0       	ldi	r23, 0x00	; 0
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	0e 94 d5 07 	call	0xfaa	; 0xfaa <BLUETOOTH_ATModeGetCommand>
	/*Wait for flag to set or for timeout*/
	vTaskDelayUntil(&g_BluetoothLastWakeTime, 1000);
    23ec:	68 ee       	ldi	r22, 0xE8	; 232
    23ee:	73 e0       	ldi	r23, 0x03	; 3
    23f0:	8a e1       	ldi	r24, 0x1A	; 26
    23f2:	96 e0       	ldi	r25, 0x06	; 6
    23f4:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
	{
		/*Do Nothing*/
	}
   #endif
	return u8_ErrorState;
}
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	08 95       	ret

000023fc <BT_Mng_SetConfig>:
static ERROR_STATE_t BT_Mng_SetConfig(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_OK;
	
	//NAME
	while(ERROR_OK!=BLUETOOTH_ATModeGetCommand(	BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_GET_NAME));
    23fc:	67 eb       	ldi	r22, 0xB7	; 183
    23fe:	70 e0       	ldi	r23, 0x00	; 0
    2400:	80 e0       	ldi	r24, 0x00	; 0
    2402:	0e 94 d5 07 	call	0xfaa	; 0xfaa <BLUETOOTH_ATModeGetCommand>
    2406:	81 11       	cpse	r24, r1
    2408:	f9 cf       	rjmp	.-14     	; 0x23fc <BT_Mng_SetConfig>
	while(BLUETOOTH_RX_PENDING==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)));
    240a:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    240e:	30 e0       	ldi	r19, 0x00	; 0
    2410:	21 50       	subi	r18, 0x01	; 1
    2412:	31 09       	sbc	r19, r1
    2414:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <BT_Mng_SetConfig+0x24>
    241c:	95 95       	asr	r25
    241e:	87 95       	ror	r24
    2420:	2a 95       	dec	r18
    2422:	e2 f7       	brpl	.-8      	; 0x241c <BT_Mng_SetConfig+0x20>
    2424:	80 ff       	sbrs	r24, 0
    2426:	f1 cf       	rjmp	.-30     	; 0x240a <BT_Mng_SetConfig+0xe>
	if(TRUE!=StringCompare(	gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],
    2428:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    242c:	30 e0       	ldi	r19, 0x00	; 0
    242e:	21 50       	subi	r18, 0x01	; 1
    2430:	31 09       	sbc	r19, r1
    2432:	42 e3       	ldi	r20, 0x32	; 50
    2434:	42 9f       	mul	r20, r18
    2436:	c0 01       	movw	r24, r0
    2438:	43 9f       	mul	r20, r19
    243a:	90 0d       	add	r25, r0
    243c:	11 24       	eor	r1, r1
    243e:	6e e1       	ldi	r22, 0x1E	; 30
    2440:	71 e0       	ldi	r23, 0x01	; 1
    2442:	8f 5c       	subi	r24, 0xCF	; 207
    2444:	99 4f       	sbci	r25, 0xF9	; 249
    2446:	d1 d8       	rcall	.-3678   	; 0x15ea <StringCompare>
    2448:	81 30       	cpi	r24, 0x01	; 1
    244a:	49 f0       	breq	.+18     	; 0x245e <BT_Mng_SetConfig+0x62>
								gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].au8_BLUETOOTH_Mng_NAME))
	{
		while(ERROR_OK!=BLUETOOTH_ATModeSetCommand(	BLUETOOTH_0,
    244c:	4e e1       	ldi	r20, 0x1E	; 30
    244e:	51 e0       	ldi	r21, 0x01	; 1
    2450:	60 ec       	ldi	r22, 0xC0	; 192
    2452:	70 e0       	ldi	r23, 0x00	; 0
    2454:	80 e0       	ldi	r24, 0x00	; 0
    2456:	0e 94 36 08 	call	0x106c	; 0x106c <BLUETOOTH_ATModeSetCommand>
    245a:	81 11       	cpse	r24, r1
    245c:	f7 cf       	rjmp	.-18     	; 0x244c <BT_Mng_SetConfig+0x50>
													gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].au8_BLUETOOTH_Mng_NAME
													)
			);	
	}
	//ROLE
	while(ERROR_OK!=BLUETOOTH_ATModeGetCommand(	BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_GET_ROLE));
    245e:	69 ec       	ldi	r22, 0xC9	; 201
    2460:	70 e0       	ldi	r23, 0x00	; 0
    2462:	80 e0       	ldi	r24, 0x00	; 0
    2464:	0e 94 d5 07 	call	0xfaa	; 0xfaa <BLUETOOTH_ATModeGetCommand>
    2468:	81 11       	cpse	r24, r1
    246a:	f9 cf       	rjmp	.-14     	; 0x245e <BT_Mng_SetConfig+0x62>
	while(BLUETOOTH_RX_PENDING==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)));
    246c:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2470:	30 e0       	ldi	r19, 0x00	; 0
    2472:	21 50       	subi	r18, 0x01	; 1
    2474:	31 09       	sbc	r19, r1
    2476:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	02 c0       	rjmp	.+4      	; 0x2482 <BT_Mng_SetConfig+0x86>
    247e:	95 95       	asr	r25
    2480:	87 95       	ror	r24
    2482:	2a 95       	dec	r18
    2484:	e2 f7       	brpl	.-8      	; 0x247e <BT_Mng_SetConfig+0x82>
    2486:	80 ff       	sbrs	r24, 0
    2488:	f1 cf       	rjmp	.-30     	; 0x246c <BT_Mng_SetConfig+0x70>
	if(TRUE!=StringCompare(	gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],
    248a:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    248e:	30 e0       	ldi	r19, 0x00	; 0
    2490:	21 50       	subi	r18, 0x01	; 1
    2492:	31 09       	sbc	r19, r1
    2494:	42 e3       	ldi	r20, 0x32	; 50
    2496:	42 9f       	mul	r20, r18
    2498:	c0 01       	movw	r24, r0
    249a:	43 9f       	mul	r20, r19
    249c:	90 0d       	add	r25, r0
    249e:	11 24       	eor	r1, r1
    24a0:	60 91 1c 01 	lds	r22, 0x011C	; 0x80011c <gastr_BLUETOOTH_Mng_Config+0xf>
    24a4:	70 91 1d 01 	lds	r23, 0x011D	; 0x80011d <gastr_BLUETOOTH_Mng_Config+0x10>
    24a8:	8f 5c       	subi	r24, 0xCF	; 207
    24aa:	99 4f       	sbci	r25, 0xF9	; 249
    24ac:	9e d8       	rcall	.-3780   	; 0x15ea <StringCompare>
    24ae:	81 30       	cpi	r24, 0x01	; 1
    24b0:	59 f0       	breq	.+22     	; 0x24c8 <BT_Mng_SetConfig+0xcc>
								gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].u8_BLUETOOTH_Mng_MODE))
	{
		while(ERROR_OK!=BLUETOOTH_ATModeSetCommand(	BLUETOOTH_0,
    24b2:	40 91 1c 01 	lds	r20, 0x011C	; 0x80011c <gastr_BLUETOOTH_Mng_Config+0xf>
    24b6:	50 91 1d 01 	lds	r21, 0x011D	; 0x80011d <gastr_BLUETOOTH_Mng_Config+0x10>
    24ba:	62 ed       	ldi	r22, 0xD2	; 210
    24bc:	70 e0       	ldi	r23, 0x00	; 0
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	0e 94 36 08 	call	0x106c	; 0x106c <BLUETOOTH_ATModeSetCommand>
    24c4:	81 11       	cpse	r24, r1
    24c6:	f5 cf       	rjmp	.-22     	; 0x24b2 <BT_Mng_SetConfig+0xb6>
													)
			);	
	}
	
	//PIN
	while(ERROR_OK!=BLUETOOTH_ATModeGetCommand(	BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_GET_PSWD));
    24c8:	6b ed       	ldi	r22, 0xDB	; 219
    24ca:	70 e0       	ldi	r23, 0x00	; 0
    24cc:	80 e0       	ldi	r24, 0x00	; 0
    24ce:	0e 94 d5 07 	call	0xfaa	; 0xfaa <BLUETOOTH_ATModeGetCommand>
    24d2:	81 11       	cpse	r24, r1
    24d4:	f9 cf       	rjmp	.-14     	; 0x24c8 <BT_Mng_SetConfig+0xcc>
	while(BLUETOOTH_RX_PENDING==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)));
    24d6:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    24da:	30 e0       	ldi	r19, 0x00	; 0
    24dc:	21 50       	subi	r18, 0x01	; 1
    24de:	31 09       	sbc	r19, r1
    24e0:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    24e4:	90 e0       	ldi	r25, 0x00	; 0
    24e6:	02 c0       	rjmp	.+4      	; 0x24ec <BT_Mng_SetConfig+0xf0>
    24e8:	95 95       	asr	r25
    24ea:	87 95       	ror	r24
    24ec:	2a 95       	dec	r18
    24ee:	e2 f7       	brpl	.-8      	; 0x24e8 <BT_Mng_SetConfig+0xec>
    24f0:	80 ff       	sbrs	r24, 0
    24f2:	f1 cf       	rjmp	.-30     	; 0x24d6 <BT_Mng_SetConfig+0xda>
	if(TRUE!=StringCompare(	gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],
    24f4:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    24f8:	30 e0       	ldi	r19, 0x00	; 0
    24fa:	21 50       	subi	r18, 0x01	; 1
    24fc:	31 09       	sbc	r19, r1
    24fe:	42 e3       	ldi	r20, 0x32	; 50
    2500:	42 9f       	mul	r20, r18
    2502:	c0 01       	movw	r24, r0
    2504:	43 9f       	mul	r20, r19
    2506:	90 0d       	add	r25, r0
    2508:	11 24       	eor	r1, r1
    250a:	68 e2       	ldi	r22, 0x28	; 40
    250c:	71 e0       	ldi	r23, 0x01	; 1
    250e:	8f 5c       	subi	r24, 0xCF	; 207
    2510:	99 4f       	sbci	r25, 0xF9	; 249
    2512:	6b d8       	rcall	.-3882   	; 0x15ea <StringCompare>
    2514:	81 30       	cpi	r24, 0x01	; 1
    2516:	49 f0       	breq	.+18     	; 0x252a <BT_Mng_SetConfig+0x12e>
								gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].au8_BLUETOOTH_Mng_PASSWORD))
	{
		while(ERROR_OK!=BLUETOOTH_ATModeSetCommand(	BLUETOOTH_0,
    2518:	48 e2       	ldi	r20, 0x28	; 40
    251a:	51 e0       	ldi	r21, 0x01	; 1
    251c:	64 ee       	ldi	r22, 0xE4	; 228
    251e:	70 e0       	ldi	r23, 0x00	; 0
    2520:	80 e0       	ldi	r24, 0x00	; 0
    2522:	0e 94 36 08 	call	0x106c	; 0x106c <BLUETOOTH_ATModeSetCommand>
    2526:	81 11       	cpse	r24, r1
    2528:	f7 cf       	rjmp	.-18     	; 0x2518 <BT_Mng_SetConfig+0x11c>
													gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].au8_BLUETOOTH_Mng_PASSWORD
													)
			);	
	}
	/*Send at cmd to get the bluetooth mac address*/
	while(ERROR_OK!=BLUETOOTH_ATModeGetCommand(	BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_GET_ADD));
    252a:	6d ee       	ldi	r22, 0xED	; 237
    252c:	70 e0       	ldi	r23, 0x00	; 0
    252e:	80 e0       	ldi	r24, 0x00	; 0
    2530:	0e 94 d5 07 	call	0xfaa	; 0xfaa <BLUETOOTH_ATModeGetCommand>
    2534:	81 11       	cpse	r24, r1
    2536:	f9 cf       	rjmp	.-14     	; 0x252a <BT_Mng_SetConfig+0x12e>
	/*wiat for the flag to set*/
	while(BLUETOOTH_RX_PENDING==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)));
    2538:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    253c:	30 e0       	ldi	r19, 0x00	; 0
    253e:	21 50       	subi	r18, 0x01	; 1
    2540:	31 09       	sbc	r19, r1
    2542:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	02 c0       	rjmp	.+4      	; 0x254e <BT_Mng_SetConfig+0x152>
    254a:	95 95       	asr	r25
    254c:	87 95       	ror	r24
    254e:	2a 95       	dec	r18
    2550:	e2 f7       	brpl	.-8      	; 0x254a <BT_Mng_SetConfig+0x14e>
    2552:	80 ff       	sbrs	r24, 0
    2554:	f1 cf       	rjmp	.-30     	; 0x2538 <BT_Mng_SetConfig+0x13c>
	/*Get the address and save it in the buffer*/
	BT_Mng_ExtractMAC(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE],gu8_BLUETOOTH_MACAddressBuf);
    2556:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    255a:	30 e0       	ldi	r19, 0x00	; 0
    255c:	21 50       	subi	r18, 0x01	; 1
    255e:	31 09       	sbc	r19, r1
    2560:	42 e3       	ldi	r20, 0x32	; 50
    2562:	42 9f       	mul	r20, r18
    2564:	c0 01       	movw	r24, r0
    2566:	43 9f       	mul	r20, r19
    2568:	90 0d       	add	r25, r0
    256a:	11 24       	eor	r1, r1
    256c:	6d e1       	ldi	r22, 0x1D	; 29
    256e:	76 e0       	ldi	r23, 0x06	; 6
    2570:	8f 5c       	subi	r24, 0xCF	; 207
    2572:	99 4f       	sbci	r25, 0xF9	; 249
    2574:	9d de       	rcall	.-710    	; 0x22b0 <BT_Mng_ExtractMAC>
	/*Set the address in the packet*/
	BT_Mng_InsertMAC(BLUETOOTH_DD_PACKET_START_OF_MAC,gu8_BLUETOOTH_DeviceDataPacket,gu8_BLUETOOTH_MACAddressBuf);
    2576:	4d e1       	ldi	r20, 0x1D	; 29
    2578:	56 e0       	ldi	r21, 0x06	; 6
    257a:	6e e6       	ldi	r22, 0x6E	; 110
    257c:	70 e0       	ldi	r23, 0x00	; 0
    257e:	8a e0       	ldi	r24, 0x0A	; 10
    2580:	80 de       	rcall	.-768    	; 0x2282 <BT_Mng_InsertMAC>
	return u8_ErrorState;	
}
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	08 95       	ret

00002586 <BT_Mng_SendDeviceData>:

/**
* @brief: This function Send device data
*/
static ERROR_STATE_t BT_Mng_SendDeviceData(void)
{
    2586:	cf 93       	push	r28
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
	uint8_t u8_RetiresCounter  = ZERO;
	for(u8_RetiresCounter=ZERO;u8_RetiresCounter<BLUETOOTH_MNG_MAX_RETIRES;u8_RetiresCounter++)
    2588:	c0 e0       	ldi	r28, 0x00	; 0
    258a:	49 c0       	rjmp	.+146    	; 0x261e <BT_Mng_SendDeviceData+0x98>
	{		
		/*Send handshake pattern*/
		while(ERROR_NOK==BLUETOOTH_SendData(BLUETOOTH_0,gu8_BLUETOOTH_DeviceDataPacket));/*Send and wait for the transmission complete */
    258c:	6e e6       	ldi	r22, 0x6E	; 110
    258e:	70 e0       	ldi	r23, 0x00	; 0
    2590:	80 e0       	ldi	r24, 0x00	; 0
    2592:	0e 94 67 07 	call	0xece	; 0xece <BLUETOOTH_SendData>
    2596:	81 30       	cpi	r24, 0x01	; 1
    2598:	c9 f3       	breq	.-14     	; 0x258c <BT_Mng_SendDeviceData+0x6>
		/*(TIMEOUT 200 ms) WITH RTOS*/
		if(BLUETOOTH_RX_COMPLETE==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)))
    259a:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    259e:	30 e0       	ldi	r19, 0x00	; 0
    25a0:	21 50       	subi	r18, 0x01	; 1
    25a2:	31 09       	sbc	r19, r1
    25a4:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	02 c0       	rjmp	.+4      	; 0x25b0 <BT_Mng_SendDeviceData+0x2a>
    25ac:	95 95       	asr	r25
    25ae:	87 95       	ror	r24
    25b0:	2a 95       	dec	r18
    25b2:	e2 f7       	brpl	.-8      	; 0x25ac <BT_Mng_SendDeviceData+0x26>
    25b4:	80 ff       	sbrs	r24, 0
    25b6:	32 c0       	rjmp	.+100    	; 0x261c <BT_Mng_SendDeviceData+0x96>
		{
			if(BLUETOOTH_DD_PACKET_TYPE==gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE][BLUETOOTH_TYPE_INDEX])
    25b8:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	01 97       	sbiw	r24, 0x01	; 1
    25c0:	22 e3       	ldi	r18, 0x32	; 50
    25c2:	28 9f       	mul	r18, r24
    25c4:	f0 01       	movw	r30, r0
    25c6:	29 9f       	mul	r18, r25
    25c8:	f0 0d       	add	r31, r0
    25ca:	11 24       	eor	r1, r1
    25cc:	ef 5c       	subi	r30, 0xCF	; 207
    25ce:	f9 4f       	sbci	r31, 0xF9	; 249
    25d0:	81 81       	ldd	r24, Z+1	; 0x01
    25d2:	82 30       	cpi	r24, 0x02	; 2
    25d4:	81 f4       	brne	.+32     	; 0x25f6 <BT_Mng_SendDeviceData+0x70>
			{
				if(ERROR_OK==CRC_16_Chk(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE]))
    25d6:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    25da:	30 e0       	ldi	r19, 0x00	; 0
    25dc:	21 50       	subi	r18, 0x01	; 1
    25de:	31 09       	sbc	r19, r1
    25e0:	42 e3       	ldi	r20, 0x32	; 50
    25e2:	42 9f       	mul	r20, r18
    25e4:	c0 01       	movw	r24, r0
    25e6:	43 9f       	mul	r20, r19
    25e8:	90 0d       	add	r25, r0
    25ea:	11 24       	eor	r1, r1
    25ec:	8f 5c       	subi	r24, 0xCF	; 207
    25ee:	99 4f       	sbci	r25, 0xF9	; 249
    25f0:	07 da       	rcall	.-3058   	; 0x1a00 <CRC_16_Chk>
    25f2:	88 23       	and	r24, r24
    25f4:	c9 f0       	breq	.+50     	; 0x2628 <BT_Mng_SendDeviceData+0xa2>
			}
			else
			{
				/*Do nothing*/
			}
			CLR_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE));
    25f6:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    25fa:	30 e0       	ldi	r19, 0x00	; 0
    25fc:	21 50       	subi	r18, 0x01	; 1
    25fe:	31 09       	sbc	r19, r1
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	90 e0       	ldi	r25, 0x00	; 0
    2604:	02 c0       	rjmp	.+4      	; 0x260a <BT_Mng_SendDeviceData+0x84>
    2606:	88 0f       	add	r24, r24
    2608:	99 1f       	adc	r25, r25
    260a:	2a 95       	dec	r18
    260c:	e2 f7       	brpl	.-8      	; 0x2606 <BT_Mng_SendDeviceData+0x80>
    260e:	80 95       	com	r24
    2610:	90 95       	com	r25
    2612:	90 91 1c 06 	lds	r25, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    2616:	89 23       	and	r24, r25
    2618:	80 93 1c 06 	sts	0x061C, r24	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
*/
static ERROR_STATE_t BT_Mng_SendDeviceData(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
	uint8_t u8_RetiresCounter  = ZERO;
	for(u8_RetiresCounter=ZERO;u8_RetiresCounter<BLUETOOTH_MNG_MAX_RETIRES;u8_RetiresCounter++)
    261c:	cf 5f       	subi	r28, 0xFF	; 255
    261e:	c5 30       	cpi	r28, 0x05	; 5
    2620:	08 f4       	brcc	.+2      	; 0x2624 <BT_Mng_SendDeviceData+0x9e>
    2622:	b4 cf       	rjmp	.-152    	; 0x258c <BT_Mng_SendDeviceData+0x6>
/**
* @brief: This function Send device data
*/
static ERROR_STATE_t BT_Mng_SendDeviceData(void)
{
	ERROR_STATE_t u8_ErrorState = ERROR_NOK;
    2624:	81 e0       	ldi	r24, 0x01	; 1
    2626:	01 c0       	rjmp	.+2      	; 0x262a <BT_Mng_SendDeviceData+0xa4>
		{
			if(BLUETOOTH_DD_PACKET_TYPE==gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE][BLUETOOTH_TYPE_INDEX])
			{
				if(ERROR_OK==CRC_16_Chk(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE]))
				{
					u8_ErrorState = ERROR_OK;
    2628:	80 e0       	ldi	r24, 0x00	; 0
		{
			/*Do nothing*/
		}
	}
	return u8_ErrorState;
}
    262a:	cf 91       	pop	r28
    262c:	08 95       	ret

0000262e <BLUETOOTH_Mng_Init>:
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    static ERROR_STATE_t u8_CurrentState = BT_STATE_INIT;
	
	switch(u8_CurrentState){
    262e:	e0 91 17 06 	lds	r30, 0x0617	; 0x800617 <u8_CurrentState.2251>
    2632:	8e 2f       	mov	r24, r30
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	8b 30       	cpi	r24, 0x0B	; 11
    2638:	91 05       	cpc	r25, r1
    263a:	20 f4       	brcc	.+8      	; 0x2644 <BLUETOOTH_Mng_Init+0x16>
    263c:	fc 01       	movw	r30, r24
    263e:	e6 5d       	subi	r30, 0xD6	; 214
    2640:	ff 4f       	sbci	r31, 0xFF	; 255
    2642:	ee c4       	rjmp	.+2524   	; 0x3020 <__tablejump2__>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2644:	8b e0       	ldi	r24, 0x0B	; 11
    2646:	08 95       	ret
    static ERROR_STATE_t u8_CurrentState = BT_STATE_INIT;
	
	switch(u8_CurrentState){
		case BT_STATE_INIT:/*INIT*/
			/*Initialize the bluetooth*/
			BLUETOOTH_Init();
    2648:	0e 94 3b 07 	call	0xe76	; 0xe76 <BLUETOOTH_Init>
         vTaskDelayUntil(&g_BluetoothLastWakeTime, 200);
    264c:	68 ec       	ldi	r22, 0xC8	; 200
    264e:	70 e0       	ldi	r23, 0x00	; 0
    2650:	8a e1       	ldi	r24, 0x1A	; 26
    2652:	96 e0       	ldi	r25, 0x06	; 6
    2654:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
			/*Enable the uart rx interrupt*/
			UART_EnableInterrupt(UART_CH_0,RX_INT);
    2658:	60 e8       	ldi	r22, 0x80	; 128
    265a:	80 e0       	ldi	r24, 0x00	; 0
    265c:	5b dd       	rcall	.-1354   	; 0x2114 <UART_EnableInterrupt>
			/*Set the call back function in the uart rx isr*/
			UART_SetCallback(UART_CH_0,RX_INT,BLUETOOTH_Mng_RxCallback);
    265e:	4c eb       	ldi	r20, 0xBC	; 188
    2660:	51 e1       	ldi	r21, 0x11	; 17
    2662:	60 e8       	ldi	r22, 0x80	; 128
    2664:	80 e0       	ldi	r24, 0x00	; 0
			/*Set the global interrupt bit*/
			GLOBALINTTERUPTS_Enable();
    2666:	65 dd       	rcall	.-1334   	; 0x2132 <UART_SetCallback>
    2668:	b9 dc       	rcall	.-1678   	; 0x1fdc <GLOBALINTTERUPTS_Enable>
			/*Move to selftest state */
			u8_CurrentState=BT_STATE_SELFTEST;
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
			break;
    2670:	8b e0       	ldi	r24, 0x0B	; 11
		case BT_STATE_SELFTEST:
			if(ERROR_OK==BT_Mng_SelfTest())
    2672:	08 95       	ret
    2674:	ab de       	rcall	.-682    	; 0x23cc <BT_Mng_SelfTest>
    2676:	81 11       	cpse	r24, r1
    2678:	0e c0       	rjmp	.+28     	; 0x2696 <BLUETOOTH_Mng_Init+0x68>
			{
				
				STR_StringConcatenate(gu8_BLUETOOTH_DeviceDataPacket,gastr_BLUETOOTH_Mng_Config[BLUETOOTH_0].au8_BLUETOOTH_Mng_NAME);				
    267a:	6e e1       	ldi	r22, 0x1E	; 30
    267c:	71 e0       	ldi	r23, 0x01	; 1
    267e:	8e e6       	ldi	r24, 0x6E	; 110
    2680:	90 e0       	ldi	r25, 0x00	; 0
				BT_Mng_SetConfig();			
    2682:	0e 94 29 0b 	call	0x1652	; 0x1652 <STR_StringConcatenate>
				
				/*Set the indecator to search pattern*/
				Indicator_SetPattern(INDICATOR_SEARCH_PATTERN);
    2686:	ba de       	rcall	.-652    	; 0x23fc <BT_Mng_SetConfig>
    2688:	81 e0       	ldi	r24, 0x01	; 1
    268a:	6c d2       	rcall	.+1240   	; 0x2b64 <Indicator_SetPattern>
				/*Set state to check eeprom*/
				u8_CurrentState=BT_STATE_CHECKEEPROM;
    268c:	82 e0       	ldi	r24, 0x02	; 2
    268e:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2692:	8b e0       	ldi	r24, 0x0B	; 11
    2694:	08 95       	ret
				u8_CurrentState=BT_STATE_CHECKEEPROM;
			}
			else
			{
				/*Set state to error state*/
				u8_CurrentState=BT_STATE_ERROR;
    2696:	8a e0       	ldi	r24, 0x0A	; 10
    2698:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    269c:	8b e0       	ldi	r24, 0x0B	; 11
    269e:	08 95       	ret
					u8_CurrentState=BT_STATE_CRC16;
				}
				#endif
			break;
		case BT_STATE_CRC16:
				while(ERROR_OK!=BLUETOOTH_ATModeSetCommand(	BLUETOOTH_0,(ptr_uint8_t)BLUETOOTH_CMD_SET_INQM,(ptr_uint8_t)BLUETOOTH_INQM));
    26a0:	46 ef       	ldi	r20, 0xF6	; 246
    26a2:	50 e0       	ldi	r21, 0x00	; 0
    26a4:	6d ef       	ldi	r22, 0xFD	; 253
    26a6:	70 e0       	ldi	r23, 0x00	; 0
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	0e 94 36 08 	call	0x106c	; 0x106c <BLUETOOTH_ATModeSetCommand>
    26ae:	81 11       	cpse	r24, r1
    26b0:	f7 cf       	rjmp	.-18     	; 0x26a0 <BLUETOOTH_Mng_Init+0x72>
				if(TRUE==StringCompare((ptr_uint8_t)BLUETOOTH_OK,gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE]))
    26b2:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	01 97       	sbiw	r24, 0x01	; 1
    26ba:	22 e3       	ldi	r18, 0x32	; 50
    26bc:	28 9f       	mul	r18, r24
    26be:	b0 01       	movw	r22, r0
    26c0:	29 9f       	mul	r18, r25
    26c2:	70 0d       	add	r23, r0
    26c4:	11 24       	eor	r1, r1
    26c6:	6f 5c       	subi	r22, 0xCF	; 207
    26c8:	79 4f       	sbci	r23, 0xF9	; 249
    26ca:	86 e0       	ldi	r24, 0x06	; 6
    26cc:	91 e0       	ldi	r25, 0x01	; 1
    26ce:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <StringCompare>
    26d2:	81 30       	cpi	r24, 0x01	; 1
    26d4:	09 f0       	breq	.+2      	; 0x26d8 <BLUETOOTH_Mng_Init+0xaa>
    26d6:	ae c0       	rjmp	.+348    	; 0x2834 <BLUETOOTH_Mng_Init+0x206>
				{
					/*Calc CRC for the handshake pattern packet*/
					CRC_16_Calc(gu8_BLUETOOTH_HandShakePacket);
    26d8:	87 e8       	ldi	r24, 0x87	; 135
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	0e 94 55 0b 	call	0x16aa	; 0x16aa <CRC_16_Calc>
					/*Calc CRC for the device data pattern packet*/
					CRC_16_Calc(gu8_BLUETOOTH_DeviceDataPacket);
    26e0:	8e e6       	ldi	r24, 0x6E	; 110
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	0e 94 55 0b 	call	0x16aa	; 0x16aa <CRC_16_Calc>
					/*Calc CRC for the device data pattern packet*/
					CRC_16_Calc(gu8_BLUETOOTH_PasswordChangePacket);
    26e8:	88 e6       	ldi	r24, 0x68	; 104
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	0e 94 55 0b 	call	0x16aa	; 0x16aa <CRC_16_Calc>
					u8_CurrentState=BT_STATE_SCANNING;
    26f0:	84 e0       	ldi	r24, 0x04	; 4
    26f2:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    26f6:	8b e0       	ldi	r24, 0x0B	; 11
    26f8:	08 95       	ret
				{
					/*Do Nothing*/
				}											
				break;
		case BT_STATE_SCANNING:
				gu8_BLUETOOTH_RXCOM_FLAG=ZERO;
    26fa:	10 92 1c 06 	sts	0x061C, r1	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
				gu8_RX_Buffer_Counter=ZERO;
    26fe:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <gu8_RX_Buffer_Counter>
				s8_MAC_Counter=ZERO;
    2702:	10 92 16 06 	sts	0x0616, r1	; 0x800616 <s8_MAC_Counter.2249>
				BLUETOOTH_Scan(BLUETOOTH_0);
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	0e 94 b7 08 	call	0x116e	; 0x116e <BLUETOOTH_Scan>
				u8_CurrentState=BT_STATE_SCANNING_END;
    270c:	85 e0       	ldi	r24, 0x05	; 5
    270e:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2712:	8b e0       	ldi	r24, 0x0B	; 11
				gu8_BLUETOOTH_RXCOM_FLAG=ZERO;
				gu8_RX_Buffer_Counter=ZERO;
				s8_MAC_Counter=ZERO;
				BLUETOOTH_Scan(BLUETOOTH_0);
				u8_CurrentState=BT_STATE_SCANNING_END;
				break;
    2714:	08 95       	ret
		case BT_STATE_SCANNING_END:		
				if(BLUETOOTH_RX_COMPLETE==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,BLUETOOTH_INQ_DEVICES_NUMBERS))
    2716:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    271a:	82 ff       	sbrs	r24, 2
    271c:	8d c0       	rjmp	.+282    	; 0x2838 <BLUETOOTH_Mng_Init+0x20a>
				{
					/*Move to Linking state*/
					u8_CurrentState=BT_STATE_LINKING;
    271e:	86 e0       	ldi	r24, 0x06	; 6
    2720:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2724:	8b e0       	ldi	r24, 0x0B	; 11
    2726:	08 95       	ret
				{
					/*Do Nothing*/
				}
				break;
		case BT_STATE_LINKING:
				if(s8_MAC_Counter<BLUETOOTH_INQ_DEVICES_NUMBERS)
    2728:	80 91 16 06 	lds	r24, 0x0616	; 0x800616 <s8_MAC_Counter.2249>
    272c:	82 30       	cpi	r24, 0x02	; 2
    272e:	0c f0       	brlt	.+2      	; 0x2732 <BLUETOOTH_Mng_Init+0x104>
    2730:	3f c0       	rjmp	.+126    	; 0x27b0 <BLUETOOTH_Mng_Init+0x182>
				{
					/******************************************************************************/
					if(ERROR_OK==BT_Mng_ExtractMAC(gau8_BLUETOOTH_RX_Buf[s8_MAC_Counter],gu8_BLUETOOTH_MACAddressBuf))
    2732:	22 e3       	ldi	r18, 0x32	; 50
    2734:	82 02       	muls	r24, r18
    2736:	c0 01       	movw	r24, r0
    2738:	11 24       	eor	r1, r1
    273a:	6d e1       	ldi	r22, 0x1D	; 29
    273c:	76 e0       	ldi	r23, 0x06	; 6
    273e:	8f 5c       	subi	r24, 0xCF	; 207
    2740:	99 4f       	sbci	r25, 0xF9	; 249
    2742:	b6 dd       	rcall	.-1172   	; 0x22b0 <BT_Mng_ExtractMAC>
    2744:	81 11       	cpse	r24, r1
    2746:	2d c0       	rjmp	.+90     	; 0x27a2 <BLUETOOTH_Mng_Init+0x174>
					/******************************************************************************/
					{	
						/*Connect to this devices*/
						BLUETOOTH_Connect(BLUETOOTH_0, gu8_BLUETOOTH_MACAddressBuf);
    2748:	6d e1       	ldi	r22, 0x1D	; 29
    274a:	76 e0       	ldi	r23, 0x06	; 6
    274c:	0e 94 bc 08 	call	0x1178	; 0x1178 <BLUETOOTH_Connect>
						while(BLUETOOTH_RX_PENDING==GET_BIT(gu8_BLUETOOTH_RXCOM_FLAG,(gu8_RX_Buffer_Counter-ONE)));
    2750:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	21 50       	subi	r18, 0x01	; 1
    2758:	31 09       	sbc	r19, r1
    275a:	80 91 1c 06 	lds	r24, 0x061C	; 0x80061c <gu8_BLUETOOTH_RXCOM_FLAG>
    275e:	90 e0       	ldi	r25, 0x00	; 0
    2760:	02 c0       	rjmp	.+4      	; 0x2766 <BLUETOOTH_Mng_Init+0x138>
    2762:	95 95       	asr	r25
    2764:	87 95       	ror	r24
    2766:	2a 95       	dec	r18
    2768:	e2 f7       	brpl	.-8      	; 0x2762 <BLUETOOTH_Mng_Init+0x134>
    276a:	80 ff       	sbrs	r24, 0
    276c:	f1 cf       	rjmp	.-30     	; 0x2750 <BLUETOOTH_Mng_Init+0x122>
						if(TRUE==StringCompare((ptr_uint8_t)BLUETOOTH_OK,gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE]))
    276e:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2772:	90 e0       	ldi	r25, 0x00	; 0
    2774:	01 97       	sbiw	r24, 0x01	; 1
    2776:	22 e3       	ldi	r18, 0x32	; 50
    2778:	28 9f       	mul	r18, r24
    277a:	b0 01       	movw	r22, r0
    277c:	29 9f       	mul	r18, r25
    277e:	70 0d       	add	r23, r0
    2780:	11 24       	eor	r1, r1
    2782:	6f 5c       	subi	r22, 0xCF	; 207
    2784:	79 4f       	sbci	r23, 0xF9	; 249
    2786:	86 e0       	ldi	r24, 0x06	; 6
    2788:	91 e0       	ldi	r25, 0x01	; 1
    278a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <StringCompare>
    278e:	81 30       	cpi	r24, 0x01	; 1
						{
							BLUETOOTH_SetDataMode(BLUETOOTH_0);
    2790:	41 f4       	brne	.+16     	; 0x27a2 <BLUETOOTH_Mng_Init+0x174>
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	0e 94 36 07 	call	0xe6c	; 0xe6c <BLUETOOTH_SetDataMode>
							/*Set the indecator to verification pattern*/
							Indicator_SetPattern(INDICATOR_VERIFICATION_PATTERN);
    2798:	82 e0       	ldi	r24, 0x02	; 2
    279a:	e4 d1       	rcall	.+968    	; 0x2b64 <Indicator_SetPattern>
							/*Move to handshake state*/
							u8_CurrentState=BT_STATE_HANDSHAKE;	
    279c:	87 e0       	ldi	r24, 0x07	; 7
    279e:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
					}
					else
					{
						/*Do Nothing*/
					}
					s8_MAC_Counter++;
    27a2:	80 91 16 06 	lds	r24, 0x0616	; 0x800616 <s8_MAC_Counter.2249>
    27a6:	8f 5f       	subi	r24, 0xFF	; 255
    27a8:	80 93 16 06 	sts	0x0616, r24	; 0x800616 <s8_MAC_Counter.2249>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    27ac:	8b e0       	ldi	r24, 0x0B	; 11
					s8_MAC_Counter++;
				}
				else
				{
					/*Move to scan state*/
					u8_CurrentState=BT_STATE_SCANNING;
    27ae:	08 95       	ret
    27b0:	84 e0       	ldi	r24, 0x04	; 4
    27b2:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
				}
				
			break;
		case BT_STATE_HANDSHAKE:
				if(ERROR_NOK==BT_Mng_SendHandShake())
    27b6:	8b e0       	ldi	r24, 0x0B	; 11
    27b8:	08 95       	ret
    27ba:	98 dd       	rcall	.-1232   	; 0x22ec <BT_Mng_SendHandShake>
    27bc:	81 30       	cpi	r24, 0x01	; 1
				{
					/*Need to get fixed*/
					BLUETOOTH_Disconnect(BLUETOOTH_0);
    27be:	51 f4       	brne	.+20     	; 0x27d4 <BLUETOOTH_Mng_Init+0x1a6>
    27c0:	80 e0       	ldi	r24, 0x00	; 0
					/*Set the indecator to search pattern*/
					Indicator_SetPattern(INDICATOR_SEARCH_PATTERN);
    27c2:	0e 94 cc 08 	call	0x1198	; 0x1198 <BLUETOOTH_Disconnect>
    27c6:	81 e0       	ldi	r24, 0x01	; 1
					/*Move to Linking state*/
					u8_CurrentState=BT_STATE_LINKING;
    27c8:	cd d1       	rcall	.+922    	; 0x2b64 <Indicator_SetPattern>
    27ca:	86 e0       	ldi	r24, 0x06	; 6
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    27cc:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
					u8_CurrentState=BT_STATE_LINKING;
				}
				else
				{
					/*Set the indecator to connect on pattern*/
					Indicator_SetPattern(INDICATOR_CONNECTED_PATTERN);
    27d0:	8b e0       	ldi	r24, 0x0B	; 11
    27d2:	08 95       	ret
    27d4:	83 e0       	ldi	r24, 0x03	; 3
					/*Move to device data state*/
					u8_CurrentState=BT_STATE_DEVICEDATA;
    27d6:	c6 d1       	rcall	.+908    	; 0x2b64 <Indicator_SetPattern>
    27d8:	88 e0       	ldi	r24, 0x08	; 8
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    27da:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
					u8_CurrentState=BT_STATE_DEVICEDATA;
				}
			break;
		case BT_STATE_DEVICEDATA:
				
				if(ERROR_NOK==BT_Mng_SendDeviceData())
    27de:	8b e0       	ldi	r24, 0x0B	; 11
    27e0:	08 95       	ret
    27e2:	d1 de       	rcall	.-606    	; 0x2586 <BT_Mng_SendDeviceData>
				{
					/*Need to get fixed*/
					BLUETOOTH_Disconnect(BLUETOOTH_0);
    27e4:	81 30       	cpi	r24, 0x01	; 1
    27e6:	51 f4       	brne	.+20     	; 0x27fc <BLUETOOTH_Mng_Init+0x1ce>
    27e8:	80 e0       	ldi	r24, 0x00	; 0
					/*Set the indecator to search pattern*/
					Indicator_SetPattern(INDICATOR_SEARCH_PATTERN);
    27ea:	0e 94 cc 08 	call	0x1198	; 0x1198 <BLUETOOTH_Disconnect>
    27ee:	81 e0       	ldi	r24, 0x01	; 1
					/*Move to scan state*/
					u8_CurrentState=BT_STATE_LINKING;
    27f0:	b9 d1       	rcall	.+882    	; 0x2b64 <Indicator_SetPattern>
    27f2:	86 e0       	ldi	r24, 0x06	; 6
    27f4:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    27f8:	8b e0       	ldi	r24, 0x0B	; 11
					u8_CurrentState=BT_STATE_LINKING;
				}
				else
				{
					/*Save to EEPROM*/
					STORAGE_MAC_Save(gu8_BLUETOOTH_MACAddressBuf);
    27fa:	08 95       	ret
    27fc:	8d e1       	ldi	r24, 0x1D	; 29
    27fe:	96 e0       	ldi	r25, 0x06	; 6
					STORAGE_DataPacket_Save(gau8_BLUETOOTH_RX_Buf[gu8_RX_Buffer_Counter-ONE]);
    2800:	b9 d1       	rcall	.+882    	; 0x2b74 <STORAGE_MAC_Save>
    2802:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <gu8_RX_Buffer_Counter>
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	21 50       	subi	r18, 0x01	; 1
    280a:	31 09       	sbc	r19, r1
    280c:	42 e3       	ldi	r20, 0x32	; 50
    280e:	42 9f       	mul	r20, r18
    2810:	c0 01       	movw	r24, r0
    2812:	43 9f       	mul	r20, r19
    2814:	90 0d       	add	r25, r0
    2816:	11 24       	eor	r1, r1
    2818:	8f 5c       	subi	r24, 0xCF	; 207
    281a:	99 4f       	sbci	r25, 0xF9	; 249
					/*Move to connected state*/
					u8_CurrentState=BT_STATE_CONNECTED;
    281c:	c4 d1       	rcall	.+904    	; 0x2ba6 <STORAGE_DataPacket_Save>
    281e:	89 e0       	ldi	r24, 0x09	; 9
    2820:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <u8_CurrentState.2251>
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2824:	8b e0       	ldi	r24, 0x0B	; 11
				/*Connected*/
				u8_ErrorState = ERROR_OK;
			break;
		case BT_STATE_ERROR:
				/*Set the indecator to malfunction pattern*/
				Indicator_SetPattern(INDICATOR_MALFUNCTION_PATTERN);
    2826:	08 95       	ret
    2828:	80 e0       	ldi	r24, 0x00	; 0
    282a:	9c d1       	rcall	.+824    	; 0x2b64 <Indicator_SetPattern>
				/*Error state*/
				u8_ErrorState = ERROR_NOK;
    282c:	81 e0       	ldi	r24, 0x01	; 1
			break;
    282e:	08 95       	ret
					u8_CurrentState=BT_STATE_CONNECTED;
				}
			break;
		case BT_STATE_CONNECTED:
				/*Connected*/
				u8_ErrorState = ERROR_OK;
    2830:	80 e0       	ldi	r24, 0x00	; 0
    2832:	08 95       	ret
* @brief: This function init the bluetooth manger
*/
static ERROR_STATE_t BLUETOOTH_Mng_Init(void)
{
	static int8_t s8_MAC_Counter=ZERO;
    ERROR_STATE_t u8_ErrorState = BT_INIT_PENDING;
    2834:	8b e0       	ldi	r24, 0x0B	; 11
    2836:	08 95       	ret
    2838:	8b e0       	ldi	r24, 0x0B	; 11
			break;
		default:
			break;
	}	
   return u8_ErrorState;
}
    283a:	08 95       	ret

0000283c <BLUETOOTH_Mng_MainFunction>:
	static uint8_t u8_BT_KP_Data=ZERO;
	static uint8_t u8_BT_State=STATE_CHECKING;
   
   /* OS Variable used for calculating the function waiting period. */
   
   g_BluetoothLastWakeTime=xTaskGetTickCount();
    283c:	0e 94 39 05 	call	0xa72	; 0xa72 <xTaskGetTickCount>
    2840:	90 93 1b 06 	sts	0x061B, r25	; 0x80061b <g_BluetoothLastWakeTime+0x1>
    2844:	80 93 1a 06 	sts	0x061A, r24	; 0x80061a <g_BluetoothLastWakeTime>
   
	/*Check if the moduled has been init before*/
	if(NOT_INIT==u8_BT_INIT_Flag)
    2848:	80 91 19 06 	lds	r24, 0x0619	; 0x800619 <u8_BT_INIT_Flag.2274>
    284c:	81 11       	cpse	r24, r1
    284e:	08 c0       	rjmp	.+16     	; 0x2860 <BLUETOOTH_Mng_MainFunction+0x24>
	{
		u8_BT_MNG_ErrorState=BLUETOOTH_Mng_Init();
    2850:	ee de       	rcall	.-548    	; 0x262e <BLUETOOTH_Mng_Init>
    2852:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		if(BT_INIT_PENDING!=u8_BT_MNG_ErrorState)
    2856:	8b 30       	cpi	r24, 0x0B	; 11
    2858:	19 f0       	breq	.+6      	; 0x2860 <BLUETOOTH_Mng_MainFunction+0x24>
		{
			u8_BT_INIT_Flag=INIT;
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	80 93 19 06 	sts	0x0619, r24	; 0x800619 <u8_BT_INIT_Flag.2274>
		{
			/*Do nothing*/
		}
	}	
	/*If not call the init function*/
	if((INIT==u8_BT_INIT_Flag)&&(ERROR_OK==u8_BT_MNG_ErrorState))
    2860:	80 91 19 06 	lds	r24, 0x0619	; 0x800619 <u8_BT_INIT_Flag.2274>
    2864:	81 30       	cpi	r24, 0x01	; 1
    2866:	29 f5       	brne	.+74     	; 0x28b2 <BLUETOOTH_Mng_MainFunction+0x76>
    2868:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    286c:	81 11       	cpse	r24, r1
    286e:	21 c0       	rjmp	.+66     	; 0x28b2 <BLUETOOTH_Mng_MainFunction+0x76>
	{
		/*OUR LOGIC*/		
		switch(u8_BT_State)
    2870:	80 91 18 06 	lds	r24, 0x0618	; 0x800618 <u8_BT_State.2278>
    2874:	81 30       	cpi	r24, 0x01	; 1
    2876:	19 f0       	breq	.+6      	; 0x287e <BLUETOOTH_Mng_MainFunction+0x42>
    2878:	82 30       	cpi	r24, 0x02	; 2
    287a:	d9 f4       	brne	.+54     	; 0x28b2 <BLUETOOTH_Mng_MainFunction+0x76>
    287c:	11 c0       	rjmp	.+34     	; 0x28a0 <BLUETOOTH_Mng_MainFunction+0x64>
				}								
				break;
			case STATE_SENDING_KD:
				/*SEND KEYPAD DATA PACKET*/
				/*Store Null after the data for the CRC*/
				gu8_BLUETOOTH_KeypadDataPacket[BLUETOOTH_DATA_INDEX+ONE]=END_OF_STRING;
    287e:	e1 e6       	ldi	r30, 0x61	; 97
    2880:	f0 e0       	ldi	r31, 0x00	; 0
    2882:	14 82       	std	Z+4, r1	; 0x04
				/*Store the data in the data index*/
				gu8_BLUETOOTH_KeypadDataPacket[BLUETOOTH_DATA_INDEX]=u8_BT_KP_Data;
    2884:	13 82       	std	Z+3, r1	; 0x03
				/*calculate the CRC*/
				CRC_16_Calc (gu8_BLUETOOTH_KeypadDataPacket);
    2886:	cf 01       	movw	r24, r30
    2888:	0e 94 55 0b 	call	0x16aa	; 0x16aa <CRC_16_Calc>
				/*Send the packet */
				if(ERROR_OK==BLUETOOTH_SendData(BLUETOOTH_0,gu8_BLUETOOTH_KeypadDataPacket))
    288c:	61 e6       	ldi	r22, 0x61	; 97
    288e:	70 e0       	ldi	r23, 0x00	; 0
    2890:	80 e0       	ldi	r24, 0x00	; 0
    2892:	0e 94 67 07 	call	0xece	; 0xece <BLUETOOTH_SendData>
    2896:	81 11       	cpse	r24, r1
    2898:	0c c0       	rjmp	.+24     	; 0x28b2 <BLUETOOTH_Mng_MainFunction+0x76>
				{
					u8_BT_State=STATE_CHECKING;	
    289a:	10 92 18 06 	sts	0x0618, r1	; 0x800618 <u8_BT_State.2278>
    289e:	08 95       	ret
				}
				break;
			case STATE_SENDING_PC:
				/*SEND PASSWORD CHANGE PACKET*/
				if(ERROR_OK==BLUETOOTH_SendData(BLUETOOTH_0,gu8_BLUETOOTH_PasswordChangePacket))
    28a0:	68 e6       	ldi	r22, 0x68	; 104
    28a2:	70 e0       	ldi	r23, 0x00	; 0
    28a4:	80 e0       	ldi	r24, 0x00	; 0
    28a6:	0e 94 67 07 	call	0xece	; 0xece <BLUETOOTH_SendData>
    28aa:	81 11       	cpse	r24, r1
    28ac:	02 c0       	rjmp	.+4      	; 0x28b2 <BLUETOOTH_Mng_MainFunction+0x76>
				{
					u8_BT_State=STATE_CHECKING;				
    28ae:	10 92 18 06 	sts	0x0618, r1	; 0x800618 <u8_BT_State.2278>
    28b2:	08 95       	ret

000028b4 <HMI_MainFunction>:
* @brief: This function is the HMI main function.
*
* @return function error state.
*/
extern void HMI_MainFunction(void)
{
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	00 d0       	rcall	.+0      	; 0x28be <HMI_MainFunction+0xa>
    28be:	00 d0       	rcall	.+0      	; 0x28c0 <HMI_MainFunction+0xc>
    28c0:	cd b7       	in	r28, 0x3d	; 61
    28c2:	de b7       	in	r29, 0x3e	; 62
   uint32_t u32_Key;
   static uint32_t u32_OldKey = 0;
   static uint32_t u32_LastSetKey = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    28c4:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <u8_Init.1658>
    28c8:	81 11       	cpse	r24, r1
    28ca:	07 c0       	rjmp	.+14     	; 0x28da <HMI_MainFunction+0x26>
   {
      KP_Init(KP_UsedChannel);
    28cc:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <KP_UsedChannel>
    28d0:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <KP_Init>
      u8_Init = 1;
    28d4:	81 e0       	ldi	r24, 0x01	; 1
    28d6:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <u8_Init.1658>
   }
   
   /* Get KEypad pressed keys. */
   KP_GetPressedValue(KP_UsedChannel, &u32_Key);
    28da:	be 01       	movw	r22, r28
    28dc:	6f 5f       	subi	r22, 0xFF	; 255
    28de:	7f 4f       	sbci	r23, 0xFF	; 255
    28e0:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <KP_UsedChannel>
    28e4:	0e 94 44 09 	call	0x1288	; 0x1288 <KP_GetPressedValue>
   
   if(u32_OldKey == u32_Key && u32_LastSetKey != u32_Key)
    28e8:	80 91 c5 07 	lds	r24, 0x07C5	; 0x8007c5 <u32_OldKey.1660>
    28ec:	90 91 c6 07 	lds	r25, 0x07C6	; 0x8007c6 <u32_OldKey.1660+0x1>
    28f0:	a0 91 c7 07 	lds	r26, 0x07C7	; 0x8007c7 <u32_OldKey.1660+0x2>
    28f4:	b0 91 c8 07 	lds	r27, 0x07C8	; 0x8007c8 <u32_OldKey.1660+0x3>
    28f8:	49 81       	ldd	r20, Y+1	; 0x01
    28fa:	5a 81       	ldd	r21, Y+2	; 0x02
    28fc:	6b 81       	ldd	r22, Y+3	; 0x03
    28fe:	7c 81       	ldd	r23, Y+4	; 0x04
    2900:	84 17       	cp	r24, r20
    2902:	95 07       	cpc	r25, r21
    2904:	a6 07       	cpc	r26, r22
    2906:	b7 07       	cpc	r27, r23
    2908:	09 f0       	breq	.+2      	; 0x290c <HMI_MainFunction+0x58>
    290a:	3f c0       	rjmp	.+126    	; 0x298a <HMI_MainFunction+0xd6>
    290c:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <u32_LastSetKey.1661>
    2910:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <u32_LastSetKey.1661+0x1>
    2914:	a0 91 c3 07 	lds	r26, 0x07C3	; 0x8007c3 <u32_LastSetKey.1661+0x2>
    2918:	b0 91 c4 07 	lds	r27, 0x07C4	; 0x8007c4 <u32_LastSetKey.1661+0x3>
    291c:	48 17       	cp	r20, r24
    291e:	59 07       	cpc	r21, r25
    2920:	6a 07       	cpc	r22, r26
    2922:	7b 07       	cpc	r23, r27
    2924:	91 f1       	breq	.+100    	; 0x298a <HMI_MainFunction+0xd6>
   {
      u32_LastSetKey = u32_Key;
    2926:	40 93 c1 07 	sts	0x07C1, r20	; 0x8007c1 <u32_LastSetKey.1661>
    292a:	50 93 c2 07 	sts	0x07C2, r21	; 0x8007c2 <u32_LastSetKey.1661+0x1>
    292e:	60 93 c3 07 	sts	0x07C3, r22	; 0x8007c3 <u32_LastSetKey.1661+0x2>
    2932:	70 93 c4 07 	sts	0x07C4, r23	; 0x8007c4 <u32_LastSetKey.1661+0x3>
      /* If multi buttons are pressed. */
      if(MULTI_PRESS_BIT & u32_Key)
    2936:	40 ff       	sbrs	r20, 0
    2938:	0f c0       	rjmp	.+30     	; 0x2958 <HMI_MainFunction+0xa4>
      {
         /* Device erase pattern keys are pressed */
         if(DEVICE_ERASE_VALUE == u32_Key)
    293a:	43 34       	cpi	r20, 0x43	; 67
    293c:	80 e1       	ldi	r24, 0x10	; 16
    293e:	58 07       	cpc	r21, r24
    2940:	61 05       	cpc	r22, r1
    2942:	71 05       	cpc	r23, r1
    2944:	11 f4       	brne	.+4      	; 0x294a <HMI_MainFunction+0x96>
         {
            /* Set device erase flag. */
            HMI_SetDeviceEraseFlag();
    2946:	36 d0       	rcall	.+108    	; 0x29b4 <HMI_SetDeviceEraseFlag>
    2948:	20 c0       	rjmp	.+64     	; 0x298a <HMI_MainFunction+0xd6>
         }
         /* password change pattern keys are pressed */
         else if(PASSWORD_CHANGE_VALUE == u32_Key)
    294a:	43 34       	cpi	r20, 0x43	; 67
    294c:	54 40       	sbci	r21, 0x04	; 4
    294e:	61 05       	cpc	r22, r1
    2950:	71 05       	cpc	r23, r1
         {
            /* Set password change flag. */
            HMI_SetPasswordChangeFlag();
    2952:	d9 f4       	brne	.+54     	; 0x298a <HMI_MainFunction+0xd6>
    2954:	34 d0       	rcall	.+104    	; 0x29be <HMI_SetPasswordChangeFlag>
    2956:	19 c0       	rjmp	.+50     	; 0x298a <HMI_MainFunction+0xd6>
         else
         {
         }
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
    2958:	41 15       	cp	r20, r1
    295a:	51 05       	cpc	r21, r1
    295c:	61 05       	cpc	r22, r1
    295e:	71 05       	cpc	r23, r1
    2960:	89 f4       	brne	.+34     	; 0x2984 <HMI_MainFunction+0xd0>
    2962:	13 c0       	rjmp	.+38     	; 0x298a <HMI_MainFunction+0xd6>
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
         {
            if((u32_Key >> u8_KeyCounter) & 1 )
    2964:	8a 01       	movw	r16, r20
    2966:	9b 01       	movw	r18, r22
    2968:	08 2e       	mov	r0, r24
    296a:	04 c0       	rjmp	.+8      	; 0x2974 <HMI_MainFunction+0xc0>
    296c:	36 95       	lsr	r19
    296e:	27 95       	ror	r18
    2970:	17 95       	ror	r17
    2972:	07 95       	ror	r16
    2974:	0a 94       	dec	r0
    2976:	d2 f7       	brpl	.-12     	; 0x296c <HMI_MainFunction+0xb8>
    2978:	00 ff       	sbrs	r16, 0
            {
               HMI_SetKeyPressed(u8_KeyCounter);
    297a:	02 c0       	rjmp	.+4      	; 0x2980 <HMI_MainFunction+0xcc>
    297c:	25 d0       	rcall	.+74     	; 0x29c8 <HMI_SetKeyPressed>
               break;
    297e:	05 c0       	rjmp	.+10     	; 0x298a <HMI_MainFunction+0xd6>
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
    2980:	8f 5f       	subi	r24, 0xFF	; 255
    2982:	01 c0       	rjmp	.+2      	; 0x2986 <HMI_MainFunction+0xd2>
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	8d 30       	cpi	r24, 0x0D	; 13
    2988:	68 f3       	brcs	.-38     	; 0x2964 <HMI_MainFunction+0xb0>
      }
      else
      {
      }
   }
   u32_OldKey = u32_Key;
    298a:	89 81       	ldd	r24, Y+1	; 0x01
    298c:	9a 81       	ldd	r25, Y+2	; 0x02
    298e:	ab 81       	ldd	r26, Y+3	; 0x03
    2990:	bc 81       	ldd	r27, Y+4	; 0x04
    2992:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <u32_OldKey.1660>
    2996:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <u32_OldKey.1660+0x1>
    299a:	a0 93 c7 07 	sts	0x07C7, r26	; 0x8007c7 <u32_OldKey.1660+0x2>
    299e:	b0 93 c8 07 	sts	0x07C8, r27	; 0x8007c8 <u32_OldKey.1660+0x3>
      
    29a2:	0f 90       	pop	r0
    29a4:	0f 90       	pop	r0
    29a6:	0f 90       	pop	r0
    29a8:	0f 90       	pop	r0
    29aa:	df 91       	pop	r29
    29ac:	cf 91       	pop	r28
    29ae:	1f 91       	pop	r17
    29b0:	0f 91       	pop	r16
    29b2:	08 95       	ret

000029b4 <HMI_SetDeviceEraseFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetDeviceEraseFlag(void)
{
   /* Set the device erase flag. */
   gu8_DeviceEraseFlag = DEVICE_ERASE_FLAG;
    29b4:	81 e0       	ldi	r24, 0x01	; 1
    29b6:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <gu8_DeviceEraseFlag>
   /* return Error state. */
   return ERROR_OK;
}
    29ba:	80 e0       	ldi	r24, 0x00	; 0
    29bc:	08 95       	ret

000029be <HMI_SetPasswordChangeFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetPasswordChangeFlag(void)
{
   /* Set the password change flag. */
   gu8_PasswordChangeFlag = PASSWORD_CHANGE_FLAG;
    29be:	81 e0       	ldi	r24, 0x01	; 1
    29c0:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <gu8_PasswordChangeFlag>
   /* return Error state. */
   return ERROR_OK;
}
    29c4:	80 e0       	ldi	r24, 0x00	; 0
    29c6:	08 95       	ret

000029c8 <HMI_SetKeyPressed>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t HMI_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
    29c8:	8d 30       	cpi	r24, 0x0D	; 13
    29ca:	20 f4       	brcc	.+8      	; 0x29d4 <HMI_SetKeyPressed+0xc>
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
   }
   else
   {
      /* Set the pressed key value. */
      gu8_KeyPressedValue = Value;
    29cc:	80 93 ca 07 	sts	0x07CA, r24	; 0x8007ca <gu8_KeyPressedValue>
      HMI_ErrorState = ERROR_OK;
    29d0:	80 e0       	ldi	r24, 0x00	; 0
    29d2:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
   {
      /* Set invalid Value error. */
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
    29d4:	82 ed       	ldi	r24, 0xD2	; 210
      HMI_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return HMI_ErrorState;
    29d6:	08 95       	ret

000029d8 <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    29d8:	cf 93       	push	r28
    29da:	df 93       	push	r29
    29dc:	00 d0       	rcall	.+0      	; 0x29de <Indicator_MainFunction+0x6>
    29de:	1f 92       	push	r1
    29e0:	cd b7       	in	r28, 0x3d	; 61
    29e2:	de b7       	in	r29, 0x3e	; 62
   /* OS Variable used for calculating the function waiting period. */
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    29e4:	0e 94 39 05 	call	0xa72	; 0xa72 <xTaskGetTickCount>
    29e8:	9a 83       	std	Y+2, r25	; 0x02
    29ea:	89 83       	std	Y+1, r24	; 0x01
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    29ec:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <u8_Init.1974>
    29f0:	81 11       	cpse	r24, r1
    29f2:	07 c0       	rjmp	.+14     	; 0x2a02 <Indicator_MainFunction+0x2a>
   {
      LED_Init(LED_UsedChannel);
    29f4:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <LED_UsedChannel>
    29f8:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED_Init>
      u8_Init = 1;
    29fc:	81 e0       	ldi	r24, 0x01	; 1
    29fe:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <u8_Init.1974>
   }
   
   /* Get the current pattern. */
   Indicator_GetPattern(&u8_Pattern);
    2a02:	ce 01       	movw	r24, r28
    2a04:	03 96       	adiw	r24, 0x03	; 3
    2a06:	a4 d0       	rcall	.+328    	; 0x2b50 <Indicator_GetPattern>
   
   /* If a new pattern is set. */
   if( u8_Pattern != u8_OldPattern)
    2a08:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0a:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <u8_OldPattern.1976>
    2a0e:	e8 17       	cp	r30, r24
    2a10:	31 f0       	breq	.+12     	; 0x2a1e <Indicator_MainFunction+0x46>
   {
      u8_OldPattern = u8_Pattern;
    2a12:	e0 93 91 00 	sts	0x0091, r30	; 0x800091 <u8_OldPattern.1976>
      /* Reinitialize the state and the duty cycle. */
      State = Indicator_LowTime;
    2a16:	10 92 ce 07 	sts	0x07CE, r1	; 0x8007ce <State.1977>
      u8_Duty = MIN_DUTY;
    2a1a:	10 92 cd 07 	sts	0x07CD, r1	; 0x8007cd <u8_Duty.1978>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    2a1e:	e4 30       	cpi	r30, 0x04	; 4
    2a20:	09 f4       	brne	.+2      	; 0x2a24 <Indicator_MainFunction+0x4c>
    2a22:	8a c0       	rjmp	.+276    	; 0x2b38 <Indicator_MainFunction+0x160>
   {
      switch(State)
    2a24:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <State.1977>
    2a28:	81 30       	cpi	r24, 0x01	; 1
    2a2a:	f9 f0       	breq	.+62     	; 0x2a6a <Indicator_MainFunction+0x92>
    2a2c:	38 f0       	brcs	.+14     	; 0x2a3c <Indicator_MainFunction+0x64>
    2a2e:	82 30       	cpi	r24, 0x02	; 2
    2a30:	09 f4       	brne	.+2      	; 0x2a34 <Indicator_MainFunction+0x5c>
    2a32:	40 c0       	rjmp	.+128    	; 0x2ab4 <Indicator_MainFunction+0xdc>
    2a34:	83 30       	cpi	r24, 0x03	; 3
    2a36:	09 f4       	brne	.+2      	; 0x2a3a <Indicator_MainFunction+0x62>
    2a38:	54 c0       	rjmp	.+168    	; 0x2ae2 <Indicator_MainFunction+0x10a>
    2a3a:	77 c0       	rjmp	.+238    	; 0x2b2a <Indicator_MainFunction+0x152>
      {
         case Indicator_LowTime:
            /* Turn off led */
            LED_Off(LED_UsedChannel);
    2a3c:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <LED_UsedChannel>
    2a40:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <LED_Off>
            /* Change state to rise time state. */
            State = Indicator_RiseTime;
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <State.1977>
            /* Put the task in waiting state for the low time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    2a4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4c:	86 e1       	ldi	r24, 0x16	; 22
    2a4e:	e8 9f       	mul	r30, r24
    2a50:	f0 01       	movw	r30, r0
    2a52:	11 24       	eor	r1, r1
    2a54:	ed 5c       	subi	r30, 0xCD	; 205
    2a56:	fe 4f       	sbci	r31, 0xFE	; 254
    2a58:	60 89       	ldd	r22, Z+16	; 0x10
    2a5a:	71 89       	ldd	r23, Z+17	; 0x11
    2a5c:	82 89       	ldd	r24, Z+18	; 0x12
    2a5e:	93 89       	ldd	r25, Z+19	; 0x13
    2a60:	ce 01       	movw	r24, r28
    2a62:	01 96       	adiw	r24, 0x01	; 1
    2a64:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
            break;
    2a68:	6d c0       	rjmp	.+218    	; 0x2b44 <Indicator_MainFunction+0x16c>
         case Indicator_RiseTime:
            /* Increase the duty with the rate of change. */
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    2a6a:	86 e1       	ldi	r24, 0x16	; 22
    2a6c:	e8 9f       	mul	r30, r24
    2a6e:	f0 01       	movw	r30, r0
    2a70:	11 24       	eor	r1, r1
    2a72:	ed 5c       	subi	r30, 0xCD	; 205
    2a74:	fe 4f       	sbci	r31, 0xFE	; 254
    2a76:	65 89       	ldd	r22, Z+21	; 0x15
    2a78:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <u8_Duty.1978>
    2a7c:	68 0f       	add	r22, r24
    2a7e:	60 93 cd 07 	sts	0x07CD, r22	; 0x8007cd <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    2a82:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <LED_UsedChannel>
    2a86:	0e 94 c9 0a 	call	0x1592	; 0x1592 <LED_Dim>
            /* Change state to high time state. */
            if(u8_Duty == MAX_DUTY)
    2a8a:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <u8_Duty.1978>
    2a8e:	84 36       	cpi	r24, 0x64	; 100
    2a90:	19 f4       	brne	.+6      	; 0x2a98 <Indicator_MainFunction+0xc0>
            {
               State = Indicator_HighTime;
    2a92:	82 e0       	ldi	r24, 0x02	; 2
    2a94:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    2a98:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9a:	86 e1       	ldi	r24, 0x16	; 22
    2a9c:	e8 9f       	mul	r30, r24
    2a9e:	f0 01       	movw	r30, r0
    2aa0:	11 24       	eor	r1, r1
    2aa2:	ed 5c       	subi	r30, 0xCD	; 205
    2aa4:	fe 4f       	sbci	r31, 0xFE	; 254
    2aa6:	64 89       	ldd	r22, Z+20	; 0x14
    2aa8:	70 e0       	ldi	r23, 0x00	; 0
    2aaa:	ce 01       	movw	r24, r28
    2aac:	01 96       	adiw	r24, 0x01	; 1
    2aae:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
            break;
    2ab2:	48 c0       	rjmp	.+144    	; 0x2b44 <Indicator_MainFunction+0x16c>
         case Indicator_HighTime:
            /* Turn led on. */
            LED_On(LED_UsedChannel);
    2ab4:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <LED_UsedChannel>
    2ab8:	0e 94 8d 0a 	call	0x151a	; 0x151a <LED_On>
            /* Change state to fall time state. */
            State = Indicator_FallTime;
    2abc:	83 e0       	ldi	r24, 0x03	; 3
    2abe:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <State.1977>
            /* Put the task in waiting state for the high time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    2ac2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac4:	86 e1       	ldi	r24, 0x16	; 22
    2ac6:	e8 9f       	mul	r30, r24
    2ac8:	f0 01       	movw	r30, r0
    2aca:	11 24       	eor	r1, r1
    2acc:	ed 5c       	subi	r30, 0xCD	; 205
    2ace:	fe 4f       	sbci	r31, 0xFE	; 254
    2ad0:	64 81       	ldd	r22, Z+4	; 0x04
    2ad2:	75 81       	ldd	r23, Z+5	; 0x05
    2ad4:	86 81       	ldd	r24, Z+6	; 0x06
    2ad6:	97 81       	ldd	r25, Z+7	; 0x07
    2ad8:	ce 01       	movw	r24, r28
    2ada:	01 96       	adiw	r24, 0x01	; 1
    2adc:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
            break;
    2ae0:	31 c0       	rjmp	.+98     	; 0x2b44 <Indicator_MainFunction+0x16c>
         case Indicator_FallTime:
            /* decrease the duty with the rate of change. */
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    2ae2:	86 e1       	ldi	r24, 0x16	; 22
    2ae4:	e8 9f       	mul	r30, r24
    2ae6:	f0 01       	movw	r30, r0
    2ae8:	11 24       	eor	r1, r1
    2aea:	ed 5c       	subi	r30, 0xCD	; 205
    2aec:	fe 4f       	sbci	r31, 0xFE	; 254
    2aee:	85 89       	ldd	r24, Z+21	; 0x15
    2af0:	60 91 cd 07 	lds	r22, 0x07CD	; 0x8007cd <u8_Duty.1978>
    2af4:	68 1b       	sub	r22, r24
    2af6:	60 93 cd 07 	sts	0x07CD, r22	; 0x8007cd <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    2afa:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <LED_UsedChannel>
    2afe:	0e 94 c9 0a 	call	0x1592	; 0x1592 <LED_Dim>
            /* Change state to low time state. */
            if(u8_Duty == MIN_DUTY)
    2b02:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <u8_Duty.1978>
    2b06:	81 11       	cpse	r24, r1
    2b08:	02 c0       	rjmp	.+4      	; 0x2b0e <Indicator_MainFunction+0x136>
            {
               State = Indicator_LowTime;
    2b0a:	10 92 ce 07 	sts	0x07CE, r1	; 0x8007ce <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    2b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b10:	86 e1       	ldi	r24, 0x16	; 22
    2b12:	e8 9f       	mul	r30, r24
    2b14:	f0 01       	movw	r30, r0
    2b16:	11 24       	eor	r1, r1
    2b18:	ed 5c       	subi	r30, 0xCD	; 205
    2b1a:	fe 4f       	sbci	r31, 0xFE	; 254
    2b1c:	64 89       	ldd	r22, Z+20	; 0x14
    2b1e:	70 e0       	ldi	r23, 0x00	; 0
    2b20:	ce 01       	movw	r24, r28
    2b22:	01 96       	adiw	r24, 0x01	; 1
    2b24:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
            break;
    2b28:	0d c0       	rjmp	.+26     	; 0x2b44 <Indicator_MainFunction+0x16c>
         default:
            vTaskDelayUntil(&xLastWakeTime, 10);
    2b2a:	6a e0       	ldi	r22, 0x0A	; 10
    2b2c:	70 e0       	ldi	r23, 0x00	; 0
    2b2e:	ce 01       	movw	r24, r28
    2b30:	01 96       	adiw	r24, 0x01	; 1
    2b32:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
            break;
    2b36:	06 c0       	rjmp	.+12     	; 0x2b44 <Indicator_MainFunction+0x16c>
      }
   }
   else
   {
      vTaskDelayUntil(&xLastWakeTime, 10);
    2b38:	6a e0       	ldi	r22, 0x0A	; 10
    2b3a:	70 e0       	ldi	r23, 0x00	; 0
    2b3c:	ce 01       	movw	r24, r28
    2b3e:	01 96       	adiw	r24, 0x01	; 1
    2b40:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
   }
    2b44:	0f 90       	pop	r0
    2b46:	0f 90       	pop	r0
    2b48:	0f 90       	pop	r0
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	08 95       	ret

00002b50 <Indicator_GetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    2b50:	00 97       	sbiw	r24, 0x00	; 0
    2b52:	31 f0       	breq	.+12     	; 0x2b60 <Indicator_GetPattern+0x10>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      /* Return the indicator pattern. */
      *Value = gu8_IndicatorPattern;
    2b54:	20 91 92 00 	lds	r18, 0x0092	; 0x800092 <gu8_IndicatorPattern>
    2b58:	fc 01       	movw	r30, r24
    2b5a:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    2b60:	82 eb       	ldi	r24, 0xB2	; 178
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
}
    2b62:	08 95       	ret

00002b64 <Indicator_SetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INDICATOR_INVALID_PATTERN <= Value)
    2b64:	84 30       	cpi	r24, 0x04	; 4
    2b66:	20 f4       	brcc	.+8      	; 0x2b70 <Indicator_SetPattern+0xc>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
   }
   else
   {
      /* Set the indicator pattern. */
      gu8_IndicatorPattern = Value;
    2b68:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <gu8_IndicatorPattern>
      Indicator_ErrorState = ERROR_OK;
    2b6c:	80 e0       	ldi	r24, 0x00	; 0
    2b6e:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INDICATOR_INVALID_PATTERN <= Value)
   {
      /* Set invalid value error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
    2b70:	81 eb       	ldi	r24, 0xB1	; 177
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
    2b72:	08 95       	ret

00002b74 <STORAGE_MAC_Save>:
ERROR_STATE_t STORAGE_MAC_Load(uint8_t* CharArr)
{
	uint8_t ErrRetVal = OperationStarted;
	ErrRetVal = EEPROM_ProxyLoadFromMemory(STARTING_ADD_MAC, ENDING_ADD_MAC, CharArr);
	return ErrRetVal;
}
    2b74:	cf 93       	push	r28
    2b76:	df 93       	push	r29
    2b78:	00 d0       	rcall	.+0      	; 0x2b7a <STORAGE_MAC_Save+0x6>
    2b7a:	cd b7       	in	r28, 0x3d	; 61
    2b7c:	de b7       	in	r29, 0x3e	; 62
    2b7e:	1a 82       	std	Y+2, r1	; 0x02
    2b80:	19 82       	std	Y+1, r1	; 0x01
    2b82:	ae 01       	movw	r20, r28
    2b84:	4f 5f       	subi	r20, 0xFF	; 255
    2b86:	5f 4f       	sbci	r21, 0xFF	; 255
    2b88:	60 e0       	ldi	r22, 0x00	; 0
    2b8a:	70 e0       	ldi	r23, 0x00	; 0
    2b8c:	0e 94 cf 08 	call	0x119e	; 0x119e <EEPROM_ProxySaveToMemory>
    2b90:	29 81       	ldd	r18, Y+1	; 0x01
    2b92:	3a 81       	ldd	r19, Y+2	; 0x02
    2b94:	21 31       	cpi	r18, 0x11	; 17
    2b96:	31 05       	cpc	r19, r1
    2b98:	08 f0       	brcs	.+2      	; 0x2b9c <STORAGE_MAC_Save+0x28>
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
    2b9c:	0f 90       	pop	r0
    2b9e:	0f 90       	pop	r0
    2ba0:	df 91       	pop	r29
    2ba2:	cf 91       	pop	r28
    2ba4:	08 95       	ret

00002ba6 <STORAGE_DataPacket_Save>:
ERROR_STATE_t STORAGE_DataPacket_Save(uint8_t* CharArr)
{
    2ba6:	cf 93       	push	r28
    2ba8:	df 93       	push	r29
    2baa:	00 d0       	rcall	.+0      	; 0x2bac <STORAGE_DataPacket_Save+0x6>
    2bac:	cd b7       	in	r28, 0x3d	; 61
    2bae:	de b7       	in	r29, 0x3e	; 62
	uint8_t ErrRetVal = OperationStarted;
	uint16_t EndingPosition = 0;
    2bb0:	1a 82       	std	Y+2, r1	; 0x02
    2bb2:	19 82       	std	Y+1, r1	; 0x01
	ErrRetVal = EEPROM_ProxySaveToMemory(CharArr,STARTING_ADD_DataPacket, &EndingPosition);
    2bb4:	ae 01       	movw	r20, r28
    2bb6:	4f 5f       	subi	r20, 0xFF	; 255
    2bb8:	5f 4f       	sbci	r21, 0xFF	; 255
    2bba:	64 e1       	ldi	r22, 0x14	; 20
    2bbc:	70 e0       	ldi	r23, 0x00	; 0
    2bbe:	0e 94 cf 08 	call	0x119e	; 0x119e <EEPROM_ProxySaveToMemory>
	if(EndingPosition > ENDING_ADD_DataPAcket)
    2bc2:	29 81       	ldd	r18, Y+1	; 0x01
    2bc4:	3a 81       	ldd	r19, Y+2	; 0x02
    2bc6:	23 33       	cpi	r18, 0x33	; 51
    2bc8:	31 05       	cpc	r19, r1
    2bca:	08 f0       	brcs	.+2      	; 0x2bce <STORAGE_DataPacket_Save+0x28>
		ErrRetVal = OperationFail;
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
	return ErrRetVal;
}
    2bce:	0f 90       	pop	r0
    2bd0:	0f 90       	pop	r0
    2bd2:	df 91       	pop	r29
    2bd4:	cf 91       	pop	r28
    2bd6:	08 95       	ret

00002bd8 <HMI_Task>:
#include "BLUETOOTH_Mng.h"
#include "FreeRTOS.h"
#include "task.h"

void HMI_Task( void *pvParameters )
{
    2bd8:	cf 93       	push	r28
    2bda:	df 93       	push	r29
    2bdc:	00 d0       	rcall	.+0      	; 0x2bde <HMI_Task+0x6>
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    2be2:	0e 94 39 05 	call	0xa72	; 0xa72 <xTaskGetTickCount>
    2be6:	9a 83       	std	Y+2, r25	; 0x02
    2be8:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      HMI_MainFunction();
    2bea:	64 de       	rcall	.-824    	; 0x28b4 <HMI_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    2bec:	62 e3       	ldi	r22, 0x32	; 50
    2bee:	70 e0       	ldi	r23, 0x00	; 0
    2bf0:	ce 01       	movw	r24, r28
    2bf2:	01 96       	adiw	r24, 0x01	; 1
    2bf4:	0e 94 65 06 	call	0xcca	; 0xcca <vTaskDelayUntil>
    2bf8:	f8 cf       	rjmp	.-16     	; 0x2bea <HMI_Task+0x12>

00002bfa <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    2bfa:	ee de       	rcall	.-548    	; 0x29d8 <Indicator_MainFunction>
    2bfc:	fe cf       	rjmp	.-4      	; 0x2bfa <Feedback_Task>

00002bfe <Bluetooth_Task>:

void Bluetooth_Task( void *pvParameters )
{
   for( ;; )
   {
      BLUETOOTH_Mng_MainFunction();
    2bfe:	1e de       	rcall	.-964    	; 0x283c <BLUETOOTH_Mng_MainFunction>
    2c00:	fe cf       	rjmp	.-4      	; 0x2bfe <Bluetooth_Task>

00002c02 <main>:
   }
}

int main(void)
{   
   xTaskCreate( HMI_Task, "HMI", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2c02:	e1 2c       	mov	r14, r1
    2c04:	f1 2c       	mov	r15, r1
    2c06:	01 e0       	ldi	r16, 0x01	; 1
    2c08:	20 e0       	ldi	r18, 0x00	; 0
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	45 e5       	ldi	r20, 0x55	; 85
    2c0e:	50 e0       	ldi	r21, 0x00	; 0
    2c10:	67 ea       	ldi	r22, 0xA7	; 167
    2c12:	71 e0       	ldi	r23, 0x01	; 1
    2c14:	8c ee       	ldi	r24, 0xEC	; 236
    2c16:	95 e1       	ldi	r25, 0x15	; 21
    2c18:	0e 94 bc 04 	call	0x978	; 0x978 <xTaskCreate>
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    2c1c:	20 e0       	ldi	r18, 0x00	; 0
    2c1e:	30 e0       	ldi	r19, 0x00	; 0
    2c20:	45 e5       	ldi	r20, 0x55	; 85
    2c22:	50 e0       	ldi	r21, 0x00	; 0
    2c24:	6b ea       	ldi	r22, 0xAB	; 171
    2c26:	71 e0       	ldi	r23, 0x01	; 1
    2c28:	8d ef       	ldi	r24, 0xFD	; 253
    2c2a:	95 e1       	ldi	r25, 0x15	; 21
    2c2c:	0e 94 bc 04 	call	0x978	; 0x978 <xTaskCreate>
   xTaskCreate( Bluetooth_Task, "Bluetooth", configMINIMAL_STACK_SIZE, NULL_PTR, 0, NULL_PTR );
    2c30:	00 e0       	ldi	r16, 0x00	; 0
    2c32:	20 e0       	ldi	r18, 0x00	; 0
    2c34:	30 e0       	ldi	r19, 0x00	; 0
    2c36:	45 e5       	ldi	r20, 0x55	; 85
    2c38:	50 e0       	ldi	r21, 0x00	; 0
    2c3a:	65 eb       	ldi	r22, 0xB5	; 181
    2c3c:	71 e0       	ldi	r23, 0x01	; 1
    2c3e:	8f ef       	ldi	r24, 0xFF	; 255
    2c40:	95 e1       	ldi	r25, 0x15	; 21
    2c42:	0e 94 bc 04 	call	0x978	; 0x978 <xTaskCreate>
   
   vTaskStartScheduler();
    2c46:	0e 94 0b 05 	call	0xa16	; 0xa16 <vTaskStartScheduler>
    2c4a:	ff cf       	rjmp	.-2      	; 0x2c4a <main+0x48>

00002c4c <__subsf3>:
    2c4c:	50 58       	subi	r21, 0x80	; 128

00002c4e <__addsf3>:
    2c4e:	bb 27       	eor	r27, r27
    2c50:	aa 27       	eor	r26, r26
    2c52:	0e d0       	rcall	.+28     	; 0x2c70 <__addsf3x>
    2c54:	48 c1       	rjmp	.+656    	; 0x2ee6 <__fp_round>
    2c56:	39 d1       	rcall	.+626    	; 0x2eca <__fp_pscA>
    2c58:	30 f0       	brcs	.+12     	; 0x2c66 <__addsf3+0x18>
    2c5a:	3e d1       	rcall	.+636    	; 0x2ed8 <__fp_pscB>
    2c5c:	20 f0       	brcs	.+8      	; 0x2c66 <__addsf3+0x18>
    2c5e:	31 f4       	brne	.+12     	; 0x2c6c <__addsf3+0x1e>
    2c60:	9f 3f       	cpi	r25, 0xFF	; 255
    2c62:	11 f4       	brne	.+4      	; 0x2c68 <__addsf3+0x1a>
    2c64:	1e f4       	brtc	.+6      	; 0x2c6c <__addsf3+0x1e>
    2c66:	2e c1       	rjmp	.+604    	; 0x2ec4 <__fp_nan>
    2c68:	0e f4       	brtc	.+2      	; 0x2c6c <__addsf3+0x1e>
    2c6a:	e0 95       	com	r30
    2c6c:	e7 fb       	bst	r30, 7
    2c6e:	24 c1       	rjmp	.+584    	; 0x2eb8 <__fp_inf>

00002c70 <__addsf3x>:
    2c70:	e9 2f       	mov	r30, r25
    2c72:	4a d1       	rcall	.+660    	; 0x2f08 <__fp_split3>
    2c74:	80 f3       	brcs	.-32     	; 0x2c56 <__addsf3+0x8>
    2c76:	ba 17       	cp	r27, r26
    2c78:	62 07       	cpc	r22, r18
    2c7a:	73 07       	cpc	r23, r19
    2c7c:	84 07       	cpc	r24, r20
    2c7e:	95 07       	cpc	r25, r21
    2c80:	18 f0       	brcs	.+6      	; 0x2c88 <__addsf3x+0x18>
    2c82:	71 f4       	brne	.+28     	; 0x2ca0 <__addsf3x+0x30>
    2c84:	9e f5       	brtc	.+102    	; 0x2cec <__addsf3x+0x7c>
    2c86:	62 c1       	rjmp	.+708    	; 0x2f4c <__fp_zero>
    2c88:	0e f4       	brtc	.+2      	; 0x2c8c <__addsf3x+0x1c>
    2c8a:	e0 95       	com	r30
    2c8c:	0b 2e       	mov	r0, r27
    2c8e:	ba 2f       	mov	r27, r26
    2c90:	a0 2d       	mov	r26, r0
    2c92:	0b 01       	movw	r0, r22
    2c94:	b9 01       	movw	r22, r18
    2c96:	90 01       	movw	r18, r0
    2c98:	0c 01       	movw	r0, r24
    2c9a:	ca 01       	movw	r24, r20
    2c9c:	a0 01       	movw	r20, r0
    2c9e:	11 24       	eor	r1, r1
    2ca0:	ff 27       	eor	r31, r31
    2ca2:	59 1b       	sub	r21, r25
    2ca4:	99 f0       	breq	.+38     	; 0x2ccc <__addsf3x+0x5c>
    2ca6:	59 3f       	cpi	r21, 0xF9	; 249
    2ca8:	50 f4       	brcc	.+20     	; 0x2cbe <__addsf3x+0x4e>
    2caa:	50 3e       	cpi	r21, 0xE0	; 224
    2cac:	68 f1       	brcs	.+90     	; 0x2d08 <__addsf3x+0x98>
    2cae:	1a 16       	cp	r1, r26
    2cb0:	f0 40       	sbci	r31, 0x00	; 0
    2cb2:	a2 2f       	mov	r26, r18
    2cb4:	23 2f       	mov	r18, r19
    2cb6:	34 2f       	mov	r19, r20
    2cb8:	44 27       	eor	r20, r20
    2cba:	58 5f       	subi	r21, 0xF8	; 248
    2cbc:	f3 cf       	rjmp	.-26     	; 0x2ca4 <__addsf3x+0x34>
    2cbe:	46 95       	lsr	r20
    2cc0:	37 95       	ror	r19
    2cc2:	27 95       	ror	r18
    2cc4:	a7 95       	ror	r26
    2cc6:	f0 40       	sbci	r31, 0x00	; 0
    2cc8:	53 95       	inc	r21
    2cca:	c9 f7       	brne	.-14     	; 0x2cbe <__addsf3x+0x4e>
    2ccc:	7e f4       	brtc	.+30     	; 0x2cec <__addsf3x+0x7c>
    2cce:	1f 16       	cp	r1, r31
    2cd0:	ba 0b       	sbc	r27, r26
    2cd2:	62 0b       	sbc	r22, r18
    2cd4:	73 0b       	sbc	r23, r19
    2cd6:	84 0b       	sbc	r24, r20
    2cd8:	ba f0       	brmi	.+46     	; 0x2d08 <__addsf3x+0x98>
    2cda:	91 50       	subi	r25, 0x01	; 1
    2cdc:	a1 f0       	breq	.+40     	; 0x2d06 <__addsf3x+0x96>
    2cde:	ff 0f       	add	r31, r31
    2ce0:	bb 1f       	adc	r27, r27
    2ce2:	66 1f       	adc	r22, r22
    2ce4:	77 1f       	adc	r23, r23
    2ce6:	88 1f       	adc	r24, r24
    2ce8:	c2 f7       	brpl	.-16     	; 0x2cda <__addsf3x+0x6a>
    2cea:	0e c0       	rjmp	.+28     	; 0x2d08 <__addsf3x+0x98>
    2cec:	ba 0f       	add	r27, r26
    2cee:	62 1f       	adc	r22, r18
    2cf0:	73 1f       	adc	r23, r19
    2cf2:	84 1f       	adc	r24, r20
    2cf4:	48 f4       	brcc	.+18     	; 0x2d08 <__addsf3x+0x98>
    2cf6:	87 95       	ror	r24
    2cf8:	77 95       	ror	r23
    2cfa:	67 95       	ror	r22
    2cfc:	b7 95       	ror	r27
    2cfe:	f7 95       	ror	r31
    2d00:	9e 3f       	cpi	r25, 0xFE	; 254
    2d02:	08 f0       	brcs	.+2      	; 0x2d06 <__addsf3x+0x96>
    2d04:	b3 cf       	rjmp	.-154    	; 0x2c6c <__addsf3+0x1e>
    2d06:	93 95       	inc	r25
    2d08:	88 0f       	add	r24, r24
    2d0a:	08 f0       	brcs	.+2      	; 0x2d0e <__addsf3x+0x9e>
    2d0c:	99 27       	eor	r25, r25
    2d0e:	ee 0f       	add	r30, r30
    2d10:	97 95       	ror	r25
    2d12:	87 95       	ror	r24
    2d14:	08 95       	ret

00002d16 <__divsf3>:
    2d16:	0c d0       	rcall	.+24     	; 0x2d30 <__divsf3x>
    2d18:	e6 c0       	rjmp	.+460    	; 0x2ee6 <__fp_round>
    2d1a:	de d0       	rcall	.+444    	; 0x2ed8 <__fp_pscB>
    2d1c:	40 f0       	brcs	.+16     	; 0x2d2e <__divsf3+0x18>
    2d1e:	d5 d0       	rcall	.+426    	; 0x2eca <__fp_pscA>
    2d20:	30 f0       	brcs	.+12     	; 0x2d2e <__divsf3+0x18>
    2d22:	21 f4       	brne	.+8      	; 0x2d2c <__divsf3+0x16>
    2d24:	5f 3f       	cpi	r21, 0xFF	; 255
    2d26:	19 f0       	breq	.+6      	; 0x2d2e <__divsf3+0x18>
    2d28:	c7 c0       	rjmp	.+398    	; 0x2eb8 <__fp_inf>
    2d2a:	51 11       	cpse	r21, r1
    2d2c:	10 c1       	rjmp	.+544    	; 0x2f4e <__fp_szero>
    2d2e:	ca c0       	rjmp	.+404    	; 0x2ec4 <__fp_nan>

00002d30 <__divsf3x>:
    2d30:	eb d0       	rcall	.+470    	; 0x2f08 <__fp_split3>
    2d32:	98 f3       	brcs	.-26     	; 0x2d1a <__divsf3+0x4>

00002d34 <__divsf3_pse>:
    2d34:	99 23       	and	r25, r25
    2d36:	c9 f3       	breq	.-14     	; 0x2d2a <__divsf3+0x14>
    2d38:	55 23       	and	r21, r21
    2d3a:	b1 f3       	breq	.-20     	; 0x2d28 <__divsf3+0x12>
    2d3c:	95 1b       	sub	r25, r21
    2d3e:	55 0b       	sbc	r21, r21
    2d40:	bb 27       	eor	r27, r27
    2d42:	aa 27       	eor	r26, r26
    2d44:	62 17       	cp	r22, r18
    2d46:	73 07       	cpc	r23, r19
    2d48:	84 07       	cpc	r24, r20
    2d4a:	38 f0       	brcs	.+14     	; 0x2d5a <__divsf3_pse+0x26>
    2d4c:	9f 5f       	subi	r25, 0xFF	; 255
    2d4e:	5f 4f       	sbci	r21, 0xFF	; 255
    2d50:	22 0f       	add	r18, r18
    2d52:	33 1f       	adc	r19, r19
    2d54:	44 1f       	adc	r20, r20
    2d56:	aa 1f       	adc	r26, r26
    2d58:	a9 f3       	breq	.-22     	; 0x2d44 <__divsf3_pse+0x10>
    2d5a:	33 d0       	rcall	.+102    	; 0x2dc2 <__divsf3_pse+0x8e>
    2d5c:	0e 2e       	mov	r0, r30
    2d5e:	3a f0       	brmi	.+14     	; 0x2d6e <__divsf3_pse+0x3a>
    2d60:	e0 e8       	ldi	r30, 0x80	; 128
    2d62:	30 d0       	rcall	.+96     	; 0x2dc4 <__divsf3_pse+0x90>
    2d64:	91 50       	subi	r25, 0x01	; 1
    2d66:	50 40       	sbci	r21, 0x00	; 0
    2d68:	e6 95       	lsr	r30
    2d6a:	00 1c       	adc	r0, r0
    2d6c:	ca f7       	brpl	.-14     	; 0x2d60 <__divsf3_pse+0x2c>
    2d6e:	29 d0       	rcall	.+82     	; 0x2dc2 <__divsf3_pse+0x8e>
    2d70:	fe 2f       	mov	r31, r30
    2d72:	27 d0       	rcall	.+78     	; 0x2dc2 <__divsf3_pse+0x8e>
    2d74:	66 0f       	add	r22, r22
    2d76:	77 1f       	adc	r23, r23
    2d78:	88 1f       	adc	r24, r24
    2d7a:	bb 1f       	adc	r27, r27
    2d7c:	26 17       	cp	r18, r22
    2d7e:	37 07       	cpc	r19, r23
    2d80:	48 07       	cpc	r20, r24
    2d82:	ab 07       	cpc	r26, r27
    2d84:	b0 e8       	ldi	r27, 0x80	; 128
    2d86:	09 f0       	breq	.+2      	; 0x2d8a <__divsf3_pse+0x56>
    2d88:	bb 0b       	sbc	r27, r27
    2d8a:	80 2d       	mov	r24, r0
    2d8c:	bf 01       	movw	r22, r30
    2d8e:	ff 27       	eor	r31, r31
    2d90:	93 58       	subi	r25, 0x83	; 131
    2d92:	5f 4f       	sbci	r21, 0xFF	; 255
    2d94:	2a f0       	brmi	.+10     	; 0x2da0 <__divsf3_pse+0x6c>
    2d96:	9e 3f       	cpi	r25, 0xFE	; 254
    2d98:	51 05       	cpc	r21, r1
    2d9a:	68 f0       	brcs	.+26     	; 0x2db6 <__divsf3_pse+0x82>
    2d9c:	8d c0       	rjmp	.+282    	; 0x2eb8 <__fp_inf>
    2d9e:	d7 c0       	rjmp	.+430    	; 0x2f4e <__fp_szero>
    2da0:	5f 3f       	cpi	r21, 0xFF	; 255
    2da2:	ec f3       	brlt	.-6      	; 0x2d9e <__divsf3_pse+0x6a>
    2da4:	98 3e       	cpi	r25, 0xE8	; 232
    2da6:	dc f3       	brlt	.-10     	; 0x2d9e <__divsf3_pse+0x6a>
    2da8:	86 95       	lsr	r24
    2daa:	77 95       	ror	r23
    2dac:	67 95       	ror	r22
    2dae:	b7 95       	ror	r27
    2db0:	f7 95       	ror	r31
    2db2:	9f 5f       	subi	r25, 0xFF	; 255
    2db4:	c9 f7       	brne	.-14     	; 0x2da8 <__divsf3_pse+0x74>
    2db6:	88 0f       	add	r24, r24
    2db8:	91 1d       	adc	r25, r1
    2dba:	96 95       	lsr	r25
    2dbc:	87 95       	ror	r24
    2dbe:	97 f9       	bld	r25, 7
    2dc0:	08 95       	ret
    2dc2:	e1 e0       	ldi	r30, 0x01	; 1
    2dc4:	66 0f       	add	r22, r22
    2dc6:	77 1f       	adc	r23, r23
    2dc8:	88 1f       	adc	r24, r24
    2dca:	bb 1f       	adc	r27, r27
    2dcc:	62 17       	cp	r22, r18
    2dce:	73 07       	cpc	r23, r19
    2dd0:	84 07       	cpc	r24, r20
    2dd2:	ba 07       	cpc	r27, r26
    2dd4:	20 f0       	brcs	.+8      	; 0x2dde <__divsf3_pse+0xaa>
    2dd6:	62 1b       	sub	r22, r18
    2dd8:	73 0b       	sbc	r23, r19
    2dda:	84 0b       	sbc	r24, r20
    2ddc:	ba 0b       	sbc	r27, r26
    2dde:	ee 1f       	adc	r30, r30
    2de0:	88 f7       	brcc	.-30     	; 0x2dc4 <__divsf3_pse+0x90>
    2de2:	e0 95       	com	r30
    2de4:	08 95       	ret

00002de6 <__fixunssfsi>:
    2de6:	98 d0       	rcall	.+304    	; 0x2f18 <__fp_splitA>
    2de8:	88 f0       	brcs	.+34     	; 0x2e0c <__fixunssfsi+0x26>
    2dea:	9f 57       	subi	r25, 0x7F	; 127
    2dec:	90 f0       	brcs	.+36     	; 0x2e12 <__fixunssfsi+0x2c>
    2dee:	b9 2f       	mov	r27, r25
    2df0:	99 27       	eor	r25, r25
    2df2:	b7 51       	subi	r27, 0x17	; 23
    2df4:	a0 f0       	brcs	.+40     	; 0x2e1e <__fixunssfsi+0x38>
    2df6:	d1 f0       	breq	.+52     	; 0x2e2c <__fixunssfsi+0x46>
    2df8:	66 0f       	add	r22, r22
    2dfa:	77 1f       	adc	r23, r23
    2dfc:	88 1f       	adc	r24, r24
    2dfe:	99 1f       	adc	r25, r25
    2e00:	1a f0       	brmi	.+6      	; 0x2e08 <__fixunssfsi+0x22>
    2e02:	ba 95       	dec	r27
    2e04:	c9 f7       	brne	.-14     	; 0x2df8 <__fixunssfsi+0x12>
    2e06:	12 c0       	rjmp	.+36     	; 0x2e2c <__fixunssfsi+0x46>
    2e08:	b1 30       	cpi	r27, 0x01	; 1
    2e0a:	81 f0       	breq	.+32     	; 0x2e2c <__fixunssfsi+0x46>
    2e0c:	9f d0       	rcall	.+318    	; 0x2f4c <__fp_zero>
    2e0e:	b1 e0       	ldi	r27, 0x01	; 1
    2e10:	08 95       	ret
    2e12:	9c c0       	rjmp	.+312    	; 0x2f4c <__fp_zero>
    2e14:	67 2f       	mov	r22, r23
    2e16:	78 2f       	mov	r23, r24
    2e18:	88 27       	eor	r24, r24
    2e1a:	b8 5f       	subi	r27, 0xF8	; 248
    2e1c:	39 f0       	breq	.+14     	; 0x2e2c <__fixunssfsi+0x46>
    2e1e:	b9 3f       	cpi	r27, 0xF9	; 249
    2e20:	cc f3       	brlt	.-14     	; 0x2e14 <__fixunssfsi+0x2e>
    2e22:	86 95       	lsr	r24
    2e24:	77 95       	ror	r23
    2e26:	67 95       	ror	r22
    2e28:	b3 95       	inc	r27
    2e2a:	d9 f7       	brne	.-10     	; 0x2e22 <__fixunssfsi+0x3c>
    2e2c:	3e f4       	brtc	.+14     	; 0x2e3c <__fixunssfsi+0x56>
    2e2e:	90 95       	com	r25
    2e30:	80 95       	com	r24
    2e32:	70 95       	com	r23
    2e34:	61 95       	neg	r22
    2e36:	7f 4f       	sbci	r23, 0xFF	; 255
    2e38:	8f 4f       	sbci	r24, 0xFF	; 255
    2e3a:	9f 4f       	sbci	r25, 0xFF	; 255
    2e3c:	08 95       	ret

00002e3e <__floatunsisf>:
    2e3e:	e8 94       	clt
    2e40:	09 c0       	rjmp	.+18     	; 0x2e54 <__floatsisf+0x12>

00002e42 <__floatsisf>:
    2e42:	97 fb       	bst	r25, 7
    2e44:	3e f4       	brtc	.+14     	; 0x2e54 <__floatsisf+0x12>
    2e46:	90 95       	com	r25
    2e48:	80 95       	com	r24
    2e4a:	70 95       	com	r23
    2e4c:	61 95       	neg	r22
    2e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e50:	8f 4f       	sbci	r24, 0xFF	; 255
    2e52:	9f 4f       	sbci	r25, 0xFF	; 255
    2e54:	99 23       	and	r25, r25
    2e56:	a9 f0       	breq	.+42     	; 0x2e82 <__floatsisf+0x40>
    2e58:	f9 2f       	mov	r31, r25
    2e5a:	96 e9       	ldi	r25, 0x96	; 150
    2e5c:	bb 27       	eor	r27, r27
    2e5e:	93 95       	inc	r25
    2e60:	f6 95       	lsr	r31
    2e62:	87 95       	ror	r24
    2e64:	77 95       	ror	r23
    2e66:	67 95       	ror	r22
    2e68:	b7 95       	ror	r27
    2e6a:	f1 11       	cpse	r31, r1
    2e6c:	f8 cf       	rjmp	.-16     	; 0x2e5e <__floatsisf+0x1c>
    2e6e:	fa f4       	brpl	.+62     	; 0x2eae <__floatsisf+0x6c>
    2e70:	bb 0f       	add	r27, r27
    2e72:	11 f4       	brne	.+4      	; 0x2e78 <__floatsisf+0x36>
    2e74:	60 ff       	sbrs	r22, 0
    2e76:	1b c0       	rjmp	.+54     	; 0x2eae <__floatsisf+0x6c>
    2e78:	6f 5f       	subi	r22, 0xFF	; 255
    2e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e7c:	8f 4f       	sbci	r24, 0xFF	; 255
    2e7e:	9f 4f       	sbci	r25, 0xFF	; 255
    2e80:	16 c0       	rjmp	.+44     	; 0x2eae <__floatsisf+0x6c>
    2e82:	88 23       	and	r24, r24
    2e84:	11 f0       	breq	.+4      	; 0x2e8a <__floatsisf+0x48>
    2e86:	96 e9       	ldi	r25, 0x96	; 150
    2e88:	11 c0       	rjmp	.+34     	; 0x2eac <__floatsisf+0x6a>
    2e8a:	77 23       	and	r23, r23
    2e8c:	21 f0       	breq	.+8      	; 0x2e96 <__floatsisf+0x54>
    2e8e:	9e e8       	ldi	r25, 0x8E	; 142
    2e90:	87 2f       	mov	r24, r23
    2e92:	76 2f       	mov	r23, r22
    2e94:	05 c0       	rjmp	.+10     	; 0x2ea0 <__floatsisf+0x5e>
    2e96:	66 23       	and	r22, r22
    2e98:	71 f0       	breq	.+28     	; 0x2eb6 <__floatsisf+0x74>
    2e9a:	96 e8       	ldi	r25, 0x86	; 134
    2e9c:	86 2f       	mov	r24, r22
    2e9e:	70 e0       	ldi	r23, 0x00	; 0
    2ea0:	60 e0       	ldi	r22, 0x00	; 0
    2ea2:	2a f0       	brmi	.+10     	; 0x2eae <__floatsisf+0x6c>
    2ea4:	9a 95       	dec	r25
    2ea6:	66 0f       	add	r22, r22
    2ea8:	77 1f       	adc	r23, r23
    2eaa:	88 1f       	adc	r24, r24
    2eac:	da f7       	brpl	.-10     	; 0x2ea4 <__floatsisf+0x62>
    2eae:	88 0f       	add	r24, r24
    2eb0:	96 95       	lsr	r25
    2eb2:	87 95       	ror	r24
    2eb4:	97 f9       	bld	r25, 7
    2eb6:	08 95       	ret

00002eb8 <__fp_inf>:
    2eb8:	97 f9       	bld	r25, 7
    2eba:	9f 67       	ori	r25, 0x7F	; 127
    2ebc:	80 e8       	ldi	r24, 0x80	; 128
    2ebe:	70 e0       	ldi	r23, 0x00	; 0
    2ec0:	60 e0       	ldi	r22, 0x00	; 0
    2ec2:	08 95       	ret

00002ec4 <__fp_nan>:
    2ec4:	9f ef       	ldi	r25, 0xFF	; 255
    2ec6:	80 ec       	ldi	r24, 0xC0	; 192
    2ec8:	08 95       	ret

00002eca <__fp_pscA>:
    2eca:	00 24       	eor	r0, r0
    2ecc:	0a 94       	dec	r0
    2ece:	16 16       	cp	r1, r22
    2ed0:	17 06       	cpc	r1, r23
    2ed2:	18 06       	cpc	r1, r24
    2ed4:	09 06       	cpc	r0, r25
    2ed6:	08 95       	ret

00002ed8 <__fp_pscB>:
    2ed8:	00 24       	eor	r0, r0
    2eda:	0a 94       	dec	r0
    2edc:	12 16       	cp	r1, r18
    2ede:	13 06       	cpc	r1, r19
    2ee0:	14 06       	cpc	r1, r20
    2ee2:	05 06       	cpc	r0, r21
    2ee4:	08 95       	ret

00002ee6 <__fp_round>:
    2ee6:	09 2e       	mov	r0, r25
    2ee8:	03 94       	inc	r0
    2eea:	00 0c       	add	r0, r0
    2eec:	11 f4       	brne	.+4      	; 0x2ef2 <__fp_round+0xc>
    2eee:	88 23       	and	r24, r24
    2ef0:	52 f0       	brmi	.+20     	; 0x2f06 <__fp_round+0x20>
    2ef2:	bb 0f       	add	r27, r27
    2ef4:	40 f4       	brcc	.+16     	; 0x2f06 <__fp_round+0x20>
    2ef6:	bf 2b       	or	r27, r31
    2ef8:	11 f4       	brne	.+4      	; 0x2efe <__fp_round+0x18>
    2efa:	60 ff       	sbrs	r22, 0
    2efc:	04 c0       	rjmp	.+8      	; 0x2f06 <__fp_round+0x20>
    2efe:	6f 5f       	subi	r22, 0xFF	; 255
    2f00:	7f 4f       	sbci	r23, 0xFF	; 255
    2f02:	8f 4f       	sbci	r24, 0xFF	; 255
    2f04:	9f 4f       	sbci	r25, 0xFF	; 255
    2f06:	08 95       	ret

00002f08 <__fp_split3>:
    2f08:	57 fd       	sbrc	r21, 7
    2f0a:	90 58       	subi	r25, 0x80	; 128
    2f0c:	44 0f       	add	r20, r20
    2f0e:	55 1f       	adc	r21, r21
    2f10:	59 f0       	breq	.+22     	; 0x2f28 <__fp_splitA+0x10>
    2f12:	5f 3f       	cpi	r21, 0xFF	; 255
    2f14:	71 f0       	breq	.+28     	; 0x2f32 <__fp_splitA+0x1a>
    2f16:	47 95       	ror	r20

00002f18 <__fp_splitA>:
    2f18:	88 0f       	add	r24, r24
    2f1a:	97 fb       	bst	r25, 7
    2f1c:	99 1f       	adc	r25, r25
    2f1e:	61 f0       	breq	.+24     	; 0x2f38 <__fp_splitA+0x20>
    2f20:	9f 3f       	cpi	r25, 0xFF	; 255
    2f22:	79 f0       	breq	.+30     	; 0x2f42 <__fp_splitA+0x2a>
    2f24:	87 95       	ror	r24
    2f26:	08 95       	ret
    2f28:	12 16       	cp	r1, r18
    2f2a:	13 06       	cpc	r1, r19
    2f2c:	14 06       	cpc	r1, r20
    2f2e:	55 1f       	adc	r21, r21
    2f30:	f2 cf       	rjmp	.-28     	; 0x2f16 <__fp_split3+0xe>
    2f32:	46 95       	lsr	r20
    2f34:	f1 df       	rcall	.-30     	; 0x2f18 <__fp_splitA>
    2f36:	08 c0       	rjmp	.+16     	; 0x2f48 <__fp_splitA+0x30>
    2f38:	16 16       	cp	r1, r22
    2f3a:	17 06       	cpc	r1, r23
    2f3c:	18 06       	cpc	r1, r24
    2f3e:	99 1f       	adc	r25, r25
    2f40:	f1 cf       	rjmp	.-30     	; 0x2f24 <__fp_splitA+0xc>
    2f42:	86 95       	lsr	r24
    2f44:	71 05       	cpc	r23, r1
    2f46:	61 05       	cpc	r22, r1
    2f48:	08 94       	sec
    2f4a:	08 95       	ret

00002f4c <__fp_zero>:
    2f4c:	e8 94       	clt

00002f4e <__fp_szero>:
    2f4e:	bb 27       	eor	r27, r27
    2f50:	66 27       	eor	r22, r22
    2f52:	77 27       	eor	r23, r23
    2f54:	cb 01       	movw	r24, r22
    2f56:	97 f9       	bld	r25, 7
    2f58:	08 95       	ret

00002f5a <__mulsf3>:
    2f5a:	0b d0       	rcall	.+22     	; 0x2f72 <__mulsf3x>
    2f5c:	c4 cf       	rjmp	.-120    	; 0x2ee6 <__fp_round>
    2f5e:	b5 df       	rcall	.-150    	; 0x2eca <__fp_pscA>
    2f60:	28 f0       	brcs	.+10     	; 0x2f6c <__mulsf3+0x12>
    2f62:	ba df       	rcall	.-140    	; 0x2ed8 <__fp_pscB>
    2f64:	18 f0       	brcs	.+6      	; 0x2f6c <__mulsf3+0x12>
    2f66:	95 23       	and	r25, r21
    2f68:	09 f0       	breq	.+2      	; 0x2f6c <__mulsf3+0x12>
    2f6a:	a6 cf       	rjmp	.-180    	; 0x2eb8 <__fp_inf>
    2f6c:	ab cf       	rjmp	.-170    	; 0x2ec4 <__fp_nan>
    2f6e:	11 24       	eor	r1, r1
    2f70:	ee cf       	rjmp	.-36     	; 0x2f4e <__fp_szero>

00002f72 <__mulsf3x>:
    2f72:	ca df       	rcall	.-108    	; 0x2f08 <__fp_split3>
    2f74:	a0 f3       	brcs	.-24     	; 0x2f5e <__mulsf3+0x4>

00002f76 <__mulsf3_pse>:
    2f76:	95 9f       	mul	r25, r21
    2f78:	d1 f3       	breq	.-12     	; 0x2f6e <__mulsf3+0x14>
    2f7a:	95 0f       	add	r25, r21
    2f7c:	50 e0       	ldi	r21, 0x00	; 0
    2f7e:	55 1f       	adc	r21, r21
    2f80:	62 9f       	mul	r22, r18
    2f82:	f0 01       	movw	r30, r0
    2f84:	72 9f       	mul	r23, r18
    2f86:	bb 27       	eor	r27, r27
    2f88:	f0 0d       	add	r31, r0
    2f8a:	b1 1d       	adc	r27, r1
    2f8c:	63 9f       	mul	r22, r19
    2f8e:	aa 27       	eor	r26, r26
    2f90:	f0 0d       	add	r31, r0
    2f92:	b1 1d       	adc	r27, r1
    2f94:	aa 1f       	adc	r26, r26
    2f96:	64 9f       	mul	r22, r20
    2f98:	66 27       	eor	r22, r22
    2f9a:	b0 0d       	add	r27, r0
    2f9c:	a1 1d       	adc	r26, r1
    2f9e:	66 1f       	adc	r22, r22
    2fa0:	82 9f       	mul	r24, r18
    2fa2:	22 27       	eor	r18, r18
    2fa4:	b0 0d       	add	r27, r0
    2fa6:	a1 1d       	adc	r26, r1
    2fa8:	62 1f       	adc	r22, r18
    2faa:	73 9f       	mul	r23, r19
    2fac:	b0 0d       	add	r27, r0
    2fae:	a1 1d       	adc	r26, r1
    2fb0:	62 1f       	adc	r22, r18
    2fb2:	83 9f       	mul	r24, r19
    2fb4:	a0 0d       	add	r26, r0
    2fb6:	61 1d       	adc	r22, r1
    2fb8:	22 1f       	adc	r18, r18
    2fba:	74 9f       	mul	r23, r20
    2fbc:	33 27       	eor	r19, r19
    2fbe:	a0 0d       	add	r26, r0
    2fc0:	61 1d       	adc	r22, r1
    2fc2:	23 1f       	adc	r18, r19
    2fc4:	84 9f       	mul	r24, r20
    2fc6:	60 0d       	add	r22, r0
    2fc8:	21 1d       	adc	r18, r1
    2fca:	82 2f       	mov	r24, r18
    2fcc:	76 2f       	mov	r23, r22
    2fce:	6a 2f       	mov	r22, r26
    2fd0:	11 24       	eor	r1, r1
    2fd2:	9f 57       	subi	r25, 0x7F	; 127
    2fd4:	50 40       	sbci	r21, 0x00	; 0
    2fd6:	8a f0       	brmi	.+34     	; 0x2ffa <__mulsf3_pse+0x84>
    2fd8:	e1 f0       	breq	.+56     	; 0x3012 <__mulsf3_pse+0x9c>
    2fda:	88 23       	and	r24, r24
    2fdc:	4a f0       	brmi	.+18     	; 0x2ff0 <__mulsf3_pse+0x7a>
    2fde:	ee 0f       	add	r30, r30
    2fe0:	ff 1f       	adc	r31, r31
    2fe2:	bb 1f       	adc	r27, r27
    2fe4:	66 1f       	adc	r22, r22
    2fe6:	77 1f       	adc	r23, r23
    2fe8:	88 1f       	adc	r24, r24
    2fea:	91 50       	subi	r25, 0x01	; 1
    2fec:	50 40       	sbci	r21, 0x00	; 0
    2fee:	a9 f7       	brne	.-22     	; 0x2fda <__mulsf3_pse+0x64>
    2ff0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ff2:	51 05       	cpc	r21, r1
    2ff4:	70 f0       	brcs	.+28     	; 0x3012 <__mulsf3_pse+0x9c>
    2ff6:	60 cf       	rjmp	.-320    	; 0x2eb8 <__fp_inf>
    2ff8:	aa cf       	rjmp	.-172    	; 0x2f4e <__fp_szero>
    2ffa:	5f 3f       	cpi	r21, 0xFF	; 255
    2ffc:	ec f3       	brlt	.-6      	; 0x2ff8 <__mulsf3_pse+0x82>
    2ffe:	98 3e       	cpi	r25, 0xE8	; 232
    3000:	dc f3       	brlt	.-10     	; 0x2ff8 <__mulsf3_pse+0x82>
    3002:	86 95       	lsr	r24
    3004:	77 95       	ror	r23
    3006:	67 95       	ror	r22
    3008:	b7 95       	ror	r27
    300a:	f7 95       	ror	r31
    300c:	e7 95       	ror	r30
    300e:	9f 5f       	subi	r25, 0xFF	; 255
    3010:	c1 f7       	brne	.-16     	; 0x3002 <__mulsf3_pse+0x8c>
    3012:	fe 2b       	or	r31, r30
    3014:	88 0f       	add	r24, r24
    3016:	91 1d       	adc	r25, r1
    3018:	96 95       	lsr	r25
    301a:	87 95       	ror	r24
    301c:	97 f9       	bld	r25, 7
    301e:	08 95       	ret

00003020 <__tablejump2__>:
    3020:	ee 0f       	add	r30, r30
    3022:	ff 1f       	adc	r31, r31
    3024:	05 90       	lpm	r0, Z+
    3026:	f4 91       	lpm	r31, Z
    3028:	e0 2d       	mov	r30, r0
    302a:	09 94       	ijmp

0000302c <_exit>:
    302c:	f8 94       	cli

0000302e <__stop_program>:
    302e:	ff cf       	rjmp	.-2      	; 0x302e <__stop_program>
