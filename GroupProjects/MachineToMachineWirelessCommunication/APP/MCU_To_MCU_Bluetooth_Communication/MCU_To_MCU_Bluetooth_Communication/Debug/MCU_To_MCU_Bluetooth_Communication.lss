
MCU_To_MCU_Bluetooth_Communication.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f9e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00800060  00001f9e  00002032  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000650  00800110  00800110  000020e2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000020e2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002114  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000500  00000000  00000000  00002150  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004c46  00000000  00000000  00002650  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a7a  00000000  00000000  00007296  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000030eb  00000000  00000000  00008d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000aac  00000000  00000000  0000bdfc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b8a  00000000  00000000  0000c8a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003529  00000000  00000000  0000e432  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004a0  00000000  00000000  0001195b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 2c 02 	jmp	0x458	; 0x458 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e9       	ldi	r30, 0x9E	; 158
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 31       	cpi	r26, 0x10	; 16
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a0 e1       	ldi	r26, 0x10	; 16
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 36       	cpi	r26, 0x60	; 96
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <main>
      8a:	0c 94 cd 0f 	jmp	0x1f9a	; 0x1f9a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      92:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      94:	03 96       	adiw	r24, 0x03	; 3
      96:	92 83       	std	Z+2, r25	; 0x02
      98:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      9a:	2f ef       	ldi	r18, 0xFF	; 255
      9c:	3f ef       	ldi	r19, 0xFF	; 255
      9e:	34 83       	std	Z+4, r19	; 0x04
      a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a2:	96 83       	std	Z+6, r25	; 0x06
      a4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a6:	90 87       	std	Z+8, r25	; 0x08
      a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      aa:	10 82       	st	Z, r1
      ac:	08 95       	ret

000000ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      ae:	fc 01       	movw	r30, r24
      b0:	11 86       	std	Z+9, r1	; 0x09
      b2:	10 86       	std	Z+8, r1	; 0x08
      b4:	08 95       	ret

000000b6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      b6:	cf 93       	push	r28
      b8:	df 93       	push	r29
      ba:	9c 01       	movw	r18, r24
      bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      be:	dc 01       	movw	r26, r24
      c0:	11 96       	adiw	r26, 0x01	; 1
      c2:	cd 91       	ld	r28, X+
      c4:	dc 91       	ld	r29, X
      c6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      c8:	d3 83       	std	Z+3, r29	; 0x03
      ca:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      cc:	8c 81       	ldd	r24, Y+4	; 0x04
      ce:	9d 81       	ldd	r25, Y+5	; 0x05
      d0:	95 83       	std	Z+5, r25	; 0x05
      d2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      d4:	8c 81       	ldd	r24, Y+4	; 0x04
      d6:	9d 81       	ldd	r25, Y+5	; 0x05
      d8:	dc 01       	movw	r26, r24
      da:	13 96       	adiw	r26, 0x03	; 3
      dc:	7c 93       	st	X, r23
      de:	6e 93       	st	-X, r22
      e0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
      e2:	7d 83       	std	Y+5, r23	; 0x05
      e4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
      e6:	31 87       	std	Z+9, r19	; 0x09
      e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
      ea:	f9 01       	movw	r30, r18
      ec:	80 81       	ld	r24, Z
      ee:	8f 5f       	subi	r24, 0xFF	; 255
      f0:	80 83       	st	Z, r24
}
      f2:	df 91       	pop	r29
      f4:	cf 91       	pop	r28
      f6:	08 95       	ret

000000f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
      fe:	48 81       	ld	r20, Y
     100:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     102:	4f 3f       	cpi	r20, 0xFF	; 255
     104:	2f ef       	ldi	r18, 0xFF	; 255
     106:	52 07       	cpc	r21, r18
     108:	21 f4       	brne	.+8      	; 0x112 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     10a:	fc 01       	movw	r30, r24
     10c:	a7 81       	ldd	r26, Z+7	; 0x07
     10e:	b0 85       	ldd	r27, Z+8	; 0x08
     110:	0d c0       	rjmp	.+26     	; 0x12c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     112:	dc 01       	movw	r26, r24
     114:	13 96       	adiw	r26, 0x03	; 3
     116:	01 c0       	rjmp	.+2      	; 0x11a <vListInsert+0x22>
     118:	df 01       	movw	r26, r30
     11a:	12 96       	adiw	r26, 0x02	; 2
     11c:	ed 91       	ld	r30, X+
     11e:	fc 91       	ld	r31, X
     120:	13 97       	sbiw	r26, 0x03	; 3
     122:	20 81       	ld	r18, Z
     124:	31 81       	ldd	r19, Z+1	; 0x01
     126:	42 17       	cp	r20, r18
     128:	53 07       	cpc	r21, r19
     12a:	b0 f7       	brcc	.-20     	; 0x118 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     12c:	12 96       	adiw	r26, 0x02	; 2
     12e:	ed 91       	ld	r30, X+
     130:	fc 91       	ld	r31, X
     132:	13 97       	sbiw	r26, 0x03	; 3
     134:	fb 83       	std	Y+3, r31	; 0x03
     136:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     138:	d5 83       	std	Z+5, r29	; 0x05
     13a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     13c:	bd 83       	std	Y+5, r27	; 0x05
     13e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     140:	13 96       	adiw	r26, 0x03	; 3
     142:	dc 93       	st	X, r29
     144:	ce 93       	st	-X, r28
     146:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     148:	99 87       	std	Y+9, r25	; 0x09
     14a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     14c:	fc 01       	movw	r30, r24
     14e:	20 81       	ld	r18, Z
     150:	2f 5f       	subi	r18, 0xFF	; 255
     152:	20 83       	st	Z, r18
}
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
     158:	08 95       	ret

0000015a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
     15e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     160:	a0 85       	ldd	r26, Z+8	; 0x08
     162:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     164:	c2 81       	ldd	r28, Z+2	; 0x02
     166:	d3 81       	ldd	r29, Z+3	; 0x03
     168:	84 81       	ldd	r24, Z+4	; 0x04
     16a:	95 81       	ldd	r25, Z+5	; 0x05
     16c:	9d 83       	std	Y+5, r25	; 0x05
     16e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     170:	c4 81       	ldd	r28, Z+4	; 0x04
     172:	d5 81       	ldd	r29, Z+5	; 0x05
     174:	82 81       	ldd	r24, Z+2	; 0x02
     176:	93 81       	ldd	r25, Z+3	; 0x03
     178:	9b 83       	std	Y+3, r25	; 0x03
     17a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     17c:	11 96       	adiw	r26, 0x01	; 1
     17e:	8d 91       	ld	r24, X+
     180:	9c 91       	ld	r25, X
     182:	12 97       	sbiw	r26, 0x02	; 2
     184:	e8 17       	cp	r30, r24
     186:	f9 07       	cpc	r31, r25
     188:	31 f4       	brne	.+12     	; 0x196 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     18a:	84 81       	ldd	r24, Z+4	; 0x04
     18c:	95 81       	ldd	r25, Z+5	; 0x05
     18e:	12 96       	adiw	r26, 0x02	; 2
     190:	9c 93       	st	X, r25
     192:	8e 93       	st	-X, r24
     194:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     196:	11 86       	std	Z+9, r1	; 0x09
     198:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     19a:	8c 91       	ld	r24, X
     19c:	81 50       	subi	r24, 0x01	; 1
     19e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     1a6:	1b bc       	out	0x2b, r1	; 43
     1a8:	89 ef       	ldi	r24, 0xF9	; 249
     1aa:	8a bd       	out	0x2a, r24	; 42
     1ac:	8b e0       	ldi	r24, 0x0B	; 11
     1ae:	8e bd       	out	0x2e, r24	; 46
     1b0:	89 b7       	in	r24, 0x39	; 57
     1b2:	80 61       	ori	r24, 0x10	; 16
     1b4:	89 bf       	out	0x39, r24	; 57
     1b6:	08 95       	ret

000001b8 <pxPortInitialiseStack>:
     1b8:	31 e1       	ldi	r19, 0x11	; 17
     1ba:	fc 01       	movw	r30, r24
     1bc:	30 83       	st	Z, r19
     1be:	31 97       	sbiw	r30, 0x01	; 1
     1c0:	22 e2       	ldi	r18, 0x22	; 34
     1c2:	20 83       	st	Z, r18
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	a3 e3       	ldi	r26, 0x33	; 51
     1c8:	a0 83       	st	Z, r26
     1ca:	31 97       	sbiw	r30, 0x01	; 1
     1cc:	60 83       	st	Z, r22
     1ce:	31 97       	sbiw	r30, 0x01	; 1
     1d0:	70 83       	st	Z, r23
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	10 82       	st	Z, r1
     1d6:	31 97       	sbiw	r30, 0x01	; 1
     1d8:	60 e8       	ldi	r22, 0x80	; 128
     1da:	60 83       	st	Z, r22
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	10 82       	st	Z, r1
     1e0:	31 97       	sbiw	r30, 0x01	; 1
     1e2:	62 e0       	ldi	r22, 0x02	; 2
     1e4:	60 83       	st	Z, r22
     1e6:	31 97       	sbiw	r30, 0x01	; 1
     1e8:	63 e0       	ldi	r22, 0x03	; 3
     1ea:	60 83       	st	Z, r22
     1ec:	31 97       	sbiw	r30, 0x01	; 1
     1ee:	64 e0       	ldi	r22, 0x04	; 4
     1f0:	60 83       	st	Z, r22
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	60 83       	st	Z, r22
     1f8:	31 97       	sbiw	r30, 0x01	; 1
     1fa:	66 e0       	ldi	r22, 0x06	; 6
     1fc:	60 83       	st	Z, r22
     1fe:	31 97       	sbiw	r30, 0x01	; 1
     200:	67 e0       	ldi	r22, 0x07	; 7
     202:	60 83       	st	Z, r22
     204:	31 97       	sbiw	r30, 0x01	; 1
     206:	68 e0       	ldi	r22, 0x08	; 8
     208:	60 83       	st	Z, r22
     20a:	31 97       	sbiw	r30, 0x01	; 1
     20c:	69 e0       	ldi	r22, 0x09	; 9
     20e:	60 83       	st	Z, r22
     210:	31 97       	sbiw	r30, 0x01	; 1
     212:	60 e1       	ldi	r22, 0x10	; 16
     214:	60 83       	st	Z, r22
     216:	31 97       	sbiw	r30, 0x01	; 1
     218:	30 83       	st	Z, r19
     21a:	31 97       	sbiw	r30, 0x01	; 1
     21c:	32 e1       	ldi	r19, 0x12	; 18
     21e:	30 83       	st	Z, r19
     220:	31 97       	sbiw	r30, 0x01	; 1
     222:	33 e1       	ldi	r19, 0x13	; 19
     224:	30 83       	st	Z, r19
     226:	31 97       	sbiw	r30, 0x01	; 1
     228:	34 e1       	ldi	r19, 0x14	; 20
     22a:	30 83       	st	Z, r19
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	35 e1       	ldi	r19, 0x15	; 21
     230:	30 83       	st	Z, r19
     232:	31 97       	sbiw	r30, 0x01	; 1
     234:	36 e1       	ldi	r19, 0x16	; 22
     236:	30 83       	st	Z, r19
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	37 e1       	ldi	r19, 0x17	; 23
     23c:	30 83       	st	Z, r19
     23e:	31 97       	sbiw	r30, 0x01	; 1
     240:	38 e1       	ldi	r19, 0x18	; 24
     242:	30 83       	st	Z, r19
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	39 e1       	ldi	r19, 0x19	; 25
     248:	30 83       	st	Z, r19
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	30 e2       	ldi	r19, 0x20	; 32
     24e:	30 83       	st	Z, r19
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	31 e2       	ldi	r19, 0x21	; 33
     254:	30 83       	st	Z, r19
     256:	31 97       	sbiw	r30, 0x01	; 1
     258:	20 83       	st	Z, r18
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	23 e2       	ldi	r18, 0x23	; 35
     25e:	20 83       	st	Z, r18
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	40 83       	st	Z, r20
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	50 83       	st	Z, r21
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	26 e2       	ldi	r18, 0x26	; 38
     26c:	20 83       	st	Z, r18
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	27 e2       	ldi	r18, 0x27	; 39
     272:	20 83       	st	Z, r18
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	28 e2       	ldi	r18, 0x28	; 40
     278:	20 83       	st	Z, r18
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	29 e2       	ldi	r18, 0x29	; 41
     27e:	20 83       	st	Z, r18
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	20 e3       	ldi	r18, 0x30	; 48
     284:	20 83       	st	Z, r18
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	21 e3       	ldi	r18, 0x31	; 49
     28a:	20 83       	st	Z, r18
     28c:	86 97       	sbiw	r24, 0x26	; 38
     28e:	08 95       	ret

00000290 <xPortStartScheduler>:
     290:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <prvSetupTimerInterrupt>
     294:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     298:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     29c:	cd 91       	ld	r28, X+
     29e:	cd bf       	out	0x3d, r28	; 61
     2a0:	dd 91       	ld	r29, X+
     2a2:	de bf       	out	0x3e, r29	; 62
     2a4:	ff 91       	pop	r31
     2a6:	ef 91       	pop	r30
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	bf 91       	pop	r27
     2ae:	af 91       	pop	r26
     2b0:	9f 91       	pop	r25
     2b2:	8f 91       	pop	r24
     2b4:	7f 91       	pop	r23
     2b6:	6f 91       	pop	r22
     2b8:	5f 91       	pop	r21
     2ba:	4f 91       	pop	r20
     2bc:	3f 91       	pop	r19
     2be:	2f 91       	pop	r18
     2c0:	1f 91       	pop	r17
     2c2:	0f 91       	pop	r16
     2c4:	ff 90       	pop	r15
     2c6:	ef 90       	pop	r14
     2c8:	df 90       	pop	r13
     2ca:	cf 90       	pop	r12
     2cc:	bf 90       	pop	r11
     2ce:	af 90       	pop	r10
     2d0:	9f 90       	pop	r9
     2d2:	8f 90       	pop	r8
     2d4:	7f 90       	pop	r7
     2d6:	6f 90       	pop	r6
     2d8:	5f 90       	pop	r5
     2da:	4f 90       	pop	r4
     2dc:	3f 90       	pop	r3
     2de:	2f 90       	pop	r2
     2e0:	1f 90       	pop	r1
     2e2:	0f 90       	pop	r0
     2e4:	0f be       	out	0x3f, r0	; 63
     2e6:	0f 90       	pop	r0
     2e8:	08 95       	ret
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	08 95       	ret

000002ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     2ee:	0f 92       	push	r0
     2f0:	0f b6       	in	r0, 0x3f	; 63
     2f2:	f8 94       	cli
     2f4:	0f 92       	push	r0
     2f6:	1f 92       	push	r1
     2f8:	11 24       	eor	r1, r1
     2fa:	2f 92       	push	r2
     2fc:	3f 92       	push	r3
     2fe:	4f 92       	push	r4
     300:	5f 92       	push	r5
     302:	6f 92       	push	r6
     304:	7f 92       	push	r7
     306:	8f 92       	push	r8
     308:	9f 92       	push	r9
     30a:	af 92       	push	r10
     30c:	bf 92       	push	r11
     30e:	cf 92       	push	r12
     310:	df 92       	push	r13
     312:	ef 92       	push	r14
     314:	ff 92       	push	r15
     316:	0f 93       	push	r16
     318:	1f 93       	push	r17
     31a:	2f 93       	push	r18
     31c:	3f 93       	push	r19
     31e:	4f 93       	push	r20
     320:	5f 93       	push	r21
     322:	6f 93       	push	r22
     324:	7f 93       	push	r23
     326:	8f 93       	push	r24
     328:	9f 93       	push	r25
     32a:	af 93       	push	r26
     32c:	bf 93       	push	r27
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	ef 93       	push	r30
     334:	ff 93       	push	r31
     336:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     33a:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     33e:	0d b6       	in	r0, 0x3d	; 61
     340:	0d 92       	st	X+, r0
     342:	0e b6       	in	r0, 0x3e	; 62
     344:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     346:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     34a:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     34e:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     352:	cd 91       	ld	r28, X+
     354:	cd bf       	out	0x3d, r28	; 61
     356:	dd 91       	ld	r29, X+
     358:	de bf       	out	0x3e, r29	; 62
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	bf 91       	pop	r27
     364:	af 91       	pop	r26
     366:	9f 91       	pop	r25
     368:	8f 91       	pop	r24
     36a:	7f 91       	pop	r23
     36c:	6f 91       	pop	r22
     36e:	5f 91       	pop	r21
     370:	4f 91       	pop	r20
     372:	3f 91       	pop	r19
     374:	2f 91       	pop	r18
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	ff 90       	pop	r15
     37c:	ef 90       	pop	r14
     37e:	df 90       	pop	r13
     380:	cf 90       	pop	r12
     382:	bf 90       	pop	r11
     384:	af 90       	pop	r10
     386:	9f 90       	pop	r9
     388:	8f 90       	pop	r8
     38a:	7f 90       	pop	r7
     38c:	6f 90       	pop	r6
     38e:	5f 90       	pop	r5
     390:	4f 90       	pop	r4
     392:	3f 90       	pop	r3
     394:	2f 90       	pop	r2
     396:	1f 90       	pop	r1
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     39e:	08 95       	ret

000003a0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3a0:	0f 92       	push	r0
     3a2:	0f b6       	in	r0, 0x3f	; 63
     3a4:	f8 94       	cli
     3a6:	0f 92       	push	r0
     3a8:	1f 92       	push	r1
     3aa:	11 24       	eor	r1, r1
     3ac:	2f 92       	push	r2
     3ae:	3f 92       	push	r3
     3b0:	4f 92       	push	r4
     3b2:	5f 92       	push	r5
     3b4:	6f 92       	push	r6
     3b6:	7f 92       	push	r7
     3b8:	8f 92       	push	r8
     3ba:	9f 92       	push	r9
     3bc:	af 92       	push	r10
     3be:	bf 92       	push	r11
     3c0:	cf 92       	push	r12
     3c2:	df 92       	push	r13
     3c4:	ef 92       	push	r14
     3c6:	ff 92       	push	r15
     3c8:	0f 93       	push	r16
     3ca:	1f 93       	push	r17
     3cc:	2f 93       	push	r18
     3ce:	3f 93       	push	r19
     3d0:	4f 93       	push	r20
     3d2:	5f 93       	push	r21
     3d4:	6f 93       	push	r22
     3d6:	7f 93       	push	r23
     3d8:	8f 93       	push	r24
     3da:	9f 93       	push	r25
     3dc:	af 93       	push	r26
     3de:	bf 93       	push	r27
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	ef 93       	push	r30
     3e6:	ff 93       	push	r31
     3e8:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     3ec:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     3f0:	0d b6       	in	r0, 0x3d	; 61
     3f2:	0d 92       	st	X+, r0
     3f4:	0e b6       	in	r0, 0x3e	; 62
     3f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     3f8:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     3fc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     3fe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     402:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     406:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     40a:	cd 91       	ld	r28, X+
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	dd 91       	ld	r29, X+
     410:	de bf       	out	0x3e, r29	; 62
     412:	ff 91       	pop	r31
     414:	ef 91       	pop	r30
     416:	df 91       	pop	r29
     418:	cf 91       	pop	r28
     41a:	bf 91       	pop	r27
     41c:	af 91       	pop	r26
     41e:	9f 91       	pop	r25
     420:	8f 91       	pop	r24
     422:	7f 91       	pop	r23
     424:	6f 91       	pop	r22
     426:	5f 91       	pop	r21
     428:	4f 91       	pop	r20
     42a:	3f 91       	pop	r19
     42c:	2f 91       	pop	r18
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	9f 90       	pop	r9
     440:	8f 90       	pop	r8
     442:	7f 90       	pop	r7
     444:	6f 90       	pop	r6
     446:	5f 90       	pop	r5
     448:	4f 90       	pop	r4
     44a:	3f 90       	pop	r3
     44c:	2f 90       	pop	r2
     44e:	1f 90       	pop	r1
     450:	0f 90       	pop	r0
     452:	0f be       	out	0x3f, r0	; 63
     454:	0f 90       	pop	r0

	asm volatile ( "ret" );
     456:	08 95       	ret

00000458 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     458:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     45c:	18 95       	reti

0000045e <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     45e:	e8 e1       	ldi	r30, 0x18	; 24
     460:	f1 e0       	ldi	r31, 0x01	; 1
     462:	ac e1       	ldi	r26, 0x1C	; 28
     464:	b1 e0       	ldi	r27, 0x01	; 1
     466:	b1 83       	std	Z+1, r27	; 0x01
     468:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     46a:	13 82       	std	Z+3, r1	; 0x03
     46c:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     46e:	e4 ef       	ldi	r30, 0xF4	; 244
     470:	f6 e0       	ldi	r31, 0x06	; 6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     472:	f0 93 17 01 	sts	0x0117, r31	; 0x800117 <pxEnd+0x1>
     476:	e0 93 16 01 	sts	0x0116, r30	; 0x800116 <pxEnd>
	pxEnd->xBlockSize = 0;
     47a:	13 82       	std	Z+3, r1	; 0x03
     47c:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     47e:	11 82       	std	Z+1, r1	; 0x01
     480:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     482:	88 ed       	ldi	r24, 0xD8	; 216
     484:	95 e0       	ldi	r25, 0x05	; 5
     486:	13 96       	adiw	r26, 0x03	; 3
     488:	9c 93       	st	X, r25
     48a:	8e 93       	st	-X, r24
     48c:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     48e:	ed 93       	st	X+, r30
     490:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     492:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     496:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     49a:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     49e:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e8       	ldi	r25, 0x80	; 128
     4a6:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <__data_end+0x1>
     4aa:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>
     4ae:	08 95       	ret

000004b0 <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
     4b4:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     4b6:	a8 e1       	ldi	r26, 0x18	; 24
     4b8:	b1 e0       	ldi	r27, 0x01	; 1
     4ba:	01 c0       	rjmp	.+2      	; 0x4be <prvInsertBlockIntoFreeList+0xe>
     4bc:	df 01       	movw	r26, r30
     4be:	ed 91       	ld	r30, X+
     4c0:	fc 91       	ld	r31, X
     4c2:	11 97       	sbiw	r26, 0x01	; 1
     4c4:	ec 17       	cp	r30, r28
     4c6:	fd 07       	cpc	r31, r29
     4c8:	c8 f3       	brcs	.-14     	; 0x4bc <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     4ca:	12 96       	adiw	r26, 0x02	; 2
     4cc:	8d 91       	ld	r24, X+
     4ce:	9c 91       	ld	r25, X
     4d0:	13 97       	sbiw	r26, 0x03	; 3
     4d2:	9d 01       	movw	r18, r26
     4d4:	28 0f       	add	r18, r24
     4d6:	39 1f       	adc	r19, r25
     4d8:	c2 17       	cp	r28, r18
     4da:	d3 07       	cpc	r29, r19
     4dc:	49 f4       	brne	.+18     	; 0x4f0 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     4de:	2a 81       	ldd	r18, Y+2	; 0x02
     4e0:	3b 81       	ldd	r19, Y+3	; 0x03
     4e2:	82 0f       	add	r24, r18
     4e4:	93 1f       	adc	r25, r19
     4e6:	13 96       	adiw	r26, 0x03	; 3
     4e8:	9c 93       	st	X, r25
     4ea:	8e 93       	st	-X, r24
     4ec:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     4ee:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     4f0:	8a 81       	ldd	r24, Y+2	; 0x02
     4f2:	9b 81       	ldd	r25, Y+3	; 0x03
     4f4:	9e 01       	movw	r18, r28
     4f6:	28 0f       	add	r18, r24
     4f8:	39 1f       	adc	r19, r25
     4fa:	e2 17       	cp	r30, r18
     4fc:	f3 07       	cpc	r31, r19
     4fe:	c1 f4       	brne	.+48     	; 0x530 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     500:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <pxEnd>
     504:	30 91 17 01 	lds	r19, 0x0117	; 0x800117 <pxEnd+0x1>
     508:	e2 17       	cp	r30, r18
     50a:	f3 07       	cpc	r31, r19
     50c:	71 f0       	breq	.+28     	; 0x52a <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     50e:	22 81       	ldd	r18, Z+2	; 0x02
     510:	33 81       	ldd	r19, Z+3	; 0x03
     512:	82 0f       	add	r24, r18
     514:	93 1f       	adc	r25, r19
     516:	9b 83       	std	Y+3, r25	; 0x03
     518:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     51a:	ed 91       	ld	r30, X+
     51c:	fc 91       	ld	r31, X
     51e:	11 97       	sbiw	r26, 0x01	; 1
     520:	80 81       	ld	r24, Z
     522:	91 81       	ldd	r25, Z+1	; 0x01
     524:	99 83       	std	Y+1, r25	; 0x01
     526:	88 83       	st	Y, r24
     528:	05 c0       	rjmp	.+10     	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     52a:	39 83       	std	Y+1, r19	; 0x01
     52c:	28 83       	st	Y, r18
     52e:	02 c0       	rjmp	.+4      	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     530:	f9 83       	std	Y+1, r31	; 0x01
     532:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     534:	ca 17       	cp	r28, r26
     536:	db 07       	cpc	r29, r27
     538:	11 f0       	breq	.+4      	; 0x53e <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     53a:	cd 93       	st	X+, r28
     53c:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	08 95       	ret

00000544 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     544:	ef 92       	push	r14
     546:	ff 92       	push	r15
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
     54c:	cf 93       	push	r28
     54e:	df 93       	push	r29
     550:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     552:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     556:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <pxEnd>
     55a:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <pxEnd+0x1>
     55e:	89 2b       	or	r24, r25
     560:	11 f4       	brne	.+4      	; 0x566 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     562:	0e 94 2f 02 	call	0x45e	; 0x45e <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     566:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
     56a:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
     56e:	80 23       	and	r24, r16
     570:	91 23       	and	r25, r17
     572:	89 2b       	or	r24, r25
     574:	09 f0       	breq	.+2      	; 0x578 <pvPortMalloc+0x34>
     576:	67 c0       	rjmp	.+206    	; 0x646 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     578:	01 15       	cp	r16, r1
     57a:	11 05       	cpc	r17, r1
     57c:	11 f0       	breq	.+4      	; 0x582 <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     57e:	0c 5f       	subi	r16, 0xFC	; 252
     580:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     582:	01 15       	cp	r16, r1
     584:	11 05       	cpc	r17, r1
     586:	09 f4       	brne	.+2      	; 0x58a <pvPortMalloc+0x46>
     588:	61 c0       	rjmp	.+194    	; 0x64c <pvPortMalloc+0x108>
     58a:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xFreeBytesRemaining>
     58e:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     592:	80 17       	cp	r24, r16
     594:	91 07       	cpc	r25, r17
     596:	08 f4       	brcc	.+2      	; 0x59a <pvPortMalloc+0x56>
     598:	5c c0       	rjmp	.+184    	; 0x652 <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     59a:	c0 91 18 01 	lds	r28, 0x0118	; 0x800118 <xStart>
     59e:	d0 91 19 01 	lds	r29, 0x0119	; 0x800119 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5a2:	e8 e1       	ldi	r30, 0x18	; 24
     5a4:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5a6:	02 c0       	rjmp	.+4      	; 0x5ac <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     5a8:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     5aa:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5ac:	8a 81       	ldd	r24, Y+2	; 0x02
     5ae:	9b 81       	ldd	r25, Y+3	; 0x03
     5b0:	80 17       	cp	r24, r16
     5b2:	91 07       	cpc	r25, r17
     5b4:	20 f4       	brcc	.+8      	; 0x5be <pvPortMalloc+0x7a>
     5b6:	88 81       	ld	r24, Y
     5b8:	99 81       	ldd	r25, Y+1	; 0x01
     5ba:	00 97       	sbiw	r24, 0x00	; 0
     5bc:	a9 f7       	brne	.-22     	; 0x5a8 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     5be:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <pxEnd>
     5c2:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <pxEnd+0x1>
     5c6:	c8 17       	cp	r28, r24
     5c8:	d9 07       	cpc	r29, r25
     5ca:	09 f4       	brne	.+2      	; 0x5ce <pvPortMalloc+0x8a>
     5cc:	45 c0       	rjmp	.+138    	; 0x658 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     5ce:	e0 80       	ld	r14, Z
     5d0:	f1 80       	ldd	r15, Z+1	; 0x01
     5d2:	84 e0       	ldi	r24, 0x04	; 4
     5d4:	e8 0e       	add	r14, r24
     5d6:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5d8:	88 81       	ld	r24, Y
     5da:	99 81       	ldd	r25, Y+1	; 0x01
     5dc:	91 83       	std	Z+1, r25	; 0x01
     5de:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5e0:	2a 81       	ldd	r18, Y+2	; 0x02
     5e2:	3b 81       	ldd	r19, Y+3	; 0x03
     5e4:	20 1b       	sub	r18, r16
     5e6:	31 0b       	sbc	r19, r17
     5e8:	29 30       	cpi	r18, 0x09	; 9
     5ea:	31 05       	cpc	r19, r1
     5ec:	50 f0       	brcs	.+20     	; 0x602 <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5ee:	ce 01       	movw	r24, r28
     5f0:	80 0f       	add	r24, r16
     5f2:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5f4:	fc 01       	movw	r30, r24
     5f6:	33 83       	std	Z+3, r19	; 0x03
     5f8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     5fa:	1b 83       	std	Y+3, r17	; 0x03
     5fc:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     5fe:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     602:	2a 81       	ldd	r18, Y+2	; 0x02
     604:	3b 81       	ldd	r19, Y+3	; 0x03
     606:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xFreeBytesRemaining>
     60a:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     60e:	82 1b       	sub	r24, r18
     610:	93 0b       	sbc	r25, r19
     612:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     616:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     61a:	40 91 12 01 	lds	r20, 0x0112	; 0x800112 <xMinimumEverFreeBytesRemaining>
     61e:	50 91 13 01 	lds	r21, 0x0113	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     622:	84 17       	cp	r24, r20
     624:	95 07       	cpc	r25, r21
     626:	20 f4       	brcc	.+8      	; 0x630 <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     628:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     62c:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     630:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
     634:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
     638:	28 2b       	or	r18, r24
     63a:	39 2b       	or	r19, r25
     63c:	3b 83       	std	Y+3, r19	; 0x03
     63e:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     640:	19 82       	std	Y+1, r1	; 0x01
     642:	18 82       	st	Y, r1
     644:	0b c0       	rjmp	.+22     	; 0x65c <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     646:	e1 2c       	mov	r14, r1
     648:	f1 2c       	mov	r15, r1
     64a:	08 c0       	rjmp	.+16     	; 0x65c <pvPortMalloc+0x118>
     64c:	e1 2c       	mov	r14, r1
     64e:	f1 2c       	mov	r15, r1
     650:	05 c0       	rjmp	.+10     	; 0x65c <pvPortMalloc+0x118>
     652:	e1 2c       	mov	r14, r1
     654:	f1 2c       	mov	r15, r1
     656:	02 c0       	rjmp	.+4      	; 0x65c <pvPortMalloc+0x118>
     658:	e1 2c       	mov	r14, r1
     65a:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     65c:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     660:	c7 01       	movw	r24, r14
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	1f 91       	pop	r17
     668:	0f 91       	pop	r16
     66a:	ff 90       	pop	r15
     66c:	ef 90       	pop	r14
     66e:	08 95       	ret

00000670 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     678:	00 97       	sbiw	r24, 0x00	; 0
     67a:	51 f1       	breq	.+84     	; 0x6d0 <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     67c:	ec 01       	movw	r28, r24
     67e:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     680:	4a 81       	ldd	r20, Y+2	; 0x02
     682:	5b 81       	ldd	r21, Y+3	; 0x03
     684:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <__data_end>
     688:	30 91 11 01 	lds	r19, 0x0111	; 0x800111 <__data_end+0x1>
     68c:	ba 01       	movw	r22, r20
     68e:	62 23       	and	r22, r18
     690:	73 23       	and	r23, r19
     692:	67 2b       	or	r22, r23
     694:	e9 f0       	breq	.+58     	; 0x6d0 <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     696:	68 81       	ld	r22, Y
     698:	79 81       	ldd	r23, Y+1	; 0x01
     69a:	67 2b       	or	r22, r23
     69c:	c9 f4       	brne	.+50     	; 0x6d0 <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     69e:	20 95       	com	r18
     6a0:	30 95       	com	r19
     6a2:	24 23       	and	r18, r20
     6a4:	35 23       	and	r19, r21
     6a6:	3b 83       	std	Y+3, r19	; 0x03
     6a8:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     6aa:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	9b 81       	ldd	r25, Y+3	; 0x03
     6b2:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <xFreeBytesRemaining>
     6b6:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     6ba:	82 0f       	add	r24, r18
     6bc:	93 1f       	adc	r25, r19
     6be:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     6c2:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     6c6:	ce 01       	movw	r24, r28
     6c8:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     6cc:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	08 95       	ret

000006da <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6da:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     6de:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     6e2:	80 81       	ld	r24, Z
     6e4:	81 11       	cpse	r24, r1
     6e6:	07 c0       	rjmp	.+14     	; 0x6f6 <prvResetNextTaskUnblockTime+0x1c>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	9f ef       	ldi	r25, 0xFF	; 255
     6ec:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     6f0:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     6f4:	08 95       	ret
     6f6:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     6fa:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     6fe:	05 80       	ldd	r0, Z+5	; 0x05
     700:	f6 81       	ldd	r31, Z+6	; 0x06
     702:	e0 2d       	mov	r30, r0
     704:	06 80       	ldd	r0, Z+6	; 0x06
     706:	f7 81       	ldd	r31, Z+7	; 0x07
     708:	e0 2d       	mov	r30, r0
     70a:	82 81       	ldd	r24, Z+2	; 0x02
     70c:	93 81       	ldd	r25, Z+3	; 0x03
     70e:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     712:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     716:	08 95       	ret

00000718 <prvInitialiseNewTask>:
     718:	6f 92       	push	r6
     71a:	7f 92       	push	r7
     71c:	8f 92       	push	r8
     71e:	9f 92       	push	r9
     720:	af 92       	push	r10
     722:	bf 92       	push	r11
     724:	cf 92       	push	r12
     726:	df 92       	push	r13
     728:	ef 92       	push	r14
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	cd b7       	in	r28, 0x3d	; 61
     734:	de b7       	in	r29, 0x3e	; 62
     736:	4c 01       	movw	r8, r24
     738:	f5 01       	movw	r30, r10
     73a:	87 89       	ldd	r24, Z+23	; 0x17
     73c:	90 8d       	ldd	r25, Z+24	; 0x18
     73e:	21 50       	subi	r18, 0x01	; 1
     740:	31 09       	sbc	r19, r1
     742:	3c 01       	movw	r6, r24
     744:	62 0e       	add	r6, r18
     746:	73 1e       	adc	r7, r19
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	0f c0       	rjmp	.+30     	; 0x76a <prvInitialiseNewTask+0x52>
     74c:	82 2f       	mov	r24, r18
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	fb 01       	movw	r30, r22
     752:	e8 0f       	add	r30, r24
     754:	f9 1f       	adc	r31, r25
     756:	30 81       	ld	r19, Z
     758:	d5 01       	movw	r26, r10
     75a:	a8 0f       	add	r26, r24
     75c:	b9 1f       	adc	r27, r25
     75e:	59 96       	adiw	r26, 0x19	; 25
     760:	3c 93       	st	X, r19
     762:	80 81       	ld	r24, Z
     764:	88 23       	and	r24, r24
     766:	19 f0       	breq	.+6      	; 0x76e <prvInitialiseNewTask+0x56>
     768:	2f 5f       	subi	r18, 0xFF	; 255
     76a:	28 30       	cpi	r18, 0x08	; 8
     76c:	78 f3       	brcs	.-34     	; 0x74c <prvInitialiseNewTask+0x34>
     76e:	f5 01       	movw	r30, r10
     770:	10 a2       	std	Z+32, r1	; 0x20
     772:	f3 e0       	ldi	r31, 0x03	; 3
     774:	fe 15       	cp	r31, r14
     776:	20 f4       	brcc	.+8      	; 0x780 <prvInitialiseNewTask+0x68>
     778:	0f 2e       	mov	r0, r31
     77a:	f3 e0       	ldi	r31, 0x03	; 3
     77c:	ef 2e       	mov	r14, r31
     77e:	f0 2d       	mov	r31, r0
     780:	f5 01       	movw	r30, r10
     782:	e6 8a       	std	Z+22, r14	; 0x16
     784:	c5 01       	movw	r24, r10
     786:	02 96       	adiw	r24, 0x02	; 2
     788:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     78c:	c5 01       	movw	r24, r10
     78e:	0c 96       	adiw	r24, 0x0c	; 12
     790:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     794:	f5 01       	movw	r30, r10
     796:	b1 86       	std	Z+9, r11	; 0x09
     798:	a0 86       	std	Z+8, r10	; 0x08
     79a:	84 e0       	ldi	r24, 0x04	; 4
     79c:	90 e0       	ldi	r25, 0x00	; 0
     79e:	8e 19       	sub	r24, r14
     7a0:	91 09       	sbc	r25, r1
     7a2:	95 87       	std	Z+13, r25	; 0x0d
     7a4:	84 87       	std	Z+12, r24	; 0x0c
     7a6:	b3 8a       	std	Z+19, r11	; 0x13
     7a8:	a2 8a       	std	Z+18, r10	; 0x12
     7aa:	11 a2       	std	Z+33, r1	; 0x21
     7ac:	12 a2       	std	Z+34, r1	; 0x22
     7ae:	13 a2       	std	Z+35, r1	; 0x23
     7b0:	14 a2       	std	Z+36, r1	; 0x24
     7b2:	15 a2       	std	Z+37, r1	; 0x25
     7b4:	a8 01       	movw	r20, r16
     7b6:	b4 01       	movw	r22, r8
     7b8:	c3 01       	movw	r24, r6
     7ba:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <pxPortInitialiseStack>
     7be:	f5 01       	movw	r30, r10
     7c0:	91 83       	std	Z+1, r25	; 0x01
     7c2:	80 83       	st	Z, r24
     7c4:	c1 14       	cp	r12, r1
     7c6:	d1 04       	cpc	r13, r1
     7c8:	19 f0       	breq	.+6      	; 0x7d0 <prvInitialiseNewTask+0xb8>
     7ca:	f6 01       	movw	r30, r12
     7cc:	b1 82       	std	Z+1, r11	; 0x01
     7ce:	a0 82       	st	Z, r10
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	ef 90       	pop	r14
     7da:	df 90       	pop	r13
     7dc:	cf 90       	pop	r12
     7de:	bf 90       	pop	r11
     7e0:	af 90       	pop	r10
     7e2:	9f 90       	pop	r9
     7e4:	8f 90       	pop	r8
     7e6:	7f 90       	pop	r7
     7e8:	6f 90       	pop	r6
     7ea:	08 95       	ret

000007ec <prvIdleTask>:
     7ec:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxReadyTasksLists>
     7f0:	82 30       	cpi	r24, 0x02	; 2
     7f2:	e0 f3       	brcs	.-8      	; 0x7ec <prvIdleTask>
     7f4:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     7f8:	f9 cf       	rjmp	.-14     	; 0x7ec <prvIdleTask>

000007fa <prvInitialiseTaskLists>:
     7fa:	cf 93       	push	r28
     7fc:	c0 e0       	ldi	r28, 0x00	; 0
     7fe:	10 c0       	rjmp	.+32     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     800:	8c 2f       	mov	r24, r28
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	9c 01       	movw	r18, r24
     806:	22 0f       	add	r18, r18
     808:	33 1f       	adc	r19, r19
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	22 0f       	add	r18, r18
     810:	33 1f       	adc	r19, r19
     812:	82 0f       	add	r24, r18
     814:	93 1f       	adc	r25, r19
     816:	8b 5d       	subi	r24, 0xDB	; 219
     818:	98 4f       	sbci	r25, 0xF8	; 248
     81a:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     81e:	cf 5f       	subi	r28, 0xFF	; 255
     820:	c4 30       	cpi	r28, 0x04	; 4
     822:	70 f3       	brcs	.-36     	; 0x800 <__DATA_REGION_LENGTH__>
     824:	8c e1       	ldi	r24, 0x1C	; 28
     826:	97 e0       	ldi	r25, 0x07	; 7
     828:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     82c:	83 e1       	ldi	r24, 0x13	; 19
     82e:	97 e0       	ldi	r25, 0x07	; 7
     830:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     834:	86 e0       	ldi	r24, 0x06	; 6
     836:	97 e0       	ldi	r25, 0x07	; 7
     838:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     83c:	8c e1       	ldi	r24, 0x1C	; 28
     83e:	97 e0       	ldi	r25, 0x07	; 7
     840:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <pxDelayedTaskList+0x1>
     844:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <pxDelayedTaskList>
     848:	83 e1       	ldi	r24, 0x13	; 19
     84a:	97 e0       	ldi	r25, 0x07	; 7
     84c:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     850:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <pxOverflowDelayedTaskList>
     854:	cf 91       	pop	r28
     856:	08 95       	ret

00000858 <prvAddNewTaskToReadyList>:
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	ec 01       	movw	r28, r24
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     868:	8f 5f       	subi	r24, 0xFF	; 255
     86a:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxCurrentNumberOfTasks>
     86e:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <pxCurrentTCB>
     872:	90 91 4a 07 	lds	r25, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     876:	89 2b       	or	r24, r25
     878:	59 f4       	brne	.+22     	; 0x890 <__stack+0x31>
     87a:	d0 93 4a 07 	sts	0x074A, r29	; 0x80074a <pxCurrentTCB+0x1>
     87e:	c0 93 49 07 	sts	0x0749, r28	; 0x800749 <pxCurrentTCB>
     882:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     886:	81 30       	cpi	r24, 0x01	; 1
     888:	99 f4       	brne	.+38     	; 0x8b0 <__stack+0x51>
     88a:	0e 94 fd 03 	call	0x7fa	; 0x7fa <prvInitialiseTaskLists>
     88e:	10 c0       	rjmp	.+32     	; 0x8b0 <__stack+0x51>
     890:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xSchedulerRunning>
     894:	81 11       	cpse	r24, r1
     896:	0c c0       	rjmp	.+24     	; 0x8b0 <__stack+0x51>
     898:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     89c:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     8a0:	96 89       	ldd	r25, Z+22	; 0x16
     8a2:	8e 89       	ldd	r24, Y+22	; 0x16
     8a4:	89 17       	cp	r24, r25
     8a6:	20 f0       	brcs	.+8      	; 0x8b0 <__stack+0x51>
     8a8:	d0 93 4a 07 	sts	0x074A, r29	; 0x80074a <pxCurrentTCB+0x1>
     8ac:	c0 93 49 07 	sts	0x0749, r28	; 0x800749 <pxCurrentTCB>
     8b0:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxTaskNumber>
     8b4:	8f 5f       	subi	r24, 0xFF	; 255
     8b6:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxTaskNumber>
     8ba:	8e 89       	ldd	r24, Y+22	; 0x16
     8bc:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     8c0:	98 17       	cp	r25, r24
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <__stack+0x69>
     8c4:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	9c 01       	movw	r18, r24
     8cc:	22 0f       	add	r18, r18
     8ce:	33 1f       	adc	r19, r19
     8d0:	22 0f       	add	r18, r18
     8d2:	33 1f       	adc	r19, r19
     8d4:	22 0f       	add	r18, r18
     8d6:	33 1f       	adc	r19, r19
     8d8:	82 0f       	add	r24, r18
     8da:	93 1f       	adc	r25, r19
     8dc:	be 01       	movw	r22, r28
     8de:	6e 5f       	subi	r22, 0xFE	; 254
     8e0:	7f 4f       	sbci	r23, 0xFF	; 255
     8e2:	8b 5d       	subi	r24, 0xDB	; 219
     8e4:	98 4f       	sbci	r25, 0xF8	; 248
     8e6:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xSchedulerRunning>
     8f2:	88 23       	and	r24, r24
     8f4:	51 f0       	breq	.+20     	; 0x90a <__stack+0xab>
     8f6:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     8fa:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     8fe:	96 89       	ldd	r25, Z+22	; 0x16
     900:	8e 89       	ldd	r24, Y+22	; 0x16
     902:	98 17       	cp	r25, r24
     904:	10 f4       	brcc	.+4      	; 0x90a <__stack+0xab>
     906:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     90a:	df 91       	pop	r29
     90c:	cf 91       	pop	r28
     90e:	08 95       	ret

00000910 <prvAddCurrentTaskToDelayedList>:
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
     918:	ec 01       	movw	r28, r24
     91a:	00 91 03 07 	lds	r16, 0x0703	; 0x800703 <xTickCount>
     91e:	10 91 04 07 	lds	r17, 0x0704	; 0x800704 <xTickCount+0x1>
     922:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <pxCurrentTCB>
     926:	90 91 4a 07 	lds	r25, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     92a:	02 96       	adiw	r24, 0x02	; 2
     92c:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
     930:	c0 0f       	add	r28, r16
     932:	d1 1f       	adc	r29, r17
     934:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     938:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     93c:	d3 83       	std	Z+3, r29	; 0x03
     93e:	c2 83       	std	Z+2, r28	; 0x02
     940:	c0 17       	cp	r28, r16
     942:	d1 07       	cpc	r29, r17
     944:	68 f4       	brcc	.+26     	; 0x960 <prvAddCurrentTaskToDelayedList+0x50>
     946:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <pxCurrentTCB>
     94a:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     94e:	80 91 0f 07 	lds	r24, 0x070F	; 0x80070f <pxOverflowDelayedTaskList>
     952:	90 91 10 07 	lds	r25, 0x0710	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     956:	6e 5f       	subi	r22, 0xFE	; 254
     958:	7f 4f       	sbci	r23, 0xFF	; 255
     95a:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     95e:	17 c0       	rjmp	.+46     	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     960:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <pxCurrentTCB>
     964:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     968:	80 91 11 07 	lds	r24, 0x0711	; 0x800711 <pxDelayedTaskList>
     96c:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     970:	6e 5f       	subi	r22, 0xFE	; 254
     972:	7f 4f       	sbci	r23, 0xFF	; 255
     974:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     978:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <xNextTaskUnblockTime>
     97c:	90 91 fc 06 	lds	r25, 0x06FC	; 0x8006fc <xNextTaskUnblockTime+0x1>
     980:	c8 17       	cp	r28, r24
     982:	d9 07       	cpc	r29, r25
     984:	20 f4       	brcc	.+8      	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     986:	d0 93 fc 06 	sts	0x06FC, r29	; 0x8006fc <xNextTaskUnblockTime+0x1>
     98a:	c0 93 fb 06 	sts	0x06FB, r28	; 0x8006fb <xNextTaskUnblockTime>
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	08 95       	ret

00000998 <xTaskCreate>:
     998:	2f 92       	push	r2
     99a:	3f 92       	push	r3
     99c:	4f 92       	push	r4
     99e:	5f 92       	push	r5
     9a0:	6f 92       	push	r6
     9a2:	7f 92       	push	r7
     9a4:	8f 92       	push	r8
     9a6:	9f 92       	push	r9
     9a8:	af 92       	push	r10
     9aa:	bf 92       	push	r11
     9ac:	cf 92       	push	r12
     9ae:	df 92       	push	r13
     9b0:	ef 92       	push	r14
     9b2:	ff 92       	push	r15
     9b4:	0f 93       	push	r16
     9b6:	1f 93       	push	r17
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
     9bc:	3c 01       	movw	r6, r24
     9be:	1b 01       	movw	r2, r22
     9c0:	5a 01       	movw	r10, r20
     9c2:	29 01       	movw	r4, r18
     9c4:	ca 01       	movw	r24, r20
     9c6:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9ca:	6c 01       	movw	r12, r24
     9cc:	89 2b       	or	r24, r25
     9ce:	71 f0       	breq	.+28     	; 0x9ec <xTaskCreate+0x54>
     9d0:	86 e2       	ldi	r24, 0x26	; 38
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9d8:	ec 01       	movw	r28, r24
     9da:	89 2b       	or	r24, r25
     9dc:	19 f0       	breq	.+6      	; 0x9e4 <xTaskCreate+0x4c>
     9de:	d8 8e       	std	Y+24, r13	; 0x18
     9e0:	cf 8a       	std	Y+23, r12	; 0x17
     9e2:	06 c0       	rjmp	.+12     	; 0x9f0 <xTaskCreate+0x58>
     9e4:	c6 01       	movw	r24, r12
     9e6:	0e 94 38 03 	call	0x670	; 0x670 <vPortFree>
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <xTaskCreate+0x58>
     9ec:	c0 e0       	ldi	r28, 0x00	; 0
     9ee:	d0 e0       	ldi	r29, 0x00	; 0
     9f0:	20 97       	sbiw	r28, 0x00	; 0
     9f2:	91 f0       	breq	.+36     	; 0xa18 <xTaskCreate+0x80>
     9f4:	95 01       	movw	r18, r10
     9f6:	40 e0       	ldi	r20, 0x00	; 0
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	81 2c       	mov	r8, r1
     9fc:	91 2c       	mov	r9, r1
     9fe:	5e 01       	movw	r10, r28
     a00:	67 01       	movw	r12, r14
     a02:	e0 2e       	mov	r14, r16
     a04:	82 01       	movw	r16, r4
     a06:	b1 01       	movw	r22, r2
     a08:	c3 01       	movw	r24, r6
     a0a:	0e 94 8c 03 	call	0x718	; 0x718 <prvInitialiseNewTask>
     a0e:	ce 01       	movw	r24, r28
     a10:	0e 94 2c 04 	call	0x858	; 0x858 <prvAddNewTaskToReadyList>
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <xTaskCreate+0x82>
     a18:	8f ef       	ldi	r24, 0xFF	; 255
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	3f 90       	pop	r3
     a3c:	2f 90       	pop	r2
     a3e:	08 95       	ret

00000a40 <vTaskStartScheduler>:
     a40:	ef 92       	push	r14
     a42:	ff 92       	push	r15
     a44:	0f 93       	push	r16
     a46:	0f 2e       	mov	r0, r31
     a48:	f9 ef       	ldi	r31, 0xF9	; 249
     a4a:	ef 2e       	mov	r14, r31
     a4c:	f6 e0       	ldi	r31, 0x06	; 6
     a4e:	ff 2e       	mov	r15, r31
     a50:	f0 2d       	mov	r31, r0
     a52:	00 e0       	ldi	r16, 0x00	; 0
     a54:	20 e0       	ldi	r18, 0x00	; 0
     a56:	30 e0       	ldi	r19, 0x00	; 0
     a58:	45 e5       	ldi	r20, 0x55	; 85
     a5a:	50 e0       	ldi	r21, 0x00	; 0
     a5c:	6f e6       	ldi	r22, 0x6F	; 111
     a5e:	70 e0       	ldi	r23, 0x00	; 0
     a60:	86 ef       	ldi	r24, 0xF6	; 246
     a62:	93 e0       	ldi	r25, 0x03	; 3
     a64:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
     a68:	81 30       	cpi	r24, 0x01	; 1
     a6a:	81 f4       	brne	.+32     	; 0xa8c <vTaskStartScheduler+0x4c>
     a6c:	f8 94       	cli
     a6e:	8f ef       	ldi	r24, 0xFF	; 255
     a70:	9f ef       	ldi	r25, 0xFF	; 255
     a72:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     a76:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xSchedulerRunning>
     a80:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xTickCount+0x1>
     a84:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <xTickCount>
     a88:	0e 94 48 01 	call	0x290	; 0x290 <xPortStartScheduler>
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	08 95       	ret

00000a94 <vTaskSuspendAll>:
     a94:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     a98:	8f 5f       	subi	r24, 0xFF	; 255
     a9a:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <uxSchedulerSuspended>
     a9e:	08 95       	ret

00000aa0 <xTaskGetTickCount>:
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	0f 92       	push	r0
     aa6:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     aaa:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63
     ab2:	08 95       	ret

00000ab4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ab4:	df 92       	push	r13
     ab6:	ef 92       	push	r14
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ac2:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     ac6:	81 11       	cpse	r24, r1
     ac8:	97 c0       	rjmp	.+302    	; 0xbf8 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     aca:	e0 90 03 07 	lds	r14, 0x0703	; 0x800703 <xTickCount>
     ace:	f0 90 04 07 	lds	r15, 0x0704	; 0x800704 <xTickCount+0x1>
     ad2:	8f ef       	ldi	r24, 0xFF	; 255
     ad4:	e8 1a       	sub	r14, r24
     ad6:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     ad8:	f0 92 04 07 	sts	0x0704, r15	; 0x800704 <xTickCount+0x1>
     adc:	e0 92 03 07 	sts	0x0703, r14	; 0x800703 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     ae0:	e1 14       	cp	r14, r1
     ae2:	f1 04       	cpc	r15, r1
     ae4:	b9 f4       	brne	.+46     	; 0xb14 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     ae6:	80 91 11 07 	lds	r24, 0x0711	; 0x800711 <pxDelayedTaskList>
     aea:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     aee:	20 91 0f 07 	lds	r18, 0x070F	; 0x80070f <pxOverflowDelayedTaskList>
     af2:	30 91 10 07 	lds	r19, 0x0710	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     af6:	30 93 12 07 	sts	0x0712, r19	; 0x800712 <pxDelayedTaskList+0x1>
     afa:	20 93 11 07 	sts	0x0711, r18	; 0x800711 <pxDelayedTaskList>
     afe:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     b02:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <pxOverflowDelayedTaskList>
     b06:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <xNumOfOverflows>
     b0a:	8f 5f       	subi	r24, 0xFF	; 255
     b0c:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <xNumOfOverflows>
     b10:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b14:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <xNextTaskUnblockTime>
     b18:	90 91 fc 06 	lds	r25, 0x06FC	; 0x8006fc <xNextTaskUnblockTime+0x1>
     b1c:	e8 16       	cp	r14, r24
     b1e:	f9 06       	cpc	r15, r25
     b20:	28 f4       	brcc	.+10     	; 0xb2c <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b22:	d1 2c       	mov	r13, r1
     b24:	53 c0       	rjmp	.+166    	; 0xbcc <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b26:	dd 24       	eor	r13, r13
     b28:	d3 94       	inc	r13
     b2a:	01 c0       	rjmp	.+2      	; 0xb2e <xTaskIncrementTick+0x7a>
     b2c:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b2e:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     b32:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     b36:	80 81       	ld	r24, Z
     b38:	81 11       	cpse	r24, r1
     b3a:	07 c0       	rjmp	.+14     	; 0xb4a <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b3c:	8f ef       	ldi	r24, 0xFF	; 255
     b3e:	9f ef       	ldi	r25, 0xFF	; 255
     b40:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     b44:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
					break;
     b48:	41 c0       	rjmp	.+130    	; 0xbcc <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b4a:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     b4e:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     b52:	05 80       	ldd	r0, Z+5	; 0x05
     b54:	f6 81       	ldd	r31, Z+6	; 0x06
     b56:	e0 2d       	mov	r30, r0
     b58:	c6 81       	ldd	r28, Z+6	; 0x06
     b5a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b5c:	8a 81       	ldd	r24, Y+2	; 0x02
     b5e:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     b60:	e8 16       	cp	r14, r24
     b62:	f9 06       	cpc	r15, r25
     b64:	28 f4       	brcc	.+10     	; 0xb70 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b66:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     b6a:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
						break;
     b6e:	2e c0       	rjmp	.+92     	; 0xbcc <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b70:	8e 01       	movw	r16, r28
     b72:	0e 5f       	subi	r16, 0xFE	; 254
     b74:	1f 4f       	sbci	r17, 0xFF	; 255
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b7c:	8c 89       	ldd	r24, Y+20	; 0x14
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	89 2b       	or	r24, r25
     b82:	21 f0       	breq	.+8      	; 0xb8c <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b84:	ce 01       	movw	r24, r28
     b86:	0c 96       	adiw	r24, 0x0c	; 12
     b88:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b8c:	8e 89       	ldd	r24, Y+22	; 0x16
     b8e:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     b92:	98 17       	cp	r25, r24
     b94:	10 f4       	brcc	.+4      	; 0xb9a <xTaskIncrementTick+0xe6>
     b96:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	9c 01       	movw	r18, r24
     b9e:	22 0f       	add	r18, r18
     ba0:	33 1f       	adc	r19, r19
     ba2:	22 0f       	add	r18, r18
     ba4:	33 1f       	adc	r19, r19
     ba6:	22 0f       	add	r18, r18
     ba8:	33 1f       	adc	r19, r19
     baa:	82 0f       	add	r24, r18
     bac:	93 1f       	adc	r25, r19
     bae:	b8 01       	movw	r22, r16
     bb0:	8b 5d       	subi	r24, 0xDB	; 219
     bb2:	98 4f       	sbci	r25, 0xF8	; 248
     bb4:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bb8:	9e 89       	ldd	r25, Y+22	; 0x16
     bba:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     bbe:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	98 17       	cp	r25, r24
     bc6:	08 f0       	brcs	.+2      	; 0xbca <xTaskIncrementTick+0x116>
     bc8:	ae cf       	rjmp	.-164    	; 0xb26 <xTaskIncrementTick+0x72>
     bca:	b1 cf       	rjmp	.-158    	; 0xb2e <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bcc:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     bd0:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     bd4:	86 89       	ldd	r24, Z+22	; 0x16
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	ee 0f       	add	r30, r30
     bdc:	ff 1f       	adc	r31, r31
     bde:	ee 0f       	add	r30, r30
     be0:	ff 1f       	adc	r31, r31
     be2:	ee 0f       	add	r30, r30
     be4:	ff 1f       	adc	r31, r31
     be6:	8e 0f       	add	r24, r30
     be8:	9f 1f       	adc	r25, r31
     bea:	fc 01       	movw	r30, r24
     bec:	eb 5d       	subi	r30, 0xDB	; 219
     bee:	f8 4f       	sbci	r31, 0xF8	; 248
     bf0:	80 81       	ld	r24, Z
     bf2:	82 30       	cpi	r24, 0x02	; 2
     bf4:	40 f4       	brcc	.+16     	; 0xc06 <xTaskIncrementTick+0x152>
     bf6:	09 c0       	rjmp	.+18     	; 0xc0a <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bf8:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxPendedTicks>
     bfc:	8f 5f       	subi	r24, 0xFF	; 255
     bfe:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c02:	d1 2c       	mov	r13, r1
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c06:	dd 24       	eor	r13, r13
     c08:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c0a:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xYieldPending>
     c0e:	88 23       	and	r24, r24
     c10:	11 f0       	breq	.+4      	; 0xc16 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c12:	dd 24       	eor	r13, r13
     c14:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c16:	8d 2d       	mov	r24, r13
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	df 90       	pop	r13
     c26:	08 95       	ret

00000c28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c28:	0f 93       	push	r16
     c2a:	1f 93       	push	r17
     c2c:	cf 93       	push	r28
     c2e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c36:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     c3a:	81 50       	subi	r24, 0x01	; 1
     c3c:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c40:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     c44:	81 11       	cpse	r24, r1
     c46:	58 c0       	rjmp	.+176    	; 0xcf8 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c48:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     c4c:	81 11       	cpse	r24, r1
     c4e:	33 c0       	rjmp	.+102    	; 0xcb6 <xTaskResumeAll+0x8e>
     c50:	56 c0       	rjmp	.+172    	; 0xcfe <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c52:	e0 91 0b 07 	lds	r30, 0x070B	; 0x80070b <xPendingReadyList+0x5>
     c56:	f0 91 0c 07 	lds	r31, 0x070C	; 0x80070c <xPendingReadyList+0x6>
     c5a:	c6 81       	ldd	r28, Z+6	; 0x06
     c5c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c5e:	ce 01       	movw	r24, r28
     c60:	0c 96       	adiw	r24, 0x0c	; 12
     c62:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c66:	8e 01       	movw	r16, r28
     c68:	0e 5f       	subi	r16, 0xFE	; 254
     c6a:	1f 4f       	sbci	r17, 0xFF	; 255
     c6c:	c8 01       	movw	r24, r16
     c6e:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c72:	8e 89       	ldd	r24, Y+22	; 0x16
     c74:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     c78:	98 17       	cp	r25, r24
     c7a:	10 f4       	brcc	.+4      	; 0xc80 <xTaskResumeAll+0x58>
     c7c:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	9c 01       	movw	r18, r24
     c84:	22 0f       	add	r18, r18
     c86:	33 1f       	adc	r19, r19
     c88:	22 0f       	add	r18, r18
     c8a:	33 1f       	adc	r19, r19
     c8c:	22 0f       	add	r18, r18
     c8e:	33 1f       	adc	r19, r19
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	b8 01       	movw	r22, r16
     c96:	8b 5d       	subi	r24, 0xDB	; 219
     c98:	98 4f       	sbci	r25, 0xF8	; 248
     c9a:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c9e:	9e 89       	ldd	r25, Y+22	; 0x16
     ca0:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     ca4:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     ca8:	86 89       	ldd	r24, Z+22	; 0x16
     caa:	98 17       	cp	r25, r24
     cac:	30 f0       	brcs	.+12     	; 0xcba <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
     cb4:	02 c0       	rjmp	.+4      	; 0xcba <xTaskResumeAll+0x92>
     cb6:	c0 e0       	ldi	r28, 0x00	; 0
     cb8:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cba:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xPendingReadyList>
     cbe:	81 11       	cpse	r24, r1
     cc0:	c8 cf       	rjmp	.-112    	; 0xc52 <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     cc2:	cd 2b       	or	r28, r29
     cc4:	11 f0       	breq	.+4      	; 0xcca <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     cc6:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     cca:	c0 91 00 07 	lds	r28, 0x0700	; 0x800700 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     cce:	cc 23       	and	r28, r28
     cd0:	59 f0       	breq	.+22     	; 0xce8 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     cd2:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     cd6:	88 23       	and	r24, r24
     cd8:	19 f0       	breq	.+6      	; 0xce0 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     ce0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     ce2:	b9 f7       	brne	.-18     	; 0xcd2 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     ce4:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     ce8:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xYieldPending>
     cec:	88 23       	and	r24, r24
     cee:	31 f0       	breq	.+12     	; 0xcfc <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cf0:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	03 c0       	rjmp	.+6      	; 0xcfe <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	01 c0       	rjmp	.+2      	; 0xcfe <xTaskResumeAll+0xd6>
     cfc:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     cfe:	0f 90       	pop	r0
     d00:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	0f 91       	pop	r16
     d0a:	08 95       	ret

00000d0c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	8c 01       	movw	r16, r24
     d16:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d18:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d1c:	40 91 03 07 	lds	r20, 0x0703	; 0x800703 <xTickCount>
     d20:	50 91 04 07 	lds	r21, 0x0704	; 0x800704 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d24:	f8 01       	movw	r30, r16
     d26:	20 81       	ld	r18, Z
     d28:	31 81       	ldd	r19, Z+1	; 0x01
     d2a:	c9 01       	movw	r24, r18
     d2c:	8c 0f       	add	r24, r28
     d2e:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d30:	42 17       	cp	r20, r18
     d32:	53 07       	cpc	r21, r19
     d34:	40 f4       	brcc	.+16     	; 0xd46 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d36:	82 17       	cp	r24, r18
     d38:	93 07       	cpc	r25, r19
     d3a:	68 f4       	brcc	.+26     	; 0xd56 <vTaskDelayUntil+0x4a>
     d3c:	48 17       	cp	r20, r24
     d3e:	59 07       	cpc	r21, r25
     d40:	60 f0       	brcs	.+24     	; 0xd5a <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d42:	20 e0       	ldi	r18, 0x00	; 0
     d44:	0f c0       	rjmp	.+30     	; 0xd64 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d46:	82 17       	cp	r24, r18
     d48:	93 07       	cpc	r25, r19
     d4a:	48 f0       	brcs	.+18     	; 0xd5e <vTaskDelayUntil+0x52>
     d4c:	48 17       	cp	r20, r24
     d4e:	59 07       	cpc	r21, r25
     d50:	40 f0       	brcs	.+16     	; 0xd62 <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	07 c0       	rjmp	.+14     	; 0xd64 <vTaskDelayUntil+0x58>
     d56:	20 e0       	ldi	r18, 0x00	; 0
     d58:	05 c0       	rjmp	.+10     	; 0xd64 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5a:	21 e0       	ldi	r18, 0x01	; 1
     d5c:	03 c0       	rjmp	.+6      	; 0xd64 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5e:	21 e0       	ldi	r18, 0x01	; 1
     d60:	01 c0       	rjmp	.+2      	; 0xd64 <vTaskDelayUntil+0x58>
     d62:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d64:	f8 01       	movw	r30, r16
     d66:	91 83       	std	Z+1, r25	; 0x01
     d68:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d6a:	22 23       	and	r18, r18
     d6c:	29 f0       	breq	.+10     	; 0xd78 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d6e:	60 e0       	ldi	r22, 0x00	; 0
     d70:	84 1b       	sub	r24, r20
     d72:	95 0b       	sbc	r25, r21
     d74:	0e 94 88 04 	call	0x910	; 0x910 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d78:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d7c:	81 11       	cpse	r24, r1
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     d80:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     d8e:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     d92:	88 23       	and	r24, r24
     d94:	21 f0       	breq	.+8      	; 0xd9e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
     d9c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     d9e:	10 92 ff 06 	sts	0x06FF, r1	; 0x8006ff <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     da2:	20 91 02 07 	lds	r18, 0x0702	; 0x800702 <uxTopReadyPriority>
     da6:	01 c0       	rjmp	.+2      	; 0xdaa <vTaskSwitchContext+0x1c>
     da8:	21 50       	subi	r18, 0x01	; 1
     daa:	82 2f       	mov	r24, r18
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	fc 01       	movw	r30, r24
     db0:	ee 0f       	add	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	ee 0f       	add	r30, r30
     db6:	ff 1f       	adc	r31, r31
     db8:	ee 0f       	add	r30, r30
     dba:	ff 1f       	adc	r31, r31
     dbc:	e8 0f       	add	r30, r24
     dbe:	f9 1f       	adc	r31, r25
     dc0:	eb 5d       	subi	r30, 0xDB	; 219
     dc2:	f8 4f       	sbci	r31, 0xF8	; 248
     dc4:	30 81       	ld	r19, Z
     dc6:	33 23       	and	r19, r19
     dc8:	79 f3       	breq	.-34     	; 0xda8 <vTaskSwitchContext+0x1a>
     dca:	ac 01       	movw	r20, r24
     dcc:	44 0f       	add	r20, r20
     dce:	55 1f       	adc	r21, r21
     dd0:	44 0f       	add	r20, r20
     dd2:	55 1f       	adc	r21, r21
     dd4:	44 0f       	add	r20, r20
     dd6:	55 1f       	adc	r21, r21
     dd8:	48 0f       	add	r20, r24
     dda:	59 1f       	adc	r21, r25
     ddc:	df 01       	movw	r26, r30
     dde:	01 80       	ldd	r0, Z+1	; 0x01
     de0:	f2 81       	ldd	r31, Z+2	; 0x02
     de2:	e0 2d       	mov	r30, r0
     de4:	02 80       	ldd	r0, Z+2	; 0x02
     de6:	f3 81       	ldd	r31, Z+3	; 0x03
     de8:	e0 2d       	mov	r30, r0
     dea:	12 96       	adiw	r26, 0x02	; 2
     dec:	fc 93       	st	X, r31
     dee:	ee 93       	st	-X, r30
     df0:	11 97       	sbiw	r26, 0x01	; 1
     df2:	48 5d       	subi	r20, 0xD8	; 216
     df4:	58 4f       	sbci	r21, 0xF8	; 248
     df6:	e4 17       	cp	r30, r20
     df8:	f5 07       	cpc	r31, r21
     dfa:	29 f4       	brne	.+10     	; 0xe06 <vTaskSwitchContext+0x78>
     dfc:	42 81       	ldd	r20, Z+2	; 0x02
     dfe:	53 81       	ldd	r21, Z+3	; 0x03
     e00:	fd 01       	movw	r30, r26
     e02:	52 83       	std	Z+2, r21	; 0x02
     e04:	41 83       	std	Z+1, r20	; 0x01
     e06:	fc 01       	movw	r30, r24
     e08:	ee 0f       	add	r30, r30
     e0a:	ff 1f       	adc	r31, r31
     e0c:	ee 0f       	add	r30, r30
     e0e:	ff 1f       	adc	r31, r31
     e10:	ee 0f       	add	r30, r30
     e12:	ff 1f       	adc	r31, r31
     e14:	8e 0f       	add	r24, r30
     e16:	9f 1f       	adc	r25, r31
     e18:	fc 01       	movw	r30, r24
     e1a:	eb 5d       	subi	r30, 0xDB	; 219
     e1c:	f8 4f       	sbci	r31, 0xF8	; 248
     e1e:	01 80       	ldd	r0, Z+1	; 0x01
     e20:	f2 81       	ldd	r31, Z+2	; 0x02
     e22:	e0 2d       	mov	r30, r0
     e24:	86 81       	ldd	r24, Z+6	; 0x06
     e26:	97 81       	ldd	r25, Z+7	; 0x07
     e28:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <pxCurrentTCB+0x1>
     e2c:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <pxCurrentTCB>
     e30:	20 93 02 07 	sts	0x0702, r18	; 0x800702 <uxTopReadyPriority>
     e34:	08 95       	ret

00000e36 <KP_Init>:
* @param [in]  KP_CH   -  Keypad channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t KP_Init(uint8_t KP_CH)
{
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
     e40:	81 11       	cpse	r24, r1
     e42:	4e c0       	rjmp	.+156    	; 0xee0 <KP_Init+0xaa>
     e44:	08 2f       	mov	r16, r24
     e46:	10 e0       	ldi	r17, 0x00	; 0
     e48:	17 c0       	rjmp	.+46     	; 0xe78 <KP_Init+0x42>
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
     e4a:	9e 01       	movw	r18, r28
     e4c:	22 0f       	add	r18, r18
     e4e:	33 1f       	adc	r19, r19
     e50:	f9 01       	movw	r30, r18
     e52:	ec 0f       	add	r30, r28
     e54:	fd 1f       	adc	r31, r29
     e56:	ee 0f       	add	r30, r30
     e58:	ff 1f       	adc	r31, r31
     e5a:	e4 52       	subi	r30, 0x24	; 36
     e5c:	ff 4f       	sbci	r31, 0xFF	; 255
     e5e:	f5 80       	ldd	r15, Z+5	; 0x05
     e60:	f1 0e       	add	r15, r17
     e62:	c4 81       	ldd	r28, Z+4	; 0x04
     e64:	40 e0       	ldi	r20, 0x00	; 0
     e66:	6f 2d       	mov	r22, r15
     e68:	8c 2f       	mov	r24, r28
     e6a:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
     e6e:	6f 2d       	mov	r22, r15
     e70:	8c 2f       	mov	r24, r28
     e72:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <DIO_EnablePinPullup>
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
   }
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
     e76:	1f 5f       	subi	r17, 0xFF	; 255
     e78:	c0 2f       	mov	r28, r16
     e7a:	d0 e0       	ldi	r29, 0x00	; 0
     e7c:	fe 01       	movw	r30, r28
     e7e:	ee 0f       	add	r30, r30
     e80:	ff 1f       	adc	r31, r31
     e82:	ec 0f       	add	r30, r28
     e84:	fd 1f       	adc	r31, r29
     e86:	ee 0f       	add	r30, r30
     e88:	ff 1f       	adc	r31, r31
     e8a:	e4 52       	subi	r30, 0x24	; 36
     e8c:	ff 4f       	sbci	r31, 0xFF	; 255
     e8e:	83 81       	ldd	r24, Z+3	; 0x03
     e90:	18 17       	cp	r17, r24
     e92:	d8 f2       	brcs	.-74     	; 0xe4a <KP_Init+0x14>
     e94:	10 e0       	ldi	r17, 0x00	; 0
     e96:	16 c0       	rjmp	.+44     	; 0xec4 <KP_Init+0x8e>
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
     e98:	fe 01       	movw	r30, r28
     e9a:	ee 0f       	add	r30, r30
     e9c:	ff 1f       	adc	r31, r31
     e9e:	ec 0f       	add	r30, r28
     ea0:	fd 1f       	adc	r31, r29
     ea2:	ee 0f       	add	r30, r30
     ea4:	ff 1f       	adc	r31, r31
     ea6:	e4 52       	subi	r30, 0x24	; 36
     ea8:	ff 4f       	sbci	r31, 0xFF	; 255
     eaa:	02 81       	ldd	r16, Z+2	; 0x02
     eac:	01 0f       	add	r16, r17
     eae:	f1 80       	ldd	r15, Z+1	; 0x01
     eb0:	40 e0       	ldi	r20, 0x00	; 0
     eb2:	60 2f       	mov	r22, r16
     eb4:	8f 2d       	mov	r24, r15
     eb6:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
     eba:	60 2f       	mov	r22, r16
     ebc:	8f 2d       	mov	r24, r15
     ebe:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <DIO_EnablePinPullup>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
     ec2:	1f 5f       	subi	r17, 0xFF	; 255
     ec4:	fe 01       	movw	r30, r28
     ec6:	ee 0f       	add	r30, r30
     ec8:	ff 1f       	adc	r31, r31
     eca:	ec 0f       	add	r30, r28
     ecc:	fd 1f       	adc	r31, r29
     ece:	ee 0f       	add	r30, r30
     ed0:	ff 1f       	adc	r31, r31
     ed2:	e4 52       	subi	r30, 0x24	; 36
     ed4:	ff 4f       	sbci	r31, 0xFF	; 255
     ed6:	80 81       	ld	r24, Z
     ed8:	18 17       	cp	r17, r24
     eda:	f0 f2       	brcs	.-68     	; 0xe98 <KP_Init+0x62>
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
      }
      KP_ErrorState = ERROR_OK;
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	01 c0       	rjmp	.+2      	; 0xee2 <KP_Init+0xac>
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
     ee0:	82 ee       	ldi	r24, 0xE2	; 226
      KP_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return KP_ErrorState;
}
     ee2:	df 91       	pop	r29
     ee4:	cf 91       	pop	r28
     ee6:	1f 91       	pop	r17
     ee8:	0f 91       	pop	r16
     eea:	ff 90       	pop	r15
     eec:	08 95       	ret

00000eee <KP_GetPressedValue>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t KP_GetPressedValue(uint8_t KP_CH, uint32_t * const Data)
{
     eee:	5f 92       	push	r5
     ef0:	6f 92       	push	r6
     ef2:	7f 92       	push	r7
     ef4:	8f 92       	push	r8
     ef6:	9f 92       	push	r9
     ef8:	af 92       	push	r10
     efa:	bf 92       	push	r11
     efc:	cf 92       	push	r12
     efe:	df 92       	push	r13
     f00:	ef 92       	push	r14
     f02:	ff 92       	push	r15
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	1f 92       	push	r1
     f0e:	cd b7       	in	r28, 0x3d	; 61
     f10:	de b7       	in	r29, 0x3e	; 62
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
     f12:	61 15       	cp	r22, r1
     f14:	71 05       	cpc	r23, r1
     f16:	09 f4       	brne	.+2      	; 0xf1a <KP_GetPressedValue+0x2c>
     f18:	87 c0       	rjmp	.+270    	; 0x1028 <KP_GetPressedValue+0x13a>
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
   }
   else if(KP_INVALID_CH <= KP_CH)
     f1a:	81 11       	cpse	r24, r1
     f1c:	87 c0       	rjmp	.+270    	; 0x102c <KP_GetPressedValue+0x13e>
     f1e:	6b 01       	movw	r12, r22
     f20:	e8 2e       	mov	r14, r24
     f22:	61 2c       	mov	r6, r1
     f24:	81 2c       	mov	r8, r1
     f26:	91 2c       	mov	r9, r1
     f28:	54 01       	movw	r10, r8
     f2a:	68 c0       	rjmp	.+208    	; 0xffc <KP_GetPressedValue+0x10e>
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
      {
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
     f2c:	f8 01       	movw	r30, r16
     f2e:	ee 0f       	add	r30, r30
     f30:	ff 1f       	adc	r31, r31
     f32:	e0 0f       	add	r30, r16
     f34:	f1 1f       	adc	r31, r17
     f36:	ee 0f       	add	r30, r30
     f38:	ff 1f       	adc	r31, r31
     f3a:	e4 52       	subi	r30, 0x24	; 36
     f3c:	ff 4f       	sbci	r31, 0xFF	; 255
     f3e:	75 80       	ldd	r7, Z+5	; 0x05
     f40:	76 0c       	add	r7, r6
     f42:	54 80       	ldd	r5, Z+4	; 0x04
     f44:	41 e0       	ldi	r20, 0x01	; 1
     f46:	67 2d       	mov	r22, r7
     f48:	85 2d       	mov	r24, r5
     f4a:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	67 2d       	mov	r22, r7
     f52:	85 2d       	mov	r24, r5
     f54:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     f58:	f1 2c       	mov	r15, r1
     f5a:	39 c0       	rjmp	.+114    	; 0xfce <KP_GetPressedValue+0xe0>
         {
            /* read row value */
            DIO_ReadPin(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_RowCounter), &u8_KeyState);
     f5c:	f8 01       	movw	r30, r16
     f5e:	ee 0f       	add	r30, r30
     f60:	ff 1f       	adc	r31, r31
     f62:	e0 0f       	add	r30, r16
     f64:	f1 1f       	adc	r31, r17
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	e4 52       	subi	r30, 0x24	; 36
     f6c:	ff 4f       	sbci	r31, 0xFF	; 255
     f6e:	62 81       	ldd	r22, Z+2	; 0x02
     f70:	6f 0d       	add	r22, r15
     f72:	ae 01       	movw	r20, r28
     f74:	4f 5f       	subi	r20, 0xFF	; 255
     f76:	5f 4f       	sbci	r21, 0xFF	; 255
     f78:	81 81       	ldd	r24, Z+1	; 0x01
     f7a:	0e 94 9a 0a 	call	0x1534	; 0x1534 <DIO_ReadPin>
            /* check if row is pressed */
            if(u8_KeyState == PRESSED)
     f7e:	89 81       	ldd	r24, Y+1	; 0x01
     f80:	81 11       	cpse	r24, r1
     f82:	24 c0       	rjmp	.+72     	; 0xfcc <KP_GetPressedValue+0xde>
            {
               /* Check for multipressed buttons. */
               if(u32_NewState > 0)
     f84:	81 14       	cp	r8, r1
     f86:	91 04       	cpc	r9, r1
     f88:	a1 04       	cpc	r10, r1
     f8a:	b1 04       	cpc	r11, r1
     f8c:	11 f0       	breq	.+4      	; 0xf92 <KP_GetPressedValue+0xa4>
               {
                  u32_NewState |= 1;
     f8e:	68 94       	set
     f90:	80 f8       	bld	r8, 0
               }
               switch(KP_CH)
     f92:	e1 10       	cpse	r14, r1
     f94:	1b c0       	rjmp	.+54     	; 0xfcc <KP_GetPressedValue+0xde>
               {
                  #ifdef KP_CH_0
                  case KP_CH_0:
                     u32_NewState |= (1<<KP_Ch0Map[u8_RowCounter][u8_ColCounter]);
     f96:	8f 2d       	mov	r24, r15
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	fc 01       	movw	r30, r24
     f9c:	ee 0f       	add	r30, r30
     f9e:	ff 1f       	adc	r31, r31
     fa0:	e8 0f       	add	r30, r24
     fa2:	f9 1f       	adc	r31, r25
     fa4:	e0 53       	subi	r30, 0x30	; 48
     fa6:	ff 4f       	sbci	r31, 0xFF	; 255
     fa8:	e6 0d       	add	r30, r6
     faa:	f1 1d       	adc	r31, r1
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	00 80       	ld	r0, Z
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <KP_GetPressedValue+0xca>
     fb4:	88 0f       	add	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	0a 94       	dec	r0
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <KP_GetPressedValue+0xc6>
     fbc:	09 2e       	mov	r0, r25
     fbe:	00 0c       	add	r0, r0
     fc0:	aa 0b       	sbc	r26, r26
     fc2:	bb 0b       	sbc	r27, r27
     fc4:	88 2a       	or	r8, r24
     fc6:	99 2a       	or	r9, r25
     fc8:	aa 2a       	or	r10, r26
     fca:	bb 2a       	or	r11, r27
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     fcc:	f3 94       	inc	r15
     fce:	f8 01       	movw	r30, r16
     fd0:	ee 0f       	add	r30, r30
     fd2:	ff 1f       	adc	r31, r31
     fd4:	e0 0f       	add	r30, r16
     fd6:	f1 1f       	adc	r31, r17
     fd8:	ee 0f       	add	r30, r30
     fda:	ff 1f       	adc	r31, r31
     fdc:	e4 52       	subi	r30, 0x24	; 36
     fde:	ff 4f       	sbci	r31, 0xFF	; 255
     fe0:	80 81       	ld	r24, Z
     fe2:	f8 16       	cp	r15, r24
     fe4:	08 f4       	brcc	.+2      	; 0xfe8 <KP_GetPressedValue+0xfa>
     fe6:	ba cf       	rjmp	.-140    	; 0xf5c <KP_GetPressedValue+0x6e>
               }
            }
         }
         
         /* return column direction to input and resistor to pulled up. */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
     fe8:	40 e0       	ldi	r20, 0x00	; 0
     fea:	67 2d       	mov	r22, r7
     fec:	85 2d       	mov	r24, r5
     fee:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
     ff2:	67 2d       	mov	r22, r7
     ff4:	85 2d       	mov	r24, r5
     ff6:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <DIO_EnablePinPullup>
   {
      uint32_t u32_NewState = 0x00;
      uint8_t u8_KeyState;
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
     ffa:	63 94       	inc	r6
     ffc:	0e 2d       	mov	r16, r14
     ffe:	10 e0       	ldi	r17, 0x00	; 0
    1000:	f8 01       	movw	r30, r16
    1002:	ee 0f       	add	r30, r30
    1004:	ff 1f       	adc	r31, r31
    1006:	e0 0f       	add	r30, r16
    1008:	f1 1f       	adc	r31, r17
    100a:	ee 0f       	add	r30, r30
    100c:	ff 1f       	adc	r31, r31
    100e:	e4 52       	subi	r30, 0x24	; 36
    1010:	ff 4f       	sbci	r31, 0xFF	; 255
    1012:	83 81       	ldd	r24, Z+3	; 0x03
    1014:	68 16       	cp	r6, r24
    1016:	08 f4       	brcc	.+2      	; 0x101a <KP_GetPressedValue+0x12c>
    1018:	89 cf       	rjmp	.-238    	; 0xf2c <KP_GetPressedValue+0x3e>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
      }
      
      /* Return the keys data. */
      *Data = u32_NewState;
    101a:	f6 01       	movw	r30, r12
    101c:	80 82       	st	Z, r8
    101e:	91 82       	std	Z+1, r9	; 0x01
    1020:	a2 82       	std	Z+2, r10	; 0x02
    1022:	b3 82       	std	Z+3, r11	; 0x03
      KP_ErrorState = ERROR_OK;
    1024:	80 e0       	ldi	r24, 0x00	; 0
    1026:	03 c0       	rjmp	.+6      	; 0x102e <KP_GetPressedValue+0x140>
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
    1028:	81 ee       	ldi	r24, 0xE1	; 225
    102a:	01 c0       	rjmp	.+2      	; 0x102e <KP_GetPressedValue+0x140>
   }
   else if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    102c:	82 ee       	ldi	r24, 0xE2	; 226
      
   }
   
   /* return Error state. */
   return KP_ErrorState;
    102e:	0f 90       	pop	r0
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	1f 91       	pop	r17
    1036:	0f 91       	pop	r16
    1038:	ff 90       	pop	r15
    103a:	ef 90       	pop	r14
    103c:	df 90       	pop	r13
    103e:	cf 90       	pop	r12
    1040:	bf 90       	pop	r11
    1042:	af 90       	pop	r10
    1044:	9f 90       	pop	r9
    1046:	8f 90       	pop	r8
    1048:	7f 90       	pop	r7
    104a:	6f 90       	pop	r6
    104c:	5f 90       	pop	r5
    104e:	08 95       	ret

00001050 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	0f 93       	push	r16
    1056:	1f 93       	push	r17
    1058:	cf 93       	push	r28
    105a:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    105c:	81 11       	cpse	r24, r1
    105e:	4e c0       	rjmp	.+156    	; 0x10fc <LED_Init+0xac>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    1060:	c8 2f       	mov	r28, r24
    1062:	d0 e0       	ldi	r29, 0x00	; 0
    1064:	fe 01       	movw	r30, r28
    1066:	e5 5b       	subi	r30, 0xB5	; 181
    1068:	f8 4f       	sbci	r31, 0xF8	; 248
    106a:	80 81       	ld	r24, Z
    106c:	81 30       	cpi	r24, 0x01	; 1
    106e:	09 f4       	brne	.+2      	; 0x1072 <LED_Init+0x22>
    1070:	47 c0       	rjmp	.+142    	; 0x1100 <LED_Init+0xb0>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      /* Normal LED Config */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1072:	fe 01       	movw	r30, r28
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	ee 0f       	add	r30, r30
    107a:	ff 1f       	adc	r31, r31
    107c:	ee 51       	subi	r30, 0x1E	; 30
    107e:	ff 4f       	sbci	r31, 0xFF	; 255
    1080:	82 81       	ldd	r24, Z+2	; 0x02
    1082:	81 11       	cpse	r24, r1
    1084:	14 c0       	rjmp	.+40     	; 0x10ae <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1086:	fe 01       	movw	r30, r28
    1088:	ee 0f       	add	r30, r30
    108a:	ff 1f       	adc	r31, r31
    108c:	ee 0f       	add	r30, r30
    108e:	ff 1f       	adc	r31, r31
    1090:	ee 51       	subi	r30, 0x1E	; 30
    1092:	ff 4f       	sbci	r31, 0xFF	; 255
    1094:	61 81       	ldd	r22, Z+1	; 0x01
    1096:	41 e0       	ldi	r20, 0x01	; 1
    1098:	80 81       	ld	r24, Z
    109a:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    109e:	81 11       	cpse	r24, r1
    10a0:	31 c0       	rjmp	.+98     	; 0x1104 <LED_Init+0xb4>
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    10a2:	c5 5b       	subi	r28, 0xB5	; 181
    10a4:	d8 4f       	sbci	r29, 0xF8	; 248
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	30 c0       	rjmp	.+96     	; 0x110e <LED_Init+0xbe>
         }
      }
      /* PWM LED Config */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    10ae:	81 30       	cpi	r24, 0x01	; 1
    10b0:	59 f5       	brne	.+86     	; 0x1108 <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         /* configure LED pin */
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10b2:	ce 01       	movw	r24, r28
    10b4:	88 0f       	add	r24, r24
    10b6:	99 1f       	adc	r25, r25
    10b8:	88 0f       	add	r24, r24
    10ba:	99 1f       	adc	r25, r25
    10bc:	9c 01       	movw	r18, r24
    10be:	2e 51       	subi	r18, 0x1E	; 30
    10c0:	3f 4f       	sbci	r19, 0xFF	; 255
    10c2:	79 01       	movw	r14, r18
    10c4:	f9 01       	movw	r30, r18
    10c6:	03 81       	ldd	r16, Z+3	; 0x03
    10c8:	80 2f       	mov	r24, r16
    10ca:	0e 94 1b 0b 	call	0x1636	; 0x1636 <PWM_Init>
    10ce:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    10d0:	41 e0       	ldi	r20, 0x01	; 1
    10d2:	f7 01       	movw	r30, r14
    10d4:	61 81       	ldd	r22, Z+1	; 0x01
    10d6:	80 81       	ld	r24, Z
    10d8:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
    10dc:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10de:	80 2f       	mov	r24, r16
    10e0:	0e 94 4c 0b 	call	0x1698	; 0x1698 <PWM_Start>
    10e4:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10e6:	80 2f       	mov	r24, r16
    10e8:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <PWM_Connect>
    10ec:	81 2b       	or	r24, r17
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
    10ee:	71 f4       	brne	.+28     	; 0x110c <LED_Init+0xbc>
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    10f0:	c5 5b       	subi	r28, 0xB5	; 181
    10f2:	d8 4f       	sbci	r29, 0xF8	; 248
    10f4:	81 e0       	ldi	r24, 0x01	; 1
    10f6:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    10f8:	80 e0       	ldi	r24, 0x00	; 0
    10fa:	09 c0       	rjmp	.+18     	; 0x110e <LED_Init+0xbe>
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    10fc:	81 ec       	ldi	r24, 0xC1	; 193
    10fe:	07 c0       	rjmp	.+14     	; 0x110e <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      /* Set init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    1100:	82 ec       	ldi	r24, 0xC2	; 194
    1102:	05 c0       	rjmp	.+10     	; 0x110e <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	03 c0       	rjmp	.+6      	; 0x110e <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	01 c0       	rjmp	.+2      	; 0x110e <LED_Init+0xbe>
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    110c:	81 e0       	ldi	r24, 0x01	; 1
      }   
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	08 95       	ret

0000111c <LED_Off>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    111c:	81 11       	cpse	r24, r1
    111e:	32 c0       	rjmp	.+100    	; 0x1184 <LED_Off+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	fc 01       	movw	r30, r24
    1124:	e5 5b       	subi	r30, 0xB5	; 181
    1126:	f8 4f       	sbci	r31, 0xF8	; 248
    1128:	20 81       	ld	r18, Z
    112a:	21 30       	cpi	r18, 0x01	; 1
    112c:	69 f5       	brne	.+90     	; 0x1188 <LED_Off+0x6c>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      /* Normal LED */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    112e:	fc 01       	movw	r30, r24
    1130:	ee 0f       	add	r30, r30
    1132:	ff 1f       	adc	r31, r31
    1134:	ee 0f       	add	r30, r30
    1136:	ff 1f       	adc	r31, r31
    1138:	ee 51       	subi	r30, 0x1E	; 30
    113a:	ff 4f       	sbci	r31, 0xFF	; 255
    113c:	22 81       	ldd	r18, Z+2	; 0x02
    113e:	21 11       	cpse	r18, r1
    1140:	10 c0       	rjmp	.+32     	; 0x1162 <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    1142:	88 0f       	add	r24, r24
    1144:	99 1f       	adc	r25, r25
    1146:	88 0f       	add	r24, r24
    1148:	99 1f       	adc	r25, r25
    114a:	fc 01       	movw	r30, r24
    114c:	ee 51       	subi	r30, 0x1E	; 30
    114e:	ff 4f       	sbci	r31, 0xFF	; 255
    1150:	61 81       	ldd	r22, Z+1	; 0x01
    1152:	40 e0       	ldi	r20, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    115a:	88 23       	and	r24, r24
    115c:	b9 f0       	breq	.+46     	; 0x118c <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	08 95       	ret
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      /* PWM LED */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1162:	21 30       	cpi	r18, 0x01	; 1
    1164:	a9 f4       	brne	.+42     	; 0x1190 <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to Minimum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MIN_DUTY);
    1166:	88 0f       	add	r24, r24
    1168:	99 1f       	adc	r25, r25
    116a:	88 0f       	add	r24, r24
    116c:	99 1f       	adc	r25, r25
    116e:	fc 01       	movw	r30, r24
    1170:	ee 51       	subi	r30, 0x1E	; 30
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	60 e0       	ldi	r22, 0x00	; 0
    1176:	83 81       	ldd	r24, Z+3	; 0x03
    1178:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    117c:	88 23       	and	r24, r24
    117e:	51 f0       	breq	.+20     	; 0x1194 <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1184:	81 ec       	ldi	r24, 0xC1	; 193
    1186:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1188:	83 ec       	ldi	r24, 0xC3	; 195
    118a:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1194:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1196:	08 95       	ret

00001198 <LED_On>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1198:	81 11       	cpse	r24, r1
    119a:	32 c0       	rjmp	.+100    	; 0x1200 <LED_On+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	fc 01       	movw	r30, r24
    11a0:	e5 5b       	subi	r30, 0xB5	; 181
    11a2:	f8 4f       	sbci	r31, 0xF8	; 248
    11a4:	20 81       	ld	r18, Z
    11a6:	21 30       	cpi	r18, 0x01	; 1
    11a8:	69 f5       	brne	.+90     	; 0x1204 <LED_On+0x6c>
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    11aa:	fc 01       	movw	r30, r24
    11ac:	ee 0f       	add	r30, r30
    11ae:	ff 1f       	adc	r31, r31
    11b0:	ee 0f       	add	r30, r30
    11b2:	ff 1f       	adc	r31, r31
    11b4:	ee 51       	subi	r30, 0x1E	; 30
    11b6:	ff 4f       	sbci	r31, 0xFF	; 255
    11b8:	22 81       	ldd	r18, Z+2	; 0x02
    11ba:	21 11       	cpse	r18, r1
    11bc:	10 c0       	rjmp	.+32     	; 0x11de <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to high */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    11be:	88 0f       	add	r24, r24
    11c0:	99 1f       	adc	r25, r25
    11c2:	88 0f       	add	r24, r24
    11c4:	99 1f       	adc	r25, r25
    11c6:	fc 01       	movw	r30, r24
    11c8:	ee 51       	subi	r30, 0x1E	; 30
    11ca:	ff 4f       	sbci	r31, 0xFF	; 255
    11cc:	61 81       	ldd	r22, Z+1	; 0x01
    11ce:	41 e0       	ldi	r20, 0x01	; 1
    11d0:	80 81       	ld	r24, Z
    11d2:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    11d6:	88 23       	and	r24, r24
    11d8:	b9 f0       	breq	.+46     	; 0x1208 <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    11de:	21 30       	cpi	r18, 0x01	; 1
    11e0:	a9 f4       	brne	.+42     	; 0x120c <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to maximum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MAX_DUTY);
    11e2:	88 0f       	add	r24, r24
    11e4:	99 1f       	adc	r25, r25
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	fc 01       	movw	r30, r24
    11ec:	ee 51       	subi	r30, 0x1E	; 30
    11ee:	ff 4f       	sbci	r31, 0xFF	; 255
    11f0:	64 e6       	ldi	r22, 0x64	; 100
    11f2:	83 81       	ldd	r24, Z+3	; 0x03
    11f4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    11f8:	88 23       	and	r24, r24
    11fa:	51 f0       	breq	.+20     	; 0x1210 <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1200:	81 ec       	ldi	r24, 0xC1	; 193
    1202:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1204:	83 ec       	ldi	r24, 0xC3	; 195
    1206:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1210:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1212:	08 95       	ret

00001214 <LED_Dim>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1214:	81 11       	cpse	r24, r1
    1216:	21 c0       	rjmp	.+66     	; 0x125a <LED_Dim+0x46>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	fc 01       	movw	r30, r24
    121c:	e5 5b       	subi	r30, 0xB5	; 181
    121e:	f8 4f       	sbci	r31, 0xF8	; 248
    1220:	20 81       	ld	r18, Z
    1222:	21 30       	cpi	r18, 0x01	; 1
    1224:	e1 f4       	brne	.+56     	; 0x125e <LED_Dim+0x4a>
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1226:	fc 01       	movw	r30, r24
    1228:	ee 0f       	add	r30, r30
    122a:	ff 1f       	adc	r31, r31
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	ee 51       	subi	r30, 0x1E	; 30
    1232:	ff 4f       	sbci	r31, 0xFF	; 255
    1234:	22 81       	ldd	r18, Z+2	; 0x02
    1236:	22 23       	and	r18, r18
    1238:	a1 f0       	breq	.+40     	; 0x1262 <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
    123a:	65 36       	cpi	r22, 0x65	; 101
    123c:	a0 f4       	brcc	.+40     	; 0x1266 <LED_Dim+0x52>
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      /* set LED duty cycle */
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    123e:	88 0f       	add	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	fc 01       	movw	r30, r24
    1248:	ee 51       	subi	r30, 0x1E	; 30
    124a:	ff 4f       	sbci	r31, 0xFF	; 255
    124c:	83 81       	ldd	r24, Z+3	; 0x03
    124e:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <PWM_SetDuty>
        
      /* make sure PWM function was successful */ 
      if(ERROR_OK != PWM_ErrorState)
    1252:	88 23       	and	r24, r24
    1254:	51 f0       	breq	.+20     	; 0x126a <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    125a:	81 ec       	ldi	r24, 0xC1	; 193
    125c:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    125e:	83 ec       	ldi	r24, 0xC3	; 195
    1260:	08 95       	ret
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	08 95       	ret
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    126a:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    126c:	08 95       	ret

0000126e <SevenSeg_ClearEnable>:
------------------------*/
/**
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
    126e:	cf 93       	push	r28
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    1270:	c0 e0       	ldi	r28, 0x00	; 0
    1272:	0e c0       	rjmp	.+28     	; 0x1290 <SevenSeg_ClearEnable+0x22>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
    1274:	ec 2f       	mov	r30, r28
    1276:	f0 e0       	ldi	r31, 0x00	; 0
    1278:	ee 0f       	add	r30, r30
    127a:	ff 1f       	adc	r31, r31
    127c:	ee 0f       	add	r30, r30
    127e:	ff 1f       	adc	r31, r31
    1280:	ea 51       	subi	r30, 0x1A	; 26
    1282:	ff 4f       	sbci	r31, 0xFF	; 255
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	61 81       	ldd	r22, Z+1	; 0x01
    1288:	80 81       	ld	r24, Z
    128a:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    128e:	cf 5f       	subi	r28, 0xFF	; 255
    1290:	c2 30       	cpi	r28, 0x02	; 2
    1292:	80 f3       	brcs	.-32     	; 0x1274 <SevenSeg_ClearEnable+0x6>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
   }
}
    1294:	cf 91       	pop	r28
    1296:	08 95       	ret

00001298 <SevenSeg_Init>:
* @param [in]  Channel   -  Channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t SevenSeg_Init(const uint8_t Channel)
{
    1298:	1f 93       	push	r17
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    129e:	82 30       	cpi	r24, 0x02	; 2
    12a0:	60 f5       	brcc	.+88     	; 0x12fa <SevenSeg_Init+0x62>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT == gu8_IsInit[Channel])
    12a2:	c8 2f       	mov	r28, r24
    12a4:	d0 e0       	ldi	r29, 0x00	; 0
    12a6:	fe 01       	movw	r30, r28
    12a8:	e4 5b       	subi	r30, 0xB4	; 180
    12aa:	f8 4f       	sbci	r31, 0xF8	; 248
    12ac:	80 81       	ld	r24, Z
    12ae:	81 30       	cpi	r24, 0x01	; 1
    12b0:	31 f1       	breq	.+76     	; 0x12fe <SevenSeg_Init+0x66>
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
   }
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
    12b2:	fe 01       	movw	r30, r28
    12b4:	ee 0f       	add	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	ee 0f       	add	r30, r30
    12ba:	ff 1f       	adc	r31, r31
    12bc:	ea 51       	subi	r30, 0x1A	; 26
    12be:	ff 4f       	sbci	r31, 0xFF	; 255
    12c0:	41 e0       	ldi	r20, 0x01	; 1
    12c2:	61 81       	ldd	r22, Z+1	; 0x01
    12c4:	80 81       	ld	r24, Z
    12c6:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    12ca:	10 e0       	ldi	r17, 0x00	; 0
    12cc:	0e c0       	rjmp	.+28     	; 0x12ea <SevenSeg_Init+0x52>
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
            aSTR_SevenSegConfig[Channel].u8_DataPort, 
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
    12ce:	fe 01       	movw	r30, r28
    12d0:	ee 0f       	add	r30, r30
    12d2:	ff 1f       	adc	r31, r31
    12d4:	ee 0f       	add	r30, r30
    12d6:	ff 1f       	adc	r31, r31
    12d8:	ea 51       	subi	r30, 0x1A	; 26
    12da:	ff 4f       	sbci	r31, 0xFF	; 255
    12dc:	63 81       	ldd	r22, Z+3	; 0x03
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
    12de:	61 0f       	add	r22, r17
    12e0:	41 e0       	ldi	r20, 0x01	; 1
    12e2:	82 81       	ldd	r24, Z+2	; 0x02
    12e4:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    12e8:	1f 5f       	subi	r17, 0xFF	; 255
    12ea:	14 30       	cpi	r17, 0x04	; 4
    12ec:	80 f3       	brcs	.-32     	; 0x12ce <SevenSeg_Init+0x36>
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
            PIN_OUTPUT
         );
      }    
      /* Set channel to initialized. */    
      gu8_IsInit[Channel] = INIT;
    12ee:	c4 5b       	subi	r28, 0xB4	; 180
    12f0:	d8 4f       	sbci	r29, 0xF8	; 248
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	88 83       	st	Y, r24
      SevenSeg_ErrorState = ERROR_OK;
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	03 c0       	rjmp	.+6      	; 0x1300 <SevenSeg_Init+0x68>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    12fa:	81 ea       	ldi	r24, 0xA1	; 161
    12fc:	01 c0       	rjmp	.+2      	; 0x1300 <SevenSeg_Init+0x68>
   }
   else if(INIT == gu8_IsInit[Channel])
   {
      /* Set initialized before error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
    12fe:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
}
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	1f 91       	pop	r17
    1306:	08 95       	ret

00001308 <SevenSeg_Display>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t SevenSeg_Display(const uint8_t Channel, const uint8_t Number)
{
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    1310:	82 30       	cpi	r24, 0x02	; 2
    1312:	a0 f5       	brcc	.+104    	; 0x137c <SevenSeg_Display+0x74>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT != gu8_IsInit[Channel])
    1314:	c8 2f       	mov	r28, r24
    1316:	d0 e0       	ldi	r29, 0x00	; 0
    1318:	fe 01       	movw	r30, r28
    131a:	e4 5b       	subi	r30, 0xB4	; 180
    131c:	f8 4f       	sbci	r31, 0xF8	; 248
    131e:	80 81       	ld	r24, Z
    1320:	81 30       	cpi	r24, 0x01	; 1
    1322:	71 f5       	brne	.+92     	; 0x1380 <SevenSeg_Display+0x78>
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
   }
   else if(MAX_DISPLAY_NUMBER < Number)
    1324:	6a 30       	cpi	r22, 0x0A	; 10
    1326:	70 f5       	brcc	.+92     	; 0x1384 <SevenSeg_Display+0x7c>
    1328:	16 2f       	mov	r17, r22
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
   }
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
    132a:	0e 94 37 09 	call	0x126e	; 0x126e <SevenSeg_ClearEnable>
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    132e:	00 e0       	ldi	r16, 0x00	; 0
    1330:	16 c0       	rjmp	.+44     	; 0x135e <SevenSeg_Display+0x56>
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
    1332:	41 2f       	mov	r20, r17
    1334:	50 e0       	ldi	r21, 0x00	; 0
    1336:	00 2e       	mov	r0, r16
    1338:	02 c0       	rjmp	.+4      	; 0x133e <SevenSeg_Display+0x36>
    133a:	55 95       	asr	r21
    133c:	47 95       	ror	r20
    133e:	0a 94       	dec	r0
    1340:	e2 f7       	brpl	.-8      	; 0x133a <SevenSeg_Display+0x32>
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
    1342:	fe 01       	movw	r30, r28
    1344:	ee 0f       	add	r30, r30
    1346:	ff 1f       	adc	r31, r31
    1348:	ee 0f       	add	r30, r30
    134a:	ff 1f       	adc	r31, r31
    134c:	ea 51       	subi	r30, 0x1A	; 26
    134e:	ff 4f       	sbci	r31, 0xFF	; 255
    1350:	63 81       	ldd	r22, Z+3	; 0x03
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
    1352:	41 70       	andi	r20, 0x01	; 1
    1354:	60 0f       	add	r22, r16
    1356:	82 81       	ldd	r24, Z+2	; 0x02
    1358:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    135c:	0f 5f       	subi	r16, 0xFF	; 255
    135e:	04 30       	cpi	r16, 0x04	; 4
    1360:	40 f3       	brcs	.-48     	; 0x1332 <SevenSeg_Display+0x2a>
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
         );
      }
      /* Set enable pin to high. */
      DIO_WritePin(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_HIGH);
    1362:	cc 0f       	add	r28, r28
    1364:	dd 1f       	adc	r29, r29
    1366:	cc 0f       	add	r28, r28
    1368:	dd 1f       	adc	r29, r29
    136a:	ca 51       	subi	r28, 0x1A	; 26
    136c:	df 4f       	sbci	r29, 0xFF	; 255
    136e:	41 e0       	ldi	r20, 0x01	; 1
    1370:	69 81       	ldd	r22, Y+1	; 0x01
    1372:	88 81       	ld	r24, Y
    1374:	0e 94 31 0a 	call	0x1462	; 0x1462 <DIO_WritePin>
      SevenSeg_ErrorState = ERROR_OK;
    1378:	80 e0       	ldi	r24, 0x00	; 0
    137a:	05 c0       	rjmp	.+10     	; 0x1386 <SevenSeg_Display+0x7e>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    137c:	81 ea       	ldi	r24, 0xA1	; 161
    137e:	03 c0       	rjmp	.+6      	; 0x1386 <SevenSeg_Display+0x7e>
   }
   else if(INIT != gu8_IsInit[Channel])
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
    1380:	82 ea       	ldi	r24, 0xA2	; 162
    1382:	01 c0       	rjmp	.+2      	; 0x1386 <SevenSeg_Display+0x7e>
   }
   else if(MAX_DISPLAY_NUMBER < Number)
   {
      /* Set invalid number error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
    1384:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret

00001390 <DIO_SetPinDirection>:
				u8_ErrorState=ERROR_NOK;
				break;	
		}	
	}	
	return u8_ErrorState;
}
    1390:	42 30       	cpi	r20, 0x02	; 2
    1392:	08 f0       	brcs	.+2      	; 0x1396 <DIO_SetPinDirection+0x6>
    1394:	60 c0       	rjmp	.+192    	; 0x1456 <DIO_SetPinDirection+0xc6>
    1396:	68 30       	cpi	r22, 0x08	; 8
    1398:	08 f0       	brcs	.+2      	; 0x139c <DIO_SetPinDirection+0xc>
    139a:	5f c0       	rjmp	.+190    	; 0x145a <DIO_SetPinDirection+0xca>
    139c:	81 30       	cpi	r24, 0x01	; 1
    139e:	e1 f0       	breq	.+56     	; 0x13d8 <DIO_SetPinDirection+0x48>
    13a0:	30 f0       	brcs	.+12     	; 0x13ae <DIO_SetPinDirection+0x1e>
    13a2:	82 30       	cpi	r24, 0x02	; 2
    13a4:	71 f1       	breq	.+92     	; 0x1402 <DIO_SetPinDirection+0x72>
    13a6:	83 30       	cpi	r24, 0x03	; 3
    13a8:	09 f4       	brne	.+2      	; 0x13ac <DIO_SetPinDirection+0x1c>
    13aa:	40 c0       	rjmp	.+128    	; 0x142c <DIO_SetPinDirection+0x9c>
    13ac:	58 c0       	rjmp	.+176    	; 0x145e <DIO_SetPinDirection+0xce>
    13ae:	2a b3       	in	r18, 0x1a	; 26
    13b0:	81 e0       	ldi	r24, 0x01	; 1
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	06 2e       	mov	r0, r22
    13b6:	02 c0       	rjmp	.+4      	; 0x13bc <DIO_SetPinDirection+0x2c>
    13b8:	88 0f       	add	r24, r24
    13ba:	99 1f       	adc	r25, r25
    13bc:	0a 94       	dec	r0
    13be:	e2 f7       	brpl	.-8      	; 0x13b8 <DIO_SetPinDirection+0x28>
    13c0:	50 e0       	ldi	r21, 0x00	; 0
    13c2:	02 c0       	rjmp	.+4      	; 0x13c8 <DIO_SetPinDirection+0x38>
    13c4:	44 0f       	add	r20, r20
    13c6:	55 1f       	adc	r21, r21
    13c8:	6a 95       	dec	r22
    13ca:	e2 f7       	brpl	.-8      	; 0x13c4 <DIO_SetPinDirection+0x34>
    13cc:	80 95       	com	r24
    13ce:	82 23       	and	r24, r18
    13d0:	48 2b       	or	r20, r24
    13d2:	4a bb       	out	0x1a, r20	; 26
    13d4:	80 e0       	ldi	r24, 0x00	; 0
    13d6:	08 95       	ret
    13d8:	27 b3       	in	r18, 0x17	; 23
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	06 2e       	mov	r0, r22
    13e0:	02 c0       	rjmp	.+4      	; 0x13e6 <DIO_SetPinDirection+0x56>
    13e2:	88 0f       	add	r24, r24
    13e4:	99 1f       	adc	r25, r25
    13e6:	0a 94       	dec	r0
    13e8:	e2 f7       	brpl	.-8      	; 0x13e2 <DIO_SetPinDirection+0x52>
    13ea:	50 e0       	ldi	r21, 0x00	; 0
    13ec:	02 c0       	rjmp	.+4      	; 0x13f2 <DIO_SetPinDirection+0x62>
    13ee:	44 0f       	add	r20, r20
    13f0:	55 1f       	adc	r21, r21
    13f2:	6a 95       	dec	r22
    13f4:	e2 f7       	brpl	.-8      	; 0x13ee <DIO_SetPinDirection+0x5e>
    13f6:	80 95       	com	r24
    13f8:	82 23       	and	r24, r18
    13fa:	48 2b       	or	r20, r24
    13fc:	47 bb       	out	0x17, r20	; 23
    13fe:	80 e0       	ldi	r24, 0x00	; 0
    1400:	08 95       	ret
    1402:	24 b3       	in	r18, 0x14	; 20
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	06 2e       	mov	r0, r22
    140a:	02 c0       	rjmp	.+4      	; 0x1410 <DIO_SetPinDirection+0x80>
    140c:	88 0f       	add	r24, r24
    140e:	99 1f       	adc	r25, r25
    1410:	0a 94       	dec	r0
    1412:	e2 f7       	brpl	.-8      	; 0x140c <DIO_SetPinDirection+0x7c>
    1414:	50 e0       	ldi	r21, 0x00	; 0
    1416:	02 c0       	rjmp	.+4      	; 0x141c <DIO_SetPinDirection+0x8c>
    1418:	44 0f       	add	r20, r20
    141a:	55 1f       	adc	r21, r21
    141c:	6a 95       	dec	r22
    141e:	e2 f7       	brpl	.-8      	; 0x1418 <DIO_SetPinDirection+0x88>
    1420:	80 95       	com	r24
    1422:	82 23       	and	r24, r18
    1424:	48 2b       	or	r20, r24
    1426:	44 bb       	out	0x14, r20	; 20
    1428:	80 e0       	ldi	r24, 0x00	; 0
    142a:	08 95       	ret
    142c:	21 b3       	in	r18, 0x11	; 17
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	06 2e       	mov	r0, r22
    1434:	02 c0       	rjmp	.+4      	; 0x143a <DIO_SetPinDirection+0xaa>
    1436:	88 0f       	add	r24, r24
    1438:	99 1f       	adc	r25, r25
    143a:	0a 94       	dec	r0
    143c:	e2 f7       	brpl	.-8      	; 0x1436 <DIO_SetPinDirection+0xa6>
    143e:	50 e0       	ldi	r21, 0x00	; 0
    1440:	02 c0       	rjmp	.+4      	; 0x1446 <DIO_SetPinDirection+0xb6>
    1442:	44 0f       	add	r20, r20
    1444:	55 1f       	adc	r21, r21
    1446:	6a 95       	dec	r22
    1448:	e2 f7       	brpl	.-8      	; 0x1442 <DIO_SetPinDirection+0xb2>
    144a:	80 95       	com	r24
    144c:	82 23       	and	r24, r18
    144e:	48 2b       	or	r20, r24
    1450:	41 bb       	out	0x11, r20	; 17
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	08 95       	ret
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	08 95       	ret
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	08 95       	ret
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	08 95       	ret

00001462 <DIO_WritePin>:
    1462:	42 30       	cpi	r20, 0x02	; 2
    1464:	08 f0       	brcs	.+2      	; 0x1468 <DIO_WritePin+0x6>
    1466:	60 c0       	rjmp	.+192    	; 0x1528 <DIO_WritePin+0xc6>
    1468:	68 30       	cpi	r22, 0x08	; 8
    146a:	08 f0       	brcs	.+2      	; 0x146e <DIO_WritePin+0xc>
    146c:	5f c0       	rjmp	.+190    	; 0x152c <DIO_WritePin+0xca>
    146e:	81 30       	cpi	r24, 0x01	; 1
    1470:	e1 f0       	breq	.+56     	; 0x14aa <DIO_WritePin+0x48>
    1472:	30 f0       	brcs	.+12     	; 0x1480 <DIO_WritePin+0x1e>
    1474:	82 30       	cpi	r24, 0x02	; 2
    1476:	71 f1       	breq	.+92     	; 0x14d4 <DIO_WritePin+0x72>
    1478:	83 30       	cpi	r24, 0x03	; 3
    147a:	09 f4       	brne	.+2      	; 0x147e <DIO_WritePin+0x1c>
    147c:	40 c0       	rjmp	.+128    	; 0x14fe <DIO_WritePin+0x9c>
    147e:	58 c0       	rjmp	.+176    	; 0x1530 <DIO_WritePin+0xce>
    1480:	2b b3       	in	r18, 0x1b	; 27
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	90 e0       	ldi	r25, 0x00	; 0
    1486:	06 2e       	mov	r0, r22
    1488:	02 c0       	rjmp	.+4      	; 0x148e <DIO_WritePin+0x2c>
    148a:	88 0f       	add	r24, r24
    148c:	99 1f       	adc	r25, r25
    148e:	0a 94       	dec	r0
    1490:	e2 f7       	brpl	.-8      	; 0x148a <DIO_WritePin+0x28>
    1492:	50 e0       	ldi	r21, 0x00	; 0
    1494:	02 c0       	rjmp	.+4      	; 0x149a <DIO_WritePin+0x38>
    1496:	44 0f       	add	r20, r20
    1498:	55 1f       	adc	r21, r21
    149a:	6a 95       	dec	r22
    149c:	e2 f7       	brpl	.-8      	; 0x1496 <DIO_WritePin+0x34>
    149e:	80 95       	com	r24
    14a0:	82 23       	and	r24, r18
    14a2:	48 2b       	or	r20, r24
    14a4:	4b bb       	out	0x1b, r20	; 27
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	08 95       	ret
    14aa:	28 b3       	in	r18, 0x18	; 24
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	06 2e       	mov	r0, r22
    14b2:	02 c0       	rjmp	.+4      	; 0x14b8 <DIO_WritePin+0x56>
    14b4:	88 0f       	add	r24, r24
    14b6:	99 1f       	adc	r25, r25
    14b8:	0a 94       	dec	r0
    14ba:	e2 f7       	brpl	.-8      	; 0x14b4 <DIO_WritePin+0x52>
    14bc:	50 e0       	ldi	r21, 0x00	; 0
    14be:	02 c0       	rjmp	.+4      	; 0x14c4 <DIO_WritePin+0x62>
    14c0:	44 0f       	add	r20, r20
    14c2:	55 1f       	adc	r21, r21
    14c4:	6a 95       	dec	r22
    14c6:	e2 f7       	brpl	.-8      	; 0x14c0 <DIO_WritePin+0x5e>
    14c8:	80 95       	com	r24
    14ca:	82 23       	and	r24, r18
    14cc:	48 2b       	or	r20, r24
    14ce:	48 bb       	out	0x18, r20	; 24
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	08 95       	ret
    14d4:	25 b3       	in	r18, 0x15	; 21
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	90 e0       	ldi	r25, 0x00	; 0
    14da:	06 2e       	mov	r0, r22
    14dc:	02 c0       	rjmp	.+4      	; 0x14e2 <DIO_WritePin+0x80>
    14de:	88 0f       	add	r24, r24
    14e0:	99 1f       	adc	r25, r25
    14e2:	0a 94       	dec	r0
    14e4:	e2 f7       	brpl	.-8      	; 0x14de <DIO_WritePin+0x7c>
    14e6:	50 e0       	ldi	r21, 0x00	; 0
    14e8:	02 c0       	rjmp	.+4      	; 0x14ee <DIO_WritePin+0x8c>
    14ea:	44 0f       	add	r20, r20
    14ec:	55 1f       	adc	r21, r21
    14ee:	6a 95       	dec	r22
    14f0:	e2 f7       	brpl	.-8      	; 0x14ea <DIO_WritePin+0x88>
    14f2:	80 95       	com	r24
    14f4:	82 23       	and	r24, r18
    14f6:	48 2b       	or	r20, r24
    14f8:	45 bb       	out	0x15, r20	; 21
    14fa:	80 e0       	ldi	r24, 0x00	; 0
    14fc:	08 95       	ret
    14fe:	22 b3       	in	r18, 0x12	; 18
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	06 2e       	mov	r0, r22
    1506:	02 c0       	rjmp	.+4      	; 0x150c <DIO_WritePin+0xaa>
    1508:	88 0f       	add	r24, r24
    150a:	99 1f       	adc	r25, r25
    150c:	0a 94       	dec	r0
    150e:	e2 f7       	brpl	.-8      	; 0x1508 <DIO_WritePin+0xa6>
    1510:	50 e0       	ldi	r21, 0x00	; 0
    1512:	02 c0       	rjmp	.+4      	; 0x1518 <DIO_WritePin+0xb6>
    1514:	44 0f       	add	r20, r20
    1516:	55 1f       	adc	r21, r21
    1518:	6a 95       	dec	r22
    151a:	e2 f7       	brpl	.-8      	; 0x1514 <DIO_WritePin+0xb2>
    151c:	80 95       	com	r24
    151e:	82 23       	and	r24, r18
    1520:	48 2b       	or	r20, r24
    1522:	42 bb       	out	0x12, r20	; 18
    1524:	80 e0       	ldi	r24, 0x00	; 0
    1526:	08 95       	ret
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	08 95       	ret
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	08 95       	ret
    1530:	81 e0       	ldi	r24, 0x01	; 1
    1532:	08 95       	ret

00001534 <DIO_ReadPin>:
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1534:	68 30       	cpi	r22, 0x08	; 8
    1536:	d8 f5       	brcc	.+118    	; 0x15ae <DIO_ReadPin+0x7a>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(NULL_PTR==PinData)
    1538:	41 15       	cp	r20, r1
    153a:	51 05       	cpc	r21, r1
    153c:	d1 f1       	breq	.+116    	; 0x15b2 <DIO_ReadPin+0x7e>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    153e:	81 30       	cpi	r24, 0x01	; 1
    1540:	91 f0       	breq	.+36     	; 0x1566 <DIO_ReadPin+0x32>
    1542:	28 f0       	brcs	.+10     	; 0x154e <DIO_ReadPin+0x1a>
    1544:	82 30       	cpi	r24, 0x02	; 2
    1546:	d9 f0       	breq	.+54     	; 0x157e <DIO_ReadPin+0x4a>
    1548:	83 30       	cpi	r24, 0x03	; 3
    154a:	29 f1       	breq	.+74     	; 0x1596 <DIO_ReadPin+0x62>
    154c:	34 c0       	rjmp	.+104    	; 0x15b6 <DIO_ReadPin+0x82>
		{
			case PORT_A:
				* PinData=BIT_GET(PINA,PinNo);
    154e:	89 b3       	in	r24, 0x19	; 25
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	02 c0       	rjmp	.+4      	; 0x1558 <DIO_ReadPin+0x24>
    1554:	95 95       	asr	r25
    1556:	87 95       	ror	r24
    1558:	6a 95       	dec	r22
    155a:	e2 f7       	brpl	.-8      	; 0x1554 <DIO_ReadPin+0x20>
    155c:	81 70       	andi	r24, 0x01	; 1
    155e:	fa 01       	movw	r30, r20
    1560:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1562:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1564:	08 95       	ret
			case PORT_B:
				* PinData=BIT_GET(PINB,PinNo);
    1566:	86 b3       	in	r24, 0x16	; 22
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	02 c0       	rjmp	.+4      	; 0x1570 <DIO_ReadPin+0x3c>
    156c:	95 95       	asr	r25
    156e:	87 95       	ror	r24
    1570:	6a 95       	dec	r22
    1572:	e2 f7       	brpl	.-8      	; 0x156c <DIO_ReadPin+0x38>
    1574:	81 70       	andi	r24, 0x01	; 1
    1576:	fa 01       	movw	r30, r20
    1578:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    157a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    157c:	08 95       	ret
			case PORT_C:
				* PinData=BIT_GET(PINC,PinNo);
    157e:	83 b3       	in	r24, 0x13	; 19
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	02 c0       	rjmp	.+4      	; 0x1588 <DIO_ReadPin+0x54>
    1584:	95 95       	asr	r25
    1586:	87 95       	ror	r24
    1588:	6a 95       	dec	r22
    158a:	e2 f7       	brpl	.-8      	; 0x1584 <DIO_ReadPin+0x50>
    158c:	81 70       	andi	r24, 0x01	; 1
    158e:	fa 01       	movw	r30, r20
    1590:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1592:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1594:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
    1596:	80 b3       	in	r24, 0x10	; 16
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	02 c0       	rjmp	.+4      	; 0x15a0 <DIO_ReadPin+0x6c>
    159c:	95 95       	asr	r25
    159e:	87 95       	ror	r24
    15a0:	6a 95       	dec	r22
    15a2:	e2 f7       	brpl	.-8      	; 0x159c <DIO_ReadPin+0x68>
    15a4:	81 70       	andi	r24, 0x01	; 1
    15a6:	fa 01       	movw	r30, r20
    15a8:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    15aa:	80 e0       	ldi	r24, 0x00	; 0
				break;
    15ac:	08 95       	ret
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	08 95       	ret
	}
	else if(NULL_PTR==PinData)
	{
		u8_ErrorState=ERROR_NOK;
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    15b8:	08 95       	ret

000015ba <DIO_EnablePinPullup>:


ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    15ba:	68 30       	cpi	r22, 0x08	; 8
    15bc:	c0 f5       	brcc	.+112    	; 0x162e <DIO_EnablePinPullup+0x74>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{	
		switch(PortName)
    15be:	81 30       	cpi	r24, 0x01	; 1
    15c0:	91 f0       	breq	.+36     	; 0x15e6 <DIO_EnablePinPullup+0x2c>
    15c2:	28 f0       	brcs	.+10     	; 0x15ce <DIO_EnablePinPullup+0x14>
    15c4:	82 30       	cpi	r24, 0x02	; 2
    15c6:	d9 f0       	breq	.+54     	; 0x15fe <DIO_EnablePinPullup+0x44>
    15c8:	83 30       	cpi	r24, 0x03	; 3
    15ca:	29 f1       	breq	.+74     	; 0x1616 <DIO_EnablePinPullup+0x5c>
    15cc:	32 c0       	rjmp	.+100    	; 0x1632 <DIO_EnablePinPullup+0x78>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PIN_HIGH);
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	02 c0       	rjmp	.+4      	; 0x15d8 <DIO_EnablePinPullup+0x1e>
    15d4:	88 0f       	add	r24, r24
    15d6:	99 1f       	adc	r25, r25
    15d8:	6a 95       	dec	r22
    15da:	e2 f7       	brpl	.-8      	; 0x15d4 <DIO_EnablePinPullup+0x1a>
    15dc:	9b b3       	in	r25, 0x1b	; 27
    15de:	89 2b       	or	r24, r25
    15e0:	8b bb       	out	0x1b, r24	; 27
				u8_ErrorState=ERROR_OK;
    15e2:	80 e0       	ldi	r24, 0x00	; 0
				break;
    15e4:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PIN_HIGH);
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	02 c0       	rjmp	.+4      	; 0x15f0 <DIO_EnablePinPullup+0x36>
    15ec:	88 0f       	add	r24, r24
    15ee:	99 1f       	adc	r25, r25
    15f0:	6a 95       	dec	r22
    15f2:	e2 f7       	brpl	.-8      	; 0x15ec <DIO_EnablePinPullup+0x32>
    15f4:	98 b3       	in	r25, 0x18	; 24
    15f6:	89 2b       	or	r24, r25
    15f8:	88 bb       	out	0x18, r24	; 24
				u8_ErrorState=ERROR_OK;
    15fa:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    15fc:	08 95       	ret
			case PORT_C:                          
				BIT_WRITE(PORTC,PinNo,PIN_HIGH);
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	02 c0       	rjmp	.+4      	; 0x1608 <DIO_EnablePinPullup+0x4e>
    1604:	88 0f       	add	r24, r24
    1606:	99 1f       	adc	r25, r25
    1608:	6a 95       	dec	r22
    160a:	e2 f7       	brpl	.-8      	; 0x1604 <DIO_EnablePinPullup+0x4a>
    160c:	95 b3       	in	r25, 0x15	; 21
    160e:	89 2b       	or	r24, r25
    1610:	85 bb       	out	0x15, r24	; 21
				u8_ErrorState=ERROR_OK;
    1612:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    1614:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
    1616:	81 e0       	ldi	r24, 0x01	; 1
    1618:	90 e0       	ldi	r25, 0x00	; 0
    161a:	02 c0       	rjmp	.+4      	; 0x1620 <DIO_EnablePinPullup+0x66>
    161c:	88 0f       	add	r24, r24
    161e:	99 1f       	adc	r25, r25
    1620:	6a 95       	dec	r22
    1622:	e2 f7       	brpl	.-8      	; 0x161c <DIO_EnablePinPullup+0x62>
    1624:	92 b3       	in	r25, 0x12	; 18
    1626:	89 2b       	or	r24, r25
    1628:	82 bb       	out	0x12, r24	; 18
				u8_ErrorState=ERROR_OK;
    162a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    162c:	08 95       	ret
ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1632:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}	
	}	
	return u8_ErrorState;
    1634:	08 95       	ret

00001636 <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    1636:	83 30       	cpi	r24, 0x03	; 3
    1638:	69 f5       	brne	.+90     	; 0x1694 <PWM_Init+0x5e>
    163a:	85 b5       	in	r24, 0x25	; 37
    163c:	e3 e6       	ldi	r30, 0x63	; 99
    163e:	f0 e0       	ldi	r31, 0x00	; 0
    1640:	92 85       	ldd	r25, Z+10	; 0x0a
    1642:	49 2f       	mov	r20, r25
    1644:	41 70       	andi	r20, 0x01	; 1
    1646:	50 e0       	ldi	r21, 0x00	; 0
    1648:	00 24       	eor	r0, r0
    164a:	56 95       	lsr	r21
    164c:	47 95       	ror	r20
    164e:	07 94       	ror	r0
    1650:	56 95       	lsr	r21
    1652:	47 95       	ror	r20
    1654:	07 94       	ror	r0
    1656:	54 2f       	mov	r21, r20
    1658:	40 2d       	mov	r20, r0
    165a:	8f 7b       	andi	r24, 0xBF	; 191
    165c:	48 2b       	or	r20, r24
    165e:	91 fb       	bst	r25, 1
    1660:	22 27       	eor	r18, r18
    1662:	20 f9       	bld	r18, 0
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	22 0f       	add	r18, r18
    1668:	33 1f       	adc	r19, r19
    166a:	22 0f       	add	r18, r18
    166c:	33 1f       	adc	r19, r19
    166e:	22 0f       	add	r18, r18
    1670:	33 1f       	adc	r19, r19
    1672:	47 7f       	andi	r20, 0xF7	; 247
    1674:	24 2b       	or	r18, r20
    1676:	83 85       	ldd	r24, Z+11	; 0x0b
    1678:	30 e1       	ldi	r19, 0x10	; 16
    167a:	83 9f       	mul	r24, r19
    167c:	c0 01       	movw	r24, r0
    167e:	11 24       	eor	r1, r1
    1680:	2f 7c       	andi	r18, 0xCF	; 207
    1682:	28 2b       	or	r18, r24
    1684:	25 bd       	out	0x25, r18	; 37
    1686:	41 e0       	ldi	r20, 0x01	; 1
    1688:	67 e0       	ldi	r22, 0x07	; 7
    168a:	83 e0       	ldi	r24, 0x03	; 3
    168c:	0e 94 c8 09 	call	0x1390	; 0x1390 <DIO_SetPinDirection>
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	08 95       	ret
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	08 95       	ret

00001698 <PWM_Start>:
    1698:	83 30       	cpi	r24, 0x03	; 3
    169a:	41 f4       	brne	.+16     	; 0x16ac <PWM_Start+0x14>
    169c:	85 b5       	in	r24, 0x25	; 37
    169e:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <gastr_PWMConfig+0x9>
    16a2:	88 7f       	andi	r24, 0xF8	; 248
    16a4:	89 2b       	or	r24, r25
    16a6:	85 bd       	out	0x25, r24	; 37
    16a8:	80 e0       	ldi	r24, 0x00	; 0
    16aa:	08 95       	ret
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	08 95       	ret

000016b0 <PWM_Connect>:
    16b0:	83 30       	cpi	r24, 0x03	; 3
    16b2:	69 f4       	brne	.+26     	; 0x16ce <PWM_Connect+0x1e>
    16b4:	25 b5       	in	r18, 0x25	; 37
    16b6:	90 91 6e 00 	lds	r25, 0x006E	; 0x80006e <gastr_PWMConfig+0xb>
    16ba:	30 e1       	ldi	r19, 0x10	; 16
    16bc:	93 9f       	mul	r25, r19
    16be:	c0 01       	movw	r24, r0
    16c0:	11 24       	eor	r1, r1
    16c2:	92 2f       	mov	r25, r18
    16c4:	9f 7c       	andi	r25, 0xCF	; 207
    16c6:	89 2b       	or	r24, r25
    16c8:	85 bd       	out	0x25, r24	; 37
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	08 95       	ret
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	08 95       	ret

000016d2 <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    16d2:	9f ef       	ldi	r25, 0xFF	; 255
    16d4:	96 0f       	add	r25, r22
    16d6:	94 36       	cpi	r25, 0x64	; 100
    16d8:	10 f5       	brcc	.+68     	; 0x171e <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    16da:	83 30       	cpi	r24, 0x03	; 3
    16dc:	11 f5       	brne	.+68     	; 0x1722 <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    16de:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <gastr_PWMConfig+0xb>
    16e2:	82 30       	cpi	r24, 0x02	; 2
    16e4:	01 f5       	brne	.+64     	; 0x1726 <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    16e6:	70 e0       	ldi	r23, 0x00	; 0
    16e8:	80 e0       	ldi	r24, 0x00	; 0
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <__floatsisf>
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	48 ec       	ldi	r20, 0xC8	; 200
    16f6:	52 e4       	ldi	r21, 0x42	; 66
    16f8:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <__divsf3>
    16fc:	20 e0       	ldi	r18, 0x00	; 0
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	40 e8       	ldi	r20, 0x80	; 128
    1702:	53 e4       	ldi	r21, 0x43	; 67
    1704:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__mulsf3>
    1708:	20 e0       	ldi	r18, 0x00	; 0
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	40 e8       	ldi	r20, 0x80	; 128
    170e:	5f e3       	ldi	r21, 0x3F	; 63
    1710:	0e 94 c4 0d 	call	0x1b88	; 0x1b88 <__subsf3>
    1714:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <__fixunssfsi>
    1718:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    171a:	80 e0       	ldi	r24, 0x00	; 0
							break;
    171c:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    1722:	81 e0       	ldi	r24, 0x01	; 1
    1724:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    1726:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    1728:	08 95       	ret

0000172a <HMI_MainFunction>:
* @brief: This function is the HMI main function.
*
* @return function error state.
*/
extern void HMI_MainFunction(void)
{
    172a:	0f 93       	push	r16
    172c:	1f 93       	push	r17
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	00 d0       	rcall	.+0      	; 0x1734 <HMI_MainFunction+0xa>
    1734:	00 d0       	rcall	.+0      	; 0x1736 <HMI_MainFunction+0xc>
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
   uint32_t u32_Key;
   static uint32_t u32_OldKey = 0;
   static uint32_t u32_LastSetKey = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    173a:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <u8_Init.1656>
    173e:	81 11       	cpse	r24, r1
    1740:	07 c0       	rjmp	.+14     	; 0x1750 <HMI_MainFunction+0x26>
   {
      KP_Init(KP_UsedChannel);
    1742:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <KP_UsedChannel>
    1746:	0e 94 1b 07 	call	0xe36	; 0xe36 <KP_Init>
      u8_Init = 1;
    174a:	81 e0       	ldi	r24, 0x01	; 1
    174c:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <u8_Init.1656>
   }
   
   /* Get KEypad pressed keys. */
   KP_GetPressedValue(KP_UsedChannel, &u32_Key);
    1750:	be 01       	movw	r22, r28
    1752:	6f 5f       	subi	r22, 0xFF	; 255
    1754:	7f 4f       	sbci	r23, 0xFF	; 255
    1756:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <KP_UsedChannel>
    175a:	0e 94 77 07 	call	0xeee	; 0xeee <KP_GetPressedValue>
   
   if(u32_OldKey == u32_Key && u32_LastSetKey != u32_Key)
    175e:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <u32_OldKey.1658>
    1762:	90 91 53 07 	lds	r25, 0x0753	; 0x800753 <u32_OldKey.1658+0x1>
    1766:	a0 91 54 07 	lds	r26, 0x0754	; 0x800754 <u32_OldKey.1658+0x2>
    176a:	b0 91 55 07 	lds	r27, 0x0755	; 0x800755 <u32_OldKey.1658+0x3>
    176e:	49 81       	ldd	r20, Y+1	; 0x01
    1770:	5a 81       	ldd	r21, Y+2	; 0x02
    1772:	6b 81       	ldd	r22, Y+3	; 0x03
    1774:	7c 81       	ldd	r23, Y+4	; 0x04
    1776:	84 17       	cp	r24, r20
    1778:	95 07       	cpc	r25, r21
    177a:	a6 07       	cpc	r26, r22
    177c:	b7 07       	cpc	r27, r23
    177e:	09 f0       	breq	.+2      	; 0x1782 <HMI_MainFunction+0x58>
    1780:	42 c0       	rjmp	.+132    	; 0x1806 <HMI_MainFunction+0xdc>
    1782:	80 91 4e 07 	lds	r24, 0x074E	; 0x80074e <u32_LastSetKey.1659>
    1786:	90 91 4f 07 	lds	r25, 0x074F	; 0x80074f <u32_LastSetKey.1659+0x1>
    178a:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <u32_LastSetKey.1659+0x2>
    178e:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <u32_LastSetKey.1659+0x3>
    1792:	48 17       	cp	r20, r24
    1794:	59 07       	cpc	r21, r25
    1796:	6a 07       	cpc	r22, r26
    1798:	7b 07       	cpc	r23, r27
    179a:	a9 f1       	breq	.+106    	; 0x1806 <HMI_MainFunction+0xdc>
   {
      u32_LastSetKey = u32_Key;
    179c:	40 93 4e 07 	sts	0x074E, r20	; 0x80074e <u32_LastSetKey.1659>
    17a0:	50 93 4f 07 	sts	0x074F, r21	; 0x80074f <u32_LastSetKey.1659+0x1>
    17a4:	60 93 50 07 	sts	0x0750, r22	; 0x800750 <u32_LastSetKey.1659+0x2>
    17a8:	70 93 51 07 	sts	0x0751, r23	; 0x800751 <u32_LastSetKey.1659+0x3>
      /* If multi buttons are pressed. */
      if(MULTI_PRESS_BIT & u32_Key)
    17ac:	40 ff       	sbrs	r20, 0
    17ae:	11 c0       	rjmp	.+34     	; 0x17d2 <HMI_MainFunction+0xa8>
      {
         /* Device erase pattern keys are pressed */
         if(DEVICE_ERASE_VALUE == u32_Key)
    17b0:	43 34       	cpi	r20, 0x43	; 67
    17b2:	80 e1       	ldi	r24, 0x10	; 16
    17b4:	58 07       	cpc	r21, r24
    17b6:	61 05       	cpc	r22, r1
    17b8:	71 05       	cpc	r23, r1
    17ba:	19 f4       	brne	.+6      	; 0x17c2 <HMI_MainFunction+0x98>
         {
            /* Set device erase flag. */
            HMI_SetDeviceEraseFlag();
    17bc:	0e 94 18 0c 	call	0x1830	; 0x1830 <HMI_SetDeviceEraseFlag>
    17c0:	22 c0       	rjmp	.+68     	; 0x1806 <HMI_MainFunction+0xdc>
         }
         /* password change pattern keys are pressed */
         else if(PASSWORD_CHANGE_VALUE == u32_Key)
    17c2:	43 34       	cpi	r20, 0x43	; 67
    17c4:	54 40       	sbci	r21, 0x04	; 4
    17c6:	61 05       	cpc	r22, r1
    17c8:	71 05       	cpc	r23, r1
    17ca:	e9 f4       	brne	.+58     	; 0x1806 <HMI_MainFunction+0xdc>
         {
            /* Set password change flag. */
            HMI_SetPasswordChangeFlag();
    17cc:	0e 94 1d 0c 	call	0x183a	; 0x183a <HMI_SetPasswordChangeFlag>
    17d0:	1a c0       	rjmp	.+52     	; 0x1806 <HMI_MainFunction+0xdc>
         else
         {
         }
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
    17d2:	41 15       	cp	r20, r1
    17d4:	51 05       	cpc	r21, r1
    17d6:	61 05       	cpc	r22, r1
    17d8:	71 05       	cpc	r23, r1
    17da:	91 f4       	brne	.+36     	; 0x1800 <HMI_MainFunction+0xd6>
    17dc:	14 c0       	rjmp	.+40     	; 0x1806 <HMI_MainFunction+0xdc>
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
         {
            if((u32_Key >> u8_KeyCounter) & 1 )
    17de:	8a 01       	movw	r16, r20
    17e0:	9b 01       	movw	r18, r22
    17e2:	08 2e       	mov	r0, r24
    17e4:	04 c0       	rjmp	.+8      	; 0x17ee <HMI_MainFunction+0xc4>
    17e6:	36 95       	lsr	r19
    17e8:	27 95       	ror	r18
    17ea:	17 95       	ror	r17
    17ec:	07 95       	ror	r16
    17ee:	0a 94       	dec	r0
    17f0:	d2 f7       	brpl	.-12     	; 0x17e6 <HMI_MainFunction+0xbc>
    17f2:	00 ff       	sbrs	r16, 0
    17f4:	03 c0       	rjmp	.+6      	; 0x17fc <HMI_MainFunction+0xd2>
            {
               HMI_SetKeyPressed(u8_KeyCounter);
    17f6:	0e 94 22 0c 	call	0x1844	; 0x1844 <HMI_SetKeyPressed>
               break;
    17fa:	05 c0       	rjmp	.+10     	; 0x1806 <HMI_MainFunction+0xdc>
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
    17fc:	8f 5f       	subi	r24, 0xFF	; 255
    17fe:	01 c0       	rjmp	.+2      	; 0x1802 <HMI_MainFunction+0xd8>
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	8d 30       	cpi	r24, 0x0D	; 13
    1804:	60 f3       	brcs	.-40     	; 0x17de <HMI_MainFunction+0xb4>
      }
      else
      {
      }
   }
   u32_OldKey = u32_Key;
    1806:	89 81       	ldd	r24, Y+1	; 0x01
    1808:	9a 81       	ldd	r25, Y+2	; 0x02
    180a:	ab 81       	ldd	r26, Y+3	; 0x03
    180c:	bc 81       	ldd	r27, Y+4	; 0x04
    180e:	80 93 52 07 	sts	0x0752, r24	; 0x800752 <u32_OldKey.1658>
    1812:	90 93 53 07 	sts	0x0753, r25	; 0x800753 <u32_OldKey.1658+0x1>
    1816:	a0 93 54 07 	sts	0x0754, r26	; 0x800754 <u32_OldKey.1658+0x2>
    181a:	b0 93 55 07 	sts	0x0755, r27	; 0x800755 <u32_OldKey.1658+0x3>
      
    181e:	0f 90       	pop	r0
    1820:	0f 90       	pop	r0
    1822:	0f 90       	pop	r0
    1824:	0f 90       	pop	r0
    1826:	df 91       	pop	r29
    1828:	cf 91       	pop	r28
    182a:	1f 91       	pop	r17
    182c:	0f 91       	pop	r16
    182e:	08 95       	ret

00001830 <HMI_SetDeviceEraseFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetDeviceEraseFlag(void)
{
   /* Set the device erase flag. */
   gu8_DeviceEraseFlag = DEVICE_ERASE_FLAG;
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <gu8_DeviceEraseFlag>
   /* return Error state. */
   return ERROR_OK;
}
    1836:	80 e0       	ldi	r24, 0x00	; 0
    1838:	08 95       	ret

0000183a <HMI_SetPasswordChangeFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetPasswordChangeFlag(void)
{
   /* Set the password change flag. */
   gu8_PasswordChangeFlag = PASSWORD_CHANGE_FLAG;
    183a:	81 e0       	ldi	r24, 0x01	; 1
    183c:	80 93 58 07 	sts	0x0758, r24	; 0x800758 <gu8_PasswordChangeFlag>
   /* return Error state. */
   return ERROR_OK;
}
    1840:	80 e0       	ldi	r24, 0x00	; 0
    1842:	08 95       	ret

00001844 <HMI_SetKeyPressed>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t HMI_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
    1844:	8d 30       	cpi	r24, 0x0D	; 13
    1846:	20 f4       	brcc	.+8      	; 0x1850 <HMI_SetKeyPressed+0xc>
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
   }
   else
   {
      /* Set the pressed key value. */
      gu8_KeyPressedValue = Value;
    1848:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <gu8_KeyPressedValue>
      HMI_ErrorState = ERROR_OK;
    184c:	80 e0       	ldi	r24, 0x00	; 0
    184e:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
   {
      /* Set invalid Value error. */
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
    1850:	82 ed       	ldi	r24, 0xD2	; 210
      HMI_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return HMI_ErrorState;
    1852:	08 95       	ret

00001854 <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    1854:	cf 93       	push	r28
    1856:	df 93       	push	r29
    1858:	00 d0       	rcall	.+0      	; 0x185a <Indicator_MainFunction+0x6>
    185a:	1f 92       	push	r1
    185c:	cd b7       	in	r28, 0x3d	; 61
    185e:	de b7       	in	r29, 0x3e	; 62
   /* OS Variable used for calculating the function waiting period. */
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1860:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1864:	9a 83       	std	Y+2, r25	; 0x02
    1866:	89 83       	std	Y+1, r24	; 0x01
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    1868:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <u8_Init.1972>
    186c:	81 11       	cpse	r24, r1
    186e:	09 c0       	rjmp	.+18     	; 0x1882 <Indicator_MainFunction+0x2e>
   {
      Indicator_SetPattern(INDICATOR_MALFUNCTION_PATTERN);
    1870:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <Indicator_SetPattern>
      LED_Init(LED_UsedChannel);
    1874:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <LED_UsedChannel>
    1878:	0e 94 28 08 	call	0x1050	; 0x1050 <LED_Init>
      u8_Init = 1;
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <u8_Init.1972>
   }
   
   /* Get the current pattern. */
   Indicator_GetPattern(&u8_Pattern);
    1882:	ce 01       	movw	r24, r28
    1884:	03 96       	adiw	r24, 0x03	; 3
    1886:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <Indicator_GetPattern>
   
   /* If a new pattern is set. */
   if( u8_Pattern != u8_OldPattern)
    188a:	eb 81       	ldd	r30, Y+3	; 0x03
    188c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1890:	e8 17       	cp	r30, r24
    1892:	31 f0       	breq	.+12     	; 0x18a0 <Indicator_MainFunction+0x4c>
   {
      u8_OldPattern = u8_Pattern;
    1894:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__DATA_REGION_ORIGIN__>
      /* Reinitialize the state and the duty cycle. */
      State = Indicator_LowTime;
    1898:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <State.1975>
      u8_Duty = MIN_DUTY;
    189c:	10 92 5a 07 	sts	0x075A, r1	; 0x80075a <u8_Duty.1976>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    18a0:	e4 30       	cpi	r30, 0x04	; 4
    18a2:	09 f4       	brne	.+2      	; 0x18a6 <Indicator_MainFunction+0x52>
    18a4:	82 c0       	rjmp	.+260    	; 0x19aa <Indicator_MainFunction+0x156>
   {
      switch(State)
    18a6:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <State.1975>
    18aa:	81 30       	cpi	r24, 0x01	; 1
    18ac:	f9 f0       	breq	.+62     	; 0x18ec <Indicator_MainFunction+0x98>
    18ae:	38 f0       	brcs	.+14     	; 0x18be <Indicator_MainFunction+0x6a>
    18b0:	82 30       	cpi	r24, 0x02	; 2
    18b2:	09 f4       	brne	.+2      	; 0x18b6 <Indicator_MainFunction+0x62>
    18b4:	40 c0       	rjmp	.+128    	; 0x1936 <Indicator_MainFunction+0xe2>
    18b6:	83 30       	cpi	r24, 0x03	; 3
    18b8:	09 f4       	brne	.+2      	; 0x18bc <Indicator_MainFunction+0x68>
    18ba:	54 c0       	rjmp	.+168    	; 0x1964 <Indicator_MainFunction+0x110>
    18bc:	76 c0       	rjmp	.+236    	; 0x19aa <Indicator_MainFunction+0x156>
      {
         case Indicator_LowTime:
            /* Turn off led */
            LED_Off(LED_UsedChannel);
    18be:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <LED_UsedChannel>
    18c2:	0e 94 8e 08 	call	0x111c	; 0x111c <LED_Off>
            /* Change state to rise time state. */
            State = Indicator_RiseTime;
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <State.1975>
            /* Put the task in waiting state for the low time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    18cc:	eb 81       	ldd	r30, Y+3	; 0x03
    18ce:	86 e1       	ldi	r24, 0x16	; 22
    18d0:	e8 9f       	mul	r30, r24
    18d2:	f0 01       	movw	r30, r0
    18d4:	11 24       	eor	r1, r1
    18d6:	eb 58       	subi	r30, 0x8B	; 139
    18d8:	ff 4f       	sbci	r31, 0xFF	; 255
    18da:	60 89       	ldd	r22, Z+16	; 0x10
    18dc:	71 89       	ldd	r23, Z+17	; 0x11
    18de:	82 89       	ldd	r24, Z+18	; 0x12
    18e0:	93 89       	ldd	r25, Z+19	; 0x13
    18e2:	ce 01       	movw	r24, r28
    18e4:	01 96       	adiw	r24, 0x01	; 1
    18e6:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    18ea:	5f c0       	rjmp	.+190    	; 0x19aa <Indicator_MainFunction+0x156>
         case Indicator_RiseTime:
            /* Increase the duty with the rate of change. */
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    18ec:	86 e1       	ldi	r24, 0x16	; 22
    18ee:	e8 9f       	mul	r30, r24
    18f0:	f0 01       	movw	r30, r0
    18f2:	11 24       	eor	r1, r1
    18f4:	eb 58       	subi	r30, 0x8B	; 139
    18f6:	ff 4f       	sbci	r31, 0xFF	; 255
    18f8:	65 89       	ldd	r22, Z+21	; 0x15
    18fa:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <u8_Duty.1976>
    18fe:	68 0f       	add	r22, r24
    1900:	60 93 5a 07 	sts	0x075A, r22	; 0x80075a <u8_Duty.1976>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    1904:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <LED_UsedChannel>
    1908:	0e 94 0a 09 	call	0x1214	; 0x1214 <LED_Dim>
            /* Change state to high time state. */
            if(u8_Duty == MAX_DUTY)
    190c:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <u8_Duty.1976>
    1910:	84 36       	cpi	r24, 0x64	; 100
    1912:	19 f4       	brne	.+6      	; 0x191a <Indicator_MainFunction+0xc6>
            {
               State = Indicator_HighTime;
    1914:	82 e0       	ldi	r24, 0x02	; 2
    1916:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <State.1975>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    191a:	eb 81       	ldd	r30, Y+3	; 0x03
    191c:	86 e1       	ldi	r24, 0x16	; 22
    191e:	e8 9f       	mul	r30, r24
    1920:	f0 01       	movw	r30, r0
    1922:	11 24       	eor	r1, r1
    1924:	eb 58       	subi	r30, 0x8B	; 139
    1926:	ff 4f       	sbci	r31, 0xFF	; 255
    1928:	64 89       	ldd	r22, Z+20	; 0x14
    192a:	70 e0       	ldi	r23, 0x00	; 0
    192c:	ce 01       	movw	r24, r28
    192e:	01 96       	adiw	r24, 0x01	; 1
    1930:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    1934:	3a c0       	rjmp	.+116    	; 0x19aa <Indicator_MainFunction+0x156>
         case Indicator_HighTime:
            /* Turn led on. */
            LED_On(LED_UsedChannel);
    1936:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <LED_UsedChannel>
    193a:	0e 94 cc 08 	call	0x1198	; 0x1198 <LED_On>
            /* Change state to fall time state. */
            State = Indicator_FallTime;
    193e:	83 e0       	ldi	r24, 0x03	; 3
    1940:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <State.1975>
            /* Put the task in waiting state for the high time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    1944:	eb 81       	ldd	r30, Y+3	; 0x03
    1946:	86 e1       	ldi	r24, 0x16	; 22
    1948:	e8 9f       	mul	r30, r24
    194a:	f0 01       	movw	r30, r0
    194c:	11 24       	eor	r1, r1
    194e:	eb 58       	subi	r30, 0x8B	; 139
    1950:	ff 4f       	sbci	r31, 0xFF	; 255
    1952:	64 81       	ldd	r22, Z+4	; 0x04
    1954:	75 81       	ldd	r23, Z+5	; 0x05
    1956:	86 81       	ldd	r24, Z+6	; 0x06
    1958:	97 81       	ldd	r25, Z+7	; 0x07
    195a:	ce 01       	movw	r24, r28
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    1962:	23 c0       	rjmp	.+70     	; 0x19aa <Indicator_MainFunction+0x156>
         case Indicator_FallTime:
            /* decrease the duty with the rate of change. */
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    1964:	86 e1       	ldi	r24, 0x16	; 22
    1966:	e8 9f       	mul	r30, r24
    1968:	f0 01       	movw	r30, r0
    196a:	11 24       	eor	r1, r1
    196c:	eb 58       	subi	r30, 0x8B	; 139
    196e:	ff 4f       	sbci	r31, 0xFF	; 255
    1970:	85 89       	ldd	r24, Z+21	; 0x15
    1972:	60 91 5a 07 	lds	r22, 0x075A	; 0x80075a <u8_Duty.1976>
    1976:	68 1b       	sub	r22, r24
    1978:	60 93 5a 07 	sts	0x075A, r22	; 0x80075a <u8_Duty.1976>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    197c:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <LED_UsedChannel>
    1980:	0e 94 0a 09 	call	0x1214	; 0x1214 <LED_Dim>
            /* Change state to low time state. */
            if(u8_Duty == MIN_DUTY)
    1984:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <u8_Duty.1976>
    1988:	81 11       	cpse	r24, r1
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <Indicator_MainFunction+0x13c>
            {
               State = Indicator_LowTime;
    198c:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <State.1975>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    1990:	eb 81       	ldd	r30, Y+3	; 0x03
    1992:	86 e1       	ldi	r24, 0x16	; 22
    1994:	e8 9f       	mul	r30, r24
    1996:	f0 01       	movw	r30, r0
    1998:	11 24       	eor	r1, r1
    199a:	eb 58       	subi	r30, 0x8B	; 139
    199c:	ff 4f       	sbci	r31, 0xFF	; 255
    199e:	64 89       	ldd	r22, Z+20	; 0x14
    19a0:	70 e0       	ldi	r23, 0x00	; 0
    19a2:	ce 01       	movw	r24, r28
    19a4:	01 96       	adiw	r24, 0x01	; 1
    19a6:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
      }
   }
    19aa:	0f 90       	pop	r0
    19ac:	0f 90       	pop	r0
    19ae:	0f 90       	pop	r0
    19b0:	df 91       	pop	r29
    19b2:	cf 91       	pop	r28
    19b4:	08 95       	ret

000019b6 <Indicator_GetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    19b6:	00 97       	sbiw	r24, 0x00	; 0
    19b8:	31 f0       	breq	.+12     	; 0x19c6 <Indicator_GetPattern+0x10>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      /* Return the indicator pattern. */
      *Value = gu8_IndicatorPattern;
    19ba:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <gu8_IndicatorPattern>
    19be:	fc 01       	movw	r30, r24
    19c0:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    19c4:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    19c6:	82 eb       	ldi	r24, 0xB2	; 178
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
}
    19c8:	08 95       	ret

000019ca <Indicator_SetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INDICATOR_INVALID_PATTERN <= Value)
    19ca:	84 30       	cpi	r24, 0x04	; 4
    19cc:	20 f4       	brcc	.+8      	; 0x19d6 <Indicator_SetPattern+0xc>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
   }
   else
   {
      /* Set the indicator pattern. */
      gu8_IndicatorPattern = Value;
    19ce:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <gu8_IndicatorPattern>
      Indicator_ErrorState = ERROR_OK;
    19d2:	80 e0       	ldi	r24, 0x00	; 0
    19d4:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INDICATOR_INVALID_PATTERN <= Value)
   {
      /* Set invalid value error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
    19d6:	81 eb       	ldi	r24, 0xB1	; 177
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
    19d8:	08 95       	ret

000019da <SSD_Display_MainFunction>:
* @brief: This function is the Display main function.
*
* @return function error state.
*/
extern void SSD_Display_MainFunction(void)
{
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	1f 92       	push	r1
    19e4:	cd b7       	in	r28, 0x3d	; 61
    19e6:	de b7       	in	r29, 0x3e	; 62
   static uint8_t u8_Init = 0;  
   uint8_t u8_SevenSegmentNumber; 
   static Enu_SSDDisplayStateMachine State = SSD_Display_FirstNumber;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    19e8:	80 91 5e 07 	lds	r24, 0x075E	; 0x80075e <u8_Init.1654>
    19ec:	81 11       	cpse	r24, r1
    19ee:	0d c0       	rjmp	.+26     	; 0x1a0a <SSD_Display_MainFunction+0x30>
   {
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh0);
    19f0:	0e ec       	ldi	r16, 0xCE	; 206
    19f2:	10 e0       	ldi	r17, 0x00	; 0
    19f4:	f8 01       	movw	r30, r16
    19f6:	80 81       	ld	r24, Z
    19f8:	0e 94 4c 09 	call	0x1298	; 0x1298 <SevenSeg_Init>
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh1);
    19fc:	f8 01       	movw	r30, r16
    19fe:	81 81       	ldd	r24, Z+1	; 0x01
    1a00:	0e 94 4c 09 	call	0x1298	; 0x1298 <SevenSeg_Init>
      u8_Init = 1;
    1a04:	81 e0       	ldi	r24, 0x01	; 1
    1a06:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <u8_Init.1654>
   }
   
   /* Get the number to display. */
   SSD_Display_GetSevenSegment(&u8_SevenSegmentNumber);
    1a0a:	ce 01       	movw	r24, r28
    1a0c:	01 96       	adiw	r24, 0x01	; 1
    1a0e:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <SSD_Display_GetSevenSegment>
   
   switch(State)
    1a12:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <State.1656>
    1a16:	88 23       	and	r24, r24
    1a18:	19 f0       	breq	.+6      	; 0x1a20 <SSD_Display_MainFunction+0x46>
    1a1a:	81 30       	cpi	r24, 0x01	; 1
    1a1c:	b9 f0       	breq	.+46     	; 0x1a4c <SSD_Display_MainFunction+0x72>
    1a1e:	24 c0       	rjmp	.+72     	; 0x1a68 <SSD_Display_MainFunction+0x8e>
   {
      case SSD_Display_FirstNumber:
         /* Display the first number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh0, u8_SevenSegmentNumber%10);
    1a20:	69 81       	ldd	r22, Y+1	; 0x01
    1a22:	8d ec       	ldi	r24, 0xCD	; 205
    1a24:	68 9f       	mul	r22, r24
    1a26:	81 2d       	mov	r24, r1
    1a28:	11 24       	eor	r1, r1
    1a2a:	86 95       	lsr	r24
    1a2c:	86 95       	lsr	r24
    1a2e:	86 95       	lsr	r24
    1a30:	88 0f       	add	r24, r24
    1a32:	98 2f       	mov	r25, r24
    1a34:	99 0f       	add	r25, r25
    1a36:	99 0f       	add	r25, r25
    1a38:	89 0f       	add	r24, r25
    1a3a:	68 1b       	sub	r22, r24
    1a3c:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <STR_DisplaySegmentConfig>
    1a40:	0e 94 84 09 	call	0x1308	; 0x1308 <SevenSeg_Display>
         State = SSD_Display_SecondNumber;
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <State.1656>
         break;
    1a4a:	0e c0       	rjmp	.+28     	; 0x1a68 <SSD_Display_MainFunction+0x8e>
      case SSD_Display_SecondNumber:
         /* Display the second number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh1, u8_SevenSegmentNumber/10);
    1a4c:	89 81       	ldd	r24, Y+1	; 0x01
    1a4e:	6d ec       	ldi	r22, 0xCD	; 205
    1a50:	86 9f       	mul	r24, r22
    1a52:	61 2d       	mov	r22, r1
    1a54:	11 24       	eor	r1, r1
    1a56:	66 95       	lsr	r22
    1a58:	66 95       	lsr	r22
    1a5a:	66 95       	lsr	r22
    1a5c:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <STR_DisplaySegmentConfig+0x1>
    1a60:	0e 94 84 09 	call	0x1308	; 0x1308 <SevenSeg_Display>
         State = SSD_Display_FirstNumber;
    1a64:	10 92 5d 07 	sts	0x075D, r1	; 0x80075d <State.1656>
         break;
   }      
    1a68:	0f 90       	pop	r0
    1a6a:	df 91       	pop	r29
    1a6c:	cf 91       	pop	r28
    1a6e:	1f 91       	pop	r17
    1a70:	0f 91       	pop	r16
    1a72:	08 95       	ret

00001a74 <SSD_Display_GetSevenSegment>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Display_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    1a74:	00 97       	sbiw	r24, 0x00	; 0
    1a76:	31 f0       	breq	.+12     	; 0x1a84 <SSD_Display_GetSevenSegment+0x10>
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
   }
   else
   {
      /* Return the segment value. */
      *Value = gu8_SevenSegmentValue;
    1a78:	20 91 5f 07 	lds	r18, 0x075F	; 0x80075f <gu8_SevenSegmentValue>
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	20 83       	st	Z, r18
      Display_ErrorState = ERROR_OK;
    1a80:	80 e0       	ldi	r24, 0x00	; 0
    1a82:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
    1a84:	82 e9       	ldi	r24, 0x92	; 146
      Display_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Display_ErrorState;
}
    1a86:	08 95       	ret

00001a88 <SSD_Display_SetSevenSegment>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Display_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
    1a88:	84 36       	cpi	r24, 0x64	; 100
    1a8a:	20 f4       	brcc	.+8      	; 0x1a94 <SSD_Display_SetSevenSegment+0xc>
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
   }
   else
   {
      /* Set the segment value. */
      gu8_SevenSegmentValue = Value;
    1a8c:	80 93 5f 07 	sts	0x075F, r24	; 0x80075f <gu8_SevenSegmentValue>
      Display_ErrorState = ERROR_OK;
    1a90:	80 e0       	ldi	r24, 0x00	; 0
    1a92:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
   {
      /* Set invalid Value error. */
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
    1a94:	81 e9       	ldi	r24, 0x91	; 145
      Display_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Display_ErrorState;
    1a96:	08 95       	ret

00001a98 <HMI_Task>:
#include "Indicator.h"
#include "FreeRTOS.h"
#include "task.h"

void HMI_Task( void *pvParameters )
{
    1a98:	cf 93       	push	r28
    1a9a:	df 93       	push	r29
    1a9c:	00 d0       	rcall	.+0      	; 0x1a9e <HMI_Task+0x6>
    1a9e:	cd b7       	in	r28, 0x3d	; 61
    1aa0:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1aa2:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1aa6:	9a 83       	std	Y+2, r25	; 0x02
    1aa8:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      HMI_MainFunction();
    1aaa:	0e 94 95 0b 	call	0x172a	; 0x172a <HMI_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    1aae:	62 e3       	ldi	r22, 0x32	; 50
    1ab0:	70 e0       	ldi	r23, 0x00	; 0
    1ab2:	ce 01       	movw	r24, r28
    1ab4:	01 96       	adiw	r24, 0x01	; 1
    1ab6:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
    1aba:	f7 cf       	rjmp	.-18     	; 0x1aaa <HMI_Task+0x12>

00001abc <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    1abc:	0e 94 2a 0c 	call	0x1854	; 0x1854 <Indicator_MainFunction>
    1ac0:	fd cf       	rjmp	.-6      	; 0x1abc <Feedback_Task>

00001ac2 <SSD_Display_Task>:
   }
}

void SSD_Display_Task( void *pvParameters )
{
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <SSD_Display_Task+0x6>
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1acc:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1ad0:	9a 83       	std	Y+2, r25	; 0x02
    1ad2:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      SSD_Display_MainFunction();
    1ad4:	0e 94 ed 0c 	call	0x19da	; 0x19da <SSD_Display_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 10);
    1ad8:	6a e0       	ldi	r22, 0x0A	; 10
    1ada:	70 e0       	ldi	r23, 0x00	; 0
    1adc:	ce 01       	movw	r24, r28
    1ade:	01 96       	adiw	r24, 0x01	; 1
    1ae0:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
    1ae4:	f7 cf       	rjmp	.-18     	; 0x1ad4 <SSD_Display_Task+0x12>

00001ae6 <NumberChange_Task>:
}

#if 1
#include "SSD_Display_Interface.h"
void NumberChange_Task( void *pvParameters )
{
    1ae6:	cf 93       	push	r28
    1ae8:	df 93       	push	r29
    1aea:	00 d0       	rcall	.+0      	; 0x1aec <NumberChange_Task+0x6>
    1aec:	cd b7       	in	r28, 0x3d	; 61
    1aee:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1af0:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1af4:	9a 83       	std	Y+2, r25	; 0x02
    1af6:	89 83       	std	Y+1, r24	; 0x01
   
   static uint8_t Number = 1;
   vTaskDelayUntil(&xLastWakeTime, 100);
    1af8:	64 e6       	ldi	r22, 0x64	; 100
    1afa:	70 e0       	ldi	r23, 0x00	; 0
    1afc:	ce 01       	movw	r24, r28
    1afe:	01 96       	adiw	r24, 0x01	; 1
    1b00:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
   for( ;; )
   {
      SSD_Display_SetSevenSegment(Number);
    1b04:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <Number.1967>
    1b08:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <SSD_Display_SetSevenSegment>
      Number++;
    1b0c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <Number.1967>
    1b10:	8f 5f       	subi	r24, 0xFF	; 255
    1b12:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <Number.1967>
      if(Number > 99)
    1b16:	84 36       	cpi	r24, 0x64	; 100
    1b18:	10 f0       	brcs	.+4      	; 0x1b1e <NumberChange_Task+0x38>
      {
         Number = 0;
    1b1a:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <Number.1967>
      }
      vTaskDelayUntil(&xLastWakeTime, 100);
    1b1e:	64 e6       	ldi	r22, 0x64	; 100
    1b20:	70 e0       	ldi	r23, 0x00	; 0
    1b22:	ce 01       	movw	r24, r28
    1b24:	01 96       	adiw	r24, 0x01	; 1
    1b26:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
   }
    1b2a:	ec cf       	rjmp	.-40     	; 0x1b04 <NumberChange_Task+0x1e>

00001b2c <main>:
}
#endif

int main(void)
{   
   xTaskCreate( HMI_Task, "HMI", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1b2c:	e1 2c       	mov	r14, r1
    1b2e:	f1 2c       	mov	r15, r1
    1b30:	01 e0       	ldi	r16, 0x01	; 1
    1b32:	20 e0       	ldi	r18, 0x00	; 0
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	45 e5       	ldi	r20, 0x55	; 85
    1b38:	50 e0       	ldi	r21, 0x00	; 0
    1b3a:	6e ee       	ldi	r22, 0xEE	; 238
    1b3c:	70 e0       	ldi	r23, 0x00	; 0
    1b3e:	8c e4       	ldi	r24, 0x4C	; 76
    1b40:	9d e0       	ldi	r25, 0x0D	; 13
    1b42:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	45 e5       	ldi	r20, 0x55	; 85
    1b4c:	50 e0       	ldi	r21, 0x00	; 0
    1b4e:	62 ef       	ldi	r22, 0xF2	; 242
    1b50:	70 e0       	ldi	r23, 0x00	; 0
    1b52:	8e e5       	ldi	r24, 0x5E	; 94
    1b54:	9d e0       	ldi	r25, 0x0D	; 13
    1b56:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   xTaskCreate( SSD_Display_Task, "SevenSegment", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1b5a:	20 e0       	ldi	r18, 0x00	; 0
    1b5c:	30 e0       	ldi	r19, 0x00	; 0
    1b5e:	45 e5       	ldi	r20, 0x55	; 85
    1b60:	50 e0       	ldi	r21, 0x00	; 0
    1b62:	6c ef       	ldi	r22, 0xFC	; 252
    1b64:	70 e0       	ldi	r23, 0x00	; 0
    1b66:	81 e6       	ldi	r24, 0x61	; 97
    1b68:	9d e0       	ldi	r25, 0x0D	; 13
    1b6a:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   xTaskCreate( NumberChange_Task, "number", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1b6e:	20 e0       	ldi	r18, 0x00	; 0
    1b70:	30 e0       	ldi	r19, 0x00	; 0
    1b72:	45 e5       	ldi	r20, 0x55	; 85
    1b74:	50 e0       	ldi	r21, 0x00	; 0
    1b76:	69 e0       	ldi	r22, 0x09	; 9
    1b78:	71 e0       	ldi	r23, 0x01	; 1
    1b7a:	83 e7       	ldi	r24, 0x73	; 115
    1b7c:	9d e0       	ldi	r25, 0x0D	; 13
    1b7e:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   
   vTaskStartScheduler();
    1b82:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskStartScheduler>
    1b86:	ff cf       	rjmp	.-2      	; 0x1b86 <main+0x5a>

00001b88 <__subsf3>:
    1b88:	50 58       	subi	r21, 0x80	; 128

00001b8a <__addsf3>:
    1b8a:	bb 27       	eor	r27, r27
    1b8c:	aa 27       	eor	r26, r26
    1b8e:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <__addsf3x>
    1b92:	0c 94 26 0f 	jmp	0x1e4c	; 0x1e4c <__fp_round>
    1b96:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fp_pscA>
    1b9a:	38 f0       	brcs	.+14     	; 0x1baa <__addsf3+0x20>
    1b9c:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <__fp_pscB>
    1ba0:	20 f0       	brcs	.+8      	; 0x1baa <__addsf3+0x20>
    1ba2:	39 f4       	brne	.+14     	; 0x1bb2 <__addsf3+0x28>
    1ba4:	9f 3f       	cpi	r25, 0xFF	; 255
    1ba6:	19 f4       	brne	.+6      	; 0x1bae <__addsf3+0x24>
    1ba8:	26 f4       	brtc	.+8      	; 0x1bb2 <__addsf3+0x28>
    1baa:	0c 94 15 0f 	jmp	0x1e2a	; 0x1e2a <__fp_nan>
    1bae:	0e f4       	brtc	.+2      	; 0x1bb2 <__addsf3+0x28>
    1bb0:	e0 95       	com	r30
    1bb2:	e7 fb       	bst	r30, 7
    1bb4:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__fp_inf>

00001bb8 <__addsf3x>:
    1bb8:	e9 2f       	mov	r30, r25
    1bba:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <__fp_split3>
    1bbe:	58 f3       	brcs	.-42     	; 0x1b96 <__addsf3+0xc>
    1bc0:	ba 17       	cp	r27, r26
    1bc2:	62 07       	cpc	r22, r18
    1bc4:	73 07       	cpc	r23, r19
    1bc6:	84 07       	cpc	r24, r20
    1bc8:	95 07       	cpc	r25, r21
    1bca:	20 f0       	brcs	.+8      	; 0x1bd4 <__addsf3x+0x1c>
    1bcc:	79 f4       	brne	.+30     	; 0x1bec <__addsf3x+0x34>
    1bce:	a6 f5       	brtc	.+104    	; 0x1c38 <__addsf3x+0x80>
    1bd0:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__fp_zero>
    1bd4:	0e f4       	brtc	.+2      	; 0x1bd8 <__addsf3x+0x20>
    1bd6:	e0 95       	com	r30
    1bd8:	0b 2e       	mov	r0, r27
    1bda:	ba 2f       	mov	r27, r26
    1bdc:	a0 2d       	mov	r26, r0
    1bde:	0b 01       	movw	r0, r22
    1be0:	b9 01       	movw	r22, r18
    1be2:	90 01       	movw	r18, r0
    1be4:	0c 01       	movw	r0, r24
    1be6:	ca 01       	movw	r24, r20
    1be8:	a0 01       	movw	r20, r0
    1bea:	11 24       	eor	r1, r1
    1bec:	ff 27       	eor	r31, r31
    1bee:	59 1b       	sub	r21, r25
    1bf0:	99 f0       	breq	.+38     	; 0x1c18 <__addsf3x+0x60>
    1bf2:	59 3f       	cpi	r21, 0xF9	; 249
    1bf4:	50 f4       	brcc	.+20     	; 0x1c0a <__addsf3x+0x52>
    1bf6:	50 3e       	cpi	r21, 0xE0	; 224
    1bf8:	68 f1       	brcs	.+90     	; 0x1c54 <__addsf3x+0x9c>
    1bfa:	1a 16       	cp	r1, r26
    1bfc:	f0 40       	sbci	r31, 0x00	; 0
    1bfe:	a2 2f       	mov	r26, r18
    1c00:	23 2f       	mov	r18, r19
    1c02:	34 2f       	mov	r19, r20
    1c04:	44 27       	eor	r20, r20
    1c06:	58 5f       	subi	r21, 0xF8	; 248
    1c08:	f3 cf       	rjmp	.-26     	; 0x1bf0 <__addsf3x+0x38>
    1c0a:	46 95       	lsr	r20
    1c0c:	37 95       	ror	r19
    1c0e:	27 95       	ror	r18
    1c10:	a7 95       	ror	r26
    1c12:	f0 40       	sbci	r31, 0x00	; 0
    1c14:	53 95       	inc	r21
    1c16:	c9 f7       	brne	.-14     	; 0x1c0a <__addsf3x+0x52>
    1c18:	7e f4       	brtc	.+30     	; 0x1c38 <__addsf3x+0x80>
    1c1a:	1f 16       	cp	r1, r31
    1c1c:	ba 0b       	sbc	r27, r26
    1c1e:	62 0b       	sbc	r22, r18
    1c20:	73 0b       	sbc	r23, r19
    1c22:	84 0b       	sbc	r24, r20
    1c24:	ba f0       	brmi	.+46     	; 0x1c54 <__addsf3x+0x9c>
    1c26:	91 50       	subi	r25, 0x01	; 1
    1c28:	a1 f0       	breq	.+40     	; 0x1c52 <__addsf3x+0x9a>
    1c2a:	ff 0f       	add	r31, r31
    1c2c:	bb 1f       	adc	r27, r27
    1c2e:	66 1f       	adc	r22, r22
    1c30:	77 1f       	adc	r23, r23
    1c32:	88 1f       	adc	r24, r24
    1c34:	c2 f7       	brpl	.-16     	; 0x1c26 <__addsf3x+0x6e>
    1c36:	0e c0       	rjmp	.+28     	; 0x1c54 <__addsf3x+0x9c>
    1c38:	ba 0f       	add	r27, r26
    1c3a:	62 1f       	adc	r22, r18
    1c3c:	73 1f       	adc	r23, r19
    1c3e:	84 1f       	adc	r24, r20
    1c40:	48 f4       	brcc	.+18     	; 0x1c54 <__addsf3x+0x9c>
    1c42:	87 95       	ror	r24
    1c44:	77 95       	ror	r23
    1c46:	67 95       	ror	r22
    1c48:	b7 95       	ror	r27
    1c4a:	f7 95       	ror	r31
    1c4c:	9e 3f       	cpi	r25, 0xFE	; 254
    1c4e:	08 f0       	brcs	.+2      	; 0x1c52 <__addsf3x+0x9a>
    1c50:	b0 cf       	rjmp	.-160    	; 0x1bb2 <__addsf3+0x28>
    1c52:	93 95       	inc	r25
    1c54:	88 0f       	add	r24, r24
    1c56:	08 f0       	brcs	.+2      	; 0x1c5a <__addsf3x+0xa2>
    1c58:	99 27       	eor	r25, r25
    1c5a:	ee 0f       	add	r30, r30
    1c5c:	97 95       	ror	r25
    1c5e:	87 95       	ror	r24
    1c60:	08 95       	ret

00001c62 <__divsf3>:
    1c62:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <__divsf3x>
    1c66:	0c 94 26 0f 	jmp	0x1e4c	; 0x1e4c <__fp_round>
    1c6a:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <__fp_pscB>
    1c6e:	58 f0       	brcs	.+22     	; 0x1c86 <__divsf3+0x24>
    1c70:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fp_pscA>
    1c74:	40 f0       	brcs	.+16     	; 0x1c86 <__divsf3+0x24>
    1c76:	29 f4       	brne	.+10     	; 0x1c82 <__divsf3+0x20>
    1c78:	5f 3f       	cpi	r21, 0xFF	; 255
    1c7a:	29 f0       	breq	.+10     	; 0x1c86 <__divsf3+0x24>
    1c7c:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__fp_inf>
    1c80:	51 11       	cpse	r21, r1
    1c82:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <__fp_szero>
    1c86:	0c 94 15 0f 	jmp	0x1e2a	; 0x1e2a <__fp_nan>

00001c8a <__divsf3x>:
    1c8a:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <__fp_split3>
    1c8e:	68 f3       	brcs	.-38     	; 0x1c6a <__divsf3+0x8>

00001c90 <__divsf3_pse>:
    1c90:	99 23       	and	r25, r25
    1c92:	b1 f3       	breq	.-20     	; 0x1c80 <__divsf3+0x1e>
    1c94:	55 23       	and	r21, r21
    1c96:	91 f3       	breq	.-28     	; 0x1c7c <__divsf3+0x1a>
    1c98:	95 1b       	sub	r25, r21
    1c9a:	55 0b       	sbc	r21, r21
    1c9c:	bb 27       	eor	r27, r27
    1c9e:	aa 27       	eor	r26, r26
    1ca0:	62 17       	cp	r22, r18
    1ca2:	73 07       	cpc	r23, r19
    1ca4:	84 07       	cpc	r24, r20
    1ca6:	38 f0       	brcs	.+14     	; 0x1cb6 <__divsf3_pse+0x26>
    1ca8:	9f 5f       	subi	r25, 0xFF	; 255
    1caa:	5f 4f       	sbci	r21, 0xFF	; 255
    1cac:	22 0f       	add	r18, r18
    1cae:	33 1f       	adc	r19, r19
    1cb0:	44 1f       	adc	r20, r20
    1cb2:	aa 1f       	adc	r26, r26
    1cb4:	a9 f3       	breq	.-22     	; 0x1ca0 <__divsf3_pse+0x10>
    1cb6:	35 d0       	rcall	.+106    	; 0x1d22 <__divsf3_pse+0x92>
    1cb8:	0e 2e       	mov	r0, r30
    1cba:	3a f0       	brmi	.+14     	; 0x1cca <__divsf3_pse+0x3a>
    1cbc:	e0 e8       	ldi	r30, 0x80	; 128
    1cbe:	32 d0       	rcall	.+100    	; 0x1d24 <__divsf3_pse+0x94>
    1cc0:	91 50       	subi	r25, 0x01	; 1
    1cc2:	50 40       	sbci	r21, 0x00	; 0
    1cc4:	e6 95       	lsr	r30
    1cc6:	00 1c       	adc	r0, r0
    1cc8:	ca f7       	brpl	.-14     	; 0x1cbc <__divsf3_pse+0x2c>
    1cca:	2b d0       	rcall	.+86     	; 0x1d22 <__divsf3_pse+0x92>
    1ccc:	fe 2f       	mov	r31, r30
    1cce:	29 d0       	rcall	.+82     	; 0x1d22 <__divsf3_pse+0x92>
    1cd0:	66 0f       	add	r22, r22
    1cd2:	77 1f       	adc	r23, r23
    1cd4:	88 1f       	adc	r24, r24
    1cd6:	bb 1f       	adc	r27, r27
    1cd8:	26 17       	cp	r18, r22
    1cda:	37 07       	cpc	r19, r23
    1cdc:	48 07       	cpc	r20, r24
    1cde:	ab 07       	cpc	r26, r27
    1ce0:	b0 e8       	ldi	r27, 0x80	; 128
    1ce2:	09 f0       	breq	.+2      	; 0x1ce6 <__divsf3_pse+0x56>
    1ce4:	bb 0b       	sbc	r27, r27
    1ce6:	80 2d       	mov	r24, r0
    1ce8:	bf 01       	movw	r22, r30
    1cea:	ff 27       	eor	r31, r31
    1cec:	93 58       	subi	r25, 0x83	; 131
    1cee:	5f 4f       	sbci	r21, 0xFF	; 255
    1cf0:	3a f0       	brmi	.+14     	; 0x1d00 <__divsf3_pse+0x70>
    1cf2:	9e 3f       	cpi	r25, 0xFE	; 254
    1cf4:	51 05       	cpc	r21, r1
    1cf6:	78 f0       	brcs	.+30     	; 0x1d16 <__divsf3_pse+0x86>
    1cf8:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__fp_inf>
    1cfc:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <__fp_szero>
    1d00:	5f 3f       	cpi	r21, 0xFF	; 255
    1d02:	e4 f3       	brlt	.-8      	; 0x1cfc <__divsf3_pse+0x6c>
    1d04:	98 3e       	cpi	r25, 0xE8	; 232
    1d06:	d4 f3       	brlt	.-12     	; 0x1cfc <__divsf3_pse+0x6c>
    1d08:	86 95       	lsr	r24
    1d0a:	77 95       	ror	r23
    1d0c:	67 95       	ror	r22
    1d0e:	b7 95       	ror	r27
    1d10:	f7 95       	ror	r31
    1d12:	9f 5f       	subi	r25, 0xFF	; 255
    1d14:	c9 f7       	brne	.-14     	; 0x1d08 <__divsf3_pse+0x78>
    1d16:	88 0f       	add	r24, r24
    1d18:	91 1d       	adc	r25, r1
    1d1a:	96 95       	lsr	r25
    1d1c:	87 95       	ror	r24
    1d1e:	97 f9       	bld	r25, 7
    1d20:	08 95       	ret
    1d22:	e1 e0       	ldi	r30, 0x01	; 1
    1d24:	66 0f       	add	r22, r22
    1d26:	77 1f       	adc	r23, r23
    1d28:	88 1f       	adc	r24, r24
    1d2a:	bb 1f       	adc	r27, r27
    1d2c:	62 17       	cp	r22, r18
    1d2e:	73 07       	cpc	r23, r19
    1d30:	84 07       	cpc	r24, r20
    1d32:	ba 07       	cpc	r27, r26
    1d34:	20 f0       	brcs	.+8      	; 0x1d3e <__divsf3_pse+0xae>
    1d36:	62 1b       	sub	r22, r18
    1d38:	73 0b       	sbc	r23, r19
    1d3a:	84 0b       	sbc	r24, r20
    1d3c:	ba 0b       	sbc	r27, r26
    1d3e:	ee 1f       	adc	r30, r30
    1d40:	88 f7       	brcc	.-30     	; 0x1d24 <__divsf3_pse+0x94>
    1d42:	e0 95       	com	r30
    1d44:	08 95       	ret

00001d46 <__fixunssfsi>:
    1d46:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <__fp_splitA>
    1d4a:	88 f0       	brcs	.+34     	; 0x1d6e <__fixunssfsi+0x28>
    1d4c:	9f 57       	subi	r25, 0x7F	; 127
    1d4e:	98 f0       	brcs	.+38     	; 0x1d76 <__fixunssfsi+0x30>
    1d50:	b9 2f       	mov	r27, r25
    1d52:	99 27       	eor	r25, r25
    1d54:	b7 51       	subi	r27, 0x17	; 23
    1d56:	b0 f0       	brcs	.+44     	; 0x1d84 <__fixunssfsi+0x3e>
    1d58:	e1 f0       	breq	.+56     	; 0x1d92 <__fixunssfsi+0x4c>
    1d5a:	66 0f       	add	r22, r22
    1d5c:	77 1f       	adc	r23, r23
    1d5e:	88 1f       	adc	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	1a f0       	brmi	.+6      	; 0x1d6a <__fixunssfsi+0x24>
    1d64:	ba 95       	dec	r27
    1d66:	c9 f7       	brne	.-14     	; 0x1d5a <__fixunssfsi+0x14>
    1d68:	14 c0       	rjmp	.+40     	; 0x1d92 <__fixunssfsi+0x4c>
    1d6a:	b1 30       	cpi	r27, 0x01	; 1
    1d6c:	91 f0       	breq	.+36     	; 0x1d92 <__fixunssfsi+0x4c>
    1d6e:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <__fp_zero>
    1d72:	b1 e0       	ldi	r27, 0x01	; 1
    1d74:	08 95       	ret
    1d76:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__fp_zero>
    1d7a:	67 2f       	mov	r22, r23
    1d7c:	78 2f       	mov	r23, r24
    1d7e:	88 27       	eor	r24, r24
    1d80:	b8 5f       	subi	r27, 0xF8	; 248
    1d82:	39 f0       	breq	.+14     	; 0x1d92 <__fixunssfsi+0x4c>
    1d84:	b9 3f       	cpi	r27, 0xF9	; 249
    1d86:	cc f3       	brlt	.-14     	; 0x1d7a <__fixunssfsi+0x34>
    1d88:	86 95       	lsr	r24
    1d8a:	77 95       	ror	r23
    1d8c:	67 95       	ror	r22
    1d8e:	b3 95       	inc	r27
    1d90:	d9 f7       	brne	.-10     	; 0x1d88 <__fixunssfsi+0x42>
    1d92:	3e f4       	brtc	.+14     	; 0x1da2 <__fixunssfsi+0x5c>
    1d94:	90 95       	com	r25
    1d96:	80 95       	com	r24
    1d98:	70 95       	com	r23
    1d9a:	61 95       	neg	r22
    1d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9e:	8f 4f       	sbci	r24, 0xFF	; 255
    1da0:	9f 4f       	sbci	r25, 0xFF	; 255
    1da2:	08 95       	ret

00001da4 <__floatunsisf>:
    1da4:	e8 94       	clt
    1da6:	09 c0       	rjmp	.+18     	; 0x1dba <__floatsisf+0x12>

00001da8 <__floatsisf>:
    1da8:	97 fb       	bst	r25, 7
    1daa:	3e f4       	brtc	.+14     	; 0x1dba <__floatsisf+0x12>
    1dac:	90 95       	com	r25
    1dae:	80 95       	com	r24
    1db0:	70 95       	com	r23
    1db2:	61 95       	neg	r22
    1db4:	7f 4f       	sbci	r23, 0xFF	; 255
    1db6:	8f 4f       	sbci	r24, 0xFF	; 255
    1db8:	9f 4f       	sbci	r25, 0xFF	; 255
    1dba:	99 23       	and	r25, r25
    1dbc:	a9 f0       	breq	.+42     	; 0x1de8 <__floatsisf+0x40>
    1dbe:	f9 2f       	mov	r31, r25
    1dc0:	96 e9       	ldi	r25, 0x96	; 150
    1dc2:	bb 27       	eor	r27, r27
    1dc4:	93 95       	inc	r25
    1dc6:	f6 95       	lsr	r31
    1dc8:	87 95       	ror	r24
    1dca:	77 95       	ror	r23
    1dcc:	67 95       	ror	r22
    1dce:	b7 95       	ror	r27
    1dd0:	f1 11       	cpse	r31, r1
    1dd2:	f8 cf       	rjmp	.-16     	; 0x1dc4 <__floatsisf+0x1c>
    1dd4:	fa f4       	brpl	.+62     	; 0x1e14 <__floatsisf+0x6c>
    1dd6:	bb 0f       	add	r27, r27
    1dd8:	11 f4       	brne	.+4      	; 0x1dde <__floatsisf+0x36>
    1dda:	60 ff       	sbrs	r22, 0
    1ddc:	1b c0       	rjmp	.+54     	; 0x1e14 <__floatsisf+0x6c>
    1dde:	6f 5f       	subi	r22, 0xFF	; 255
    1de0:	7f 4f       	sbci	r23, 0xFF	; 255
    1de2:	8f 4f       	sbci	r24, 0xFF	; 255
    1de4:	9f 4f       	sbci	r25, 0xFF	; 255
    1de6:	16 c0       	rjmp	.+44     	; 0x1e14 <__floatsisf+0x6c>
    1de8:	88 23       	and	r24, r24
    1dea:	11 f0       	breq	.+4      	; 0x1df0 <__floatsisf+0x48>
    1dec:	96 e9       	ldi	r25, 0x96	; 150
    1dee:	11 c0       	rjmp	.+34     	; 0x1e12 <__floatsisf+0x6a>
    1df0:	77 23       	and	r23, r23
    1df2:	21 f0       	breq	.+8      	; 0x1dfc <__floatsisf+0x54>
    1df4:	9e e8       	ldi	r25, 0x8E	; 142
    1df6:	87 2f       	mov	r24, r23
    1df8:	76 2f       	mov	r23, r22
    1dfa:	05 c0       	rjmp	.+10     	; 0x1e06 <__floatsisf+0x5e>
    1dfc:	66 23       	and	r22, r22
    1dfe:	71 f0       	breq	.+28     	; 0x1e1c <__floatsisf+0x74>
    1e00:	96 e8       	ldi	r25, 0x86	; 134
    1e02:	86 2f       	mov	r24, r22
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	60 e0       	ldi	r22, 0x00	; 0
    1e08:	2a f0       	brmi	.+10     	; 0x1e14 <__floatsisf+0x6c>
    1e0a:	9a 95       	dec	r25
    1e0c:	66 0f       	add	r22, r22
    1e0e:	77 1f       	adc	r23, r23
    1e10:	88 1f       	adc	r24, r24
    1e12:	da f7       	brpl	.-10     	; 0x1e0a <__floatsisf+0x62>
    1e14:	88 0f       	add	r24, r24
    1e16:	96 95       	lsr	r25
    1e18:	87 95       	ror	r24
    1e1a:	97 f9       	bld	r25, 7
    1e1c:	08 95       	ret

00001e1e <__fp_inf>:
    1e1e:	97 f9       	bld	r25, 7
    1e20:	9f 67       	ori	r25, 0x7F	; 127
    1e22:	80 e8       	ldi	r24, 0x80	; 128
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	60 e0       	ldi	r22, 0x00	; 0
    1e28:	08 95       	ret

00001e2a <__fp_nan>:
    1e2a:	9f ef       	ldi	r25, 0xFF	; 255
    1e2c:	80 ec       	ldi	r24, 0xC0	; 192
    1e2e:	08 95       	ret

00001e30 <__fp_pscA>:
    1e30:	00 24       	eor	r0, r0
    1e32:	0a 94       	dec	r0
    1e34:	16 16       	cp	r1, r22
    1e36:	17 06       	cpc	r1, r23
    1e38:	18 06       	cpc	r1, r24
    1e3a:	09 06       	cpc	r0, r25
    1e3c:	08 95       	ret

00001e3e <__fp_pscB>:
    1e3e:	00 24       	eor	r0, r0
    1e40:	0a 94       	dec	r0
    1e42:	12 16       	cp	r1, r18
    1e44:	13 06       	cpc	r1, r19
    1e46:	14 06       	cpc	r1, r20
    1e48:	05 06       	cpc	r0, r21
    1e4a:	08 95       	ret

00001e4c <__fp_round>:
    1e4c:	09 2e       	mov	r0, r25
    1e4e:	03 94       	inc	r0
    1e50:	00 0c       	add	r0, r0
    1e52:	11 f4       	brne	.+4      	; 0x1e58 <__fp_round+0xc>
    1e54:	88 23       	and	r24, r24
    1e56:	52 f0       	brmi	.+20     	; 0x1e6c <__fp_round+0x20>
    1e58:	bb 0f       	add	r27, r27
    1e5a:	40 f4       	brcc	.+16     	; 0x1e6c <__fp_round+0x20>
    1e5c:	bf 2b       	or	r27, r31
    1e5e:	11 f4       	brne	.+4      	; 0x1e64 <__fp_round+0x18>
    1e60:	60 ff       	sbrs	r22, 0
    1e62:	04 c0       	rjmp	.+8      	; 0x1e6c <__fp_round+0x20>
    1e64:	6f 5f       	subi	r22, 0xFF	; 255
    1e66:	7f 4f       	sbci	r23, 0xFF	; 255
    1e68:	8f 4f       	sbci	r24, 0xFF	; 255
    1e6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e6c:	08 95       	ret

00001e6e <__fp_split3>:
    1e6e:	57 fd       	sbrc	r21, 7
    1e70:	90 58       	subi	r25, 0x80	; 128
    1e72:	44 0f       	add	r20, r20
    1e74:	55 1f       	adc	r21, r21
    1e76:	59 f0       	breq	.+22     	; 0x1e8e <__fp_splitA+0x10>
    1e78:	5f 3f       	cpi	r21, 0xFF	; 255
    1e7a:	71 f0       	breq	.+28     	; 0x1e98 <__fp_splitA+0x1a>
    1e7c:	47 95       	ror	r20

00001e7e <__fp_splitA>:
    1e7e:	88 0f       	add	r24, r24
    1e80:	97 fb       	bst	r25, 7
    1e82:	99 1f       	adc	r25, r25
    1e84:	61 f0       	breq	.+24     	; 0x1e9e <__fp_splitA+0x20>
    1e86:	9f 3f       	cpi	r25, 0xFF	; 255
    1e88:	79 f0       	breq	.+30     	; 0x1ea8 <__fp_splitA+0x2a>
    1e8a:	87 95       	ror	r24
    1e8c:	08 95       	ret
    1e8e:	12 16       	cp	r1, r18
    1e90:	13 06       	cpc	r1, r19
    1e92:	14 06       	cpc	r1, r20
    1e94:	55 1f       	adc	r21, r21
    1e96:	f2 cf       	rjmp	.-28     	; 0x1e7c <__fp_split3+0xe>
    1e98:	46 95       	lsr	r20
    1e9a:	f1 df       	rcall	.-30     	; 0x1e7e <__fp_splitA>
    1e9c:	08 c0       	rjmp	.+16     	; 0x1eae <__fp_splitA+0x30>
    1e9e:	16 16       	cp	r1, r22
    1ea0:	17 06       	cpc	r1, r23
    1ea2:	18 06       	cpc	r1, r24
    1ea4:	99 1f       	adc	r25, r25
    1ea6:	f1 cf       	rjmp	.-30     	; 0x1e8a <__fp_splitA+0xc>
    1ea8:	86 95       	lsr	r24
    1eaa:	71 05       	cpc	r23, r1
    1eac:	61 05       	cpc	r22, r1
    1eae:	08 94       	sec
    1eb0:	08 95       	ret

00001eb2 <__fp_zero>:
    1eb2:	e8 94       	clt

00001eb4 <__fp_szero>:
    1eb4:	bb 27       	eor	r27, r27
    1eb6:	66 27       	eor	r22, r22
    1eb8:	77 27       	eor	r23, r23
    1eba:	cb 01       	movw	r24, r22
    1ebc:	97 f9       	bld	r25, 7
    1ebe:	08 95       	ret

00001ec0 <__mulsf3>:
    1ec0:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <__mulsf3x>
    1ec4:	0c 94 26 0f 	jmp	0x1e4c	; 0x1e4c <__fp_round>
    1ec8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fp_pscA>
    1ecc:	38 f0       	brcs	.+14     	; 0x1edc <__mulsf3+0x1c>
    1ece:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <__fp_pscB>
    1ed2:	20 f0       	brcs	.+8      	; 0x1edc <__mulsf3+0x1c>
    1ed4:	95 23       	and	r25, r21
    1ed6:	11 f0       	breq	.+4      	; 0x1edc <__mulsf3+0x1c>
    1ed8:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__fp_inf>
    1edc:	0c 94 15 0f 	jmp	0x1e2a	; 0x1e2a <__fp_nan>
    1ee0:	11 24       	eor	r1, r1
    1ee2:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <__fp_szero>

00001ee6 <__mulsf3x>:
    1ee6:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <__fp_split3>
    1eea:	70 f3       	brcs	.-36     	; 0x1ec8 <__mulsf3+0x8>

00001eec <__mulsf3_pse>:
    1eec:	95 9f       	mul	r25, r21
    1eee:	c1 f3       	breq	.-16     	; 0x1ee0 <__mulsf3+0x20>
    1ef0:	95 0f       	add	r25, r21
    1ef2:	50 e0       	ldi	r21, 0x00	; 0
    1ef4:	55 1f       	adc	r21, r21
    1ef6:	62 9f       	mul	r22, r18
    1ef8:	f0 01       	movw	r30, r0
    1efa:	72 9f       	mul	r23, r18
    1efc:	bb 27       	eor	r27, r27
    1efe:	f0 0d       	add	r31, r0
    1f00:	b1 1d       	adc	r27, r1
    1f02:	63 9f       	mul	r22, r19
    1f04:	aa 27       	eor	r26, r26
    1f06:	f0 0d       	add	r31, r0
    1f08:	b1 1d       	adc	r27, r1
    1f0a:	aa 1f       	adc	r26, r26
    1f0c:	64 9f       	mul	r22, r20
    1f0e:	66 27       	eor	r22, r22
    1f10:	b0 0d       	add	r27, r0
    1f12:	a1 1d       	adc	r26, r1
    1f14:	66 1f       	adc	r22, r22
    1f16:	82 9f       	mul	r24, r18
    1f18:	22 27       	eor	r18, r18
    1f1a:	b0 0d       	add	r27, r0
    1f1c:	a1 1d       	adc	r26, r1
    1f1e:	62 1f       	adc	r22, r18
    1f20:	73 9f       	mul	r23, r19
    1f22:	b0 0d       	add	r27, r0
    1f24:	a1 1d       	adc	r26, r1
    1f26:	62 1f       	adc	r22, r18
    1f28:	83 9f       	mul	r24, r19
    1f2a:	a0 0d       	add	r26, r0
    1f2c:	61 1d       	adc	r22, r1
    1f2e:	22 1f       	adc	r18, r18
    1f30:	74 9f       	mul	r23, r20
    1f32:	33 27       	eor	r19, r19
    1f34:	a0 0d       	add	r26, r0
    1f36:	61 1d       	adc	r22, r1
    1f38:	23 1f       	adc	r18, r19
    1f3a:	84 9f       	mul	r24, r20
    1f3c:	60 0d       	add	r22, r0
    1f3e:	21 1d       	adc	r18, r1
    1f40:	82 2f       	mov	r24, r18
    1f42:	76 2f       	mov	r23, r22
    1f44:	6a 2f       	mov	r22, r26
    1f46:	11 24       	eor	r1, r1
    1f48:	9f 57       	subi	r25, 0x7F	; 127
    1f4a:	50 40       	sbci	r21, 0x00	; 0
    1f4c:	9a f0       	brmi	.+38     	; 0x1f74 <__mulsf3_pse+0x88>
    1f4e:	f1 f0       	breq	.+60     	; 0x1f8c <__mulsf3_pse+0xa0>
    1f50:	88 23       	and	r24, r24
    1f52:	4a f0       	brmi	.+18     	; 0x1f66 <__mulsf3_pse+0x7a>
    1f54:	ee 0f       	add	r30, r30
    1f56:	ff 1f       	adc	r31, r31
    1f58:	bb 1f       	adc	r27, r27
    1f5a:	66 1f       	adc	r22, r22
    1f5c:	77 1f       	adc	r23, r23
    1f5e:	88 1f       	adc	r24, r24
    1f60:	91 50       	subi	r25, 0x01	; 1
    1f62:	50 40       	sbci	r21, 0x00	; 0
    1f64:	a9 f7       	brne	.-22     	; 0x1f50 <__mulsf3_pse+0x64>
    1f66:	9e 3f       	cpi	r25, 0xFE	; 254
    1f68:	51 05       	cpc	r21, r1
    1f6a:	80 f0       	brcs	.+32     	; 0x1f8c <__mulsf3_pse+0xa0>
    1f6c:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__fp_inf>
    1f70:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <__fp_szero>
    1f74:	5f 3f       	cpi	r21, 0xFF	; 255
    1f76:	e4 f3       	brlt	.-8      	; 0x1f70 <__mulsf3_pse+0x84>
    1f78:	98 3e       	cpi	r25, 0xE8	; 232
    1f7a:	d4 f3       	brlt	.-12     	; 0x1f70 <__mulsf3_pse+0x84>
    1f7c:	86 95       	lsr	r24
    1f7e:	77 95       	ror	r23
    1f80:	67 95       	ror	r22
    1f82:	b7 95       	ror	r27
    1f84:	f7 95       	ror	r31
    1f86:	e7 95       	ror	r30
    1f88:	9f 5f       	subi	r25, 0xFF	; 255
    1f8a:	c1 f7       	brne	.-16     	; 0x1f7c <__mulsf3_pse+0x90>
    1f8c:	fe 2b       	or	r31, r30
    1f8e:	88 0f       	add	r24, r24
    1f90:	91 1d       	adc	r25, r1
    1f92:	96 95       	lsr	r25
    1f94:	87 95       	ror	r24
    1f96:	97 f9       	bld	r25, 7
    1f98:	08 95       	ret

00001f9a <_exit>:
    1f9a:	f8 94       	cli

00001f9c <__stop_program>:
    1f9c:	ff cf       	rjmp	.-2      	; 0x1f9c <__stop_program>
